/*!
 * puppeteer-extra-plugin-portal v3.1.0 by claabs
 * https://github.com/claabs/puppeteer-extra-plugin-portal
 * @license MIT
 */
import { PuppeteerExtraPlugin } from 'puppeteer-extra-plugin';
import { URL } from 'url';
import express from 'express';
import http from 'http';
import path from 'path';
import https from 'https';
import { once } from 'events';
import { createProxyMiddleware } from 'http-proxy-middleware';
import urlJoin from 'url-join';

const frontendRoot = path.extname(__filename) === '.ts'
    ? path.join(__dirname, '..', 'dist', 'frontend')
    : path.join(__dirname, 'frontend');
class PortalServer {
    constructor(props) {
        var _a;
        this.openPortals = new Set();
        this.targetIdProxyMap = new Map();
        this.serverOpts = {};
        this.proxyLogger = () => {
            const subLogger = this.debug.extend('http-proxy-middleware');
            return {
                log: subLogger,
                debug: subLogger,
                error: subLogger,
                info: subLogger,
                warn: subLogger,
            };
        };
        this.debug = props.debug;
        this.listenOpts = props.listenOpts;
        this.serverOpts = props.serverOpts || {};
        this.webPortalBaseUrl = props.webPortalBaseUrl;
        this.app = express();
        this.router = express.Router();
        this.router.use(express.static(frontendRoot));
        this.basePath = ((_a = props.webPortalBaseUrl) === null || _a === void 0 ? void 0 : _a.pathname) || '/';
        this.debug('basePath:', this.basePath);
        this.app.use(this.basePath, this.router);
    }
    upgradeHandler(req, socket, head) {
        const targetId = req.url.split('/').slice(-1)[0];
        const proxyMiddleware = this.targetIdProxyMap.get(targetId);
        if (proxyMiddleware === null || proxyMiddleware === void 0 ? void 0 : proxyMiddleware.upgrade) {
            proxyMiddleware.upgrade(req, socket, head);
        }
        else {
            this.debug(`No proxy middleware found for targetId "${targetId}" when upgrading`);
        }
    }
    async openServer() {
        if (!this.server) {
            this.debug('Starting the express server...');
            if (Object.entries(this.serverOpts).length > 0) {
                // The serverOpts are mostly HTTPS-related options, so use `https` if there's any options set
                this.server = https.createServer(this.serverOpts, this.app);
            }
            else {
                // Otherwise, we just use `http`. This is pretty much the first half of `this.app.listen()`
                this.server = http.createServer(this.app);
            }
            this.server = this.app.listen(this.listenOpts);
            await once(this.server, 'listening');
            this.debug('Express server now listening');
            // http-proxy-middleware requires a `server` object to add the upgrade path.
            // Since it doesn't exist when setting up the middleware, we need to pass it to it after we start listening on the server
            this.server.on('upgrade', this.upgradeHandler.bind(this));
        }
    }
    async closeServer() {
        if (this.server) {
            this.server.on('close', () => {
                this.debug('The express server has been closed');
            });
            this.debug('No more open portals, shutting down the express server...');
            this.server.close();
            this.server = undefined;
        }
    }
    async hostPortal(params) {
        this.debug('params.wsUrl', params.wsUrl);
        const wsProxy = createProxyMiddleware(urlJoin(this.basePath, `/ws/${params.targetId}`), {
            target: params.wsUrl,
            logLevel: this.debug.enabled ? 'debug' : 'silent',
            logProvider: this.proxyLogger,
            ws: true,
            changeOrigin: true,
        });
        this.targetIdProxyMap.set(params.targetId, wsProxy);
        this.router.use('/ws', wsProxy); // Proxy websockets
        if (this.openPortals.size === 0) {
            await this.openServer();
        }
        this.openPortals.add(params.targetId);
        const fullUrl = this.webPortalBaseUrl;
        fullUrl.searchParams.set('targetId', params.targetId);
        this.debug('fullUrl', fullUrl.toString());
        return fullUrl.toString();
    }
    async closePortal(targetId) {
        this.debug(`Closing portal for targetId "${targetId}""`);
        this.openPortals.delete(targetId);
        this.targetIdProxyMap.delete(targetId);
        if (this.openPortals.size === 0)
            this.closeServer();
    }
    hasOpenPortal(targetId) {
        return this.openPortals.has(targetId);
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
const getPageTargetId = (page) => {
    // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-explicit-any
    return page.target()._targetId;
};
/**
 * A puppeteer-extra plugin to let you interact with headless sessions remotely.
 * @noInheritDoc
 */
class PuppeteerExtraPluginPortal extends PuppeteerExtraPlugin {
    constructor(opts) {
        var _a, _b;
        super(opts);
        this.debug('Initialized', this.opts);
        this.webPortalBaseUrl = new URL(this.opts.webPortalConfig.baseUrl);
        this.portalServer = new PortalServer({
            debug: this.debug,
            webPortalBaseUrl: this.webPortalBaseUrl,
            listenOpts: (_a = this.opts.webPortalConfig) === null || _a === void 0 ? void 0 : _a.listenOpts,
            serverOpts: (_b = this.opts.webPortalConfig) === null || _b === void 0 ? void 0 : _b.serverOpts,
        });
    }
    get name() {
        return 'portal';
    }
    get defaults() {
        return {
            webPortalConfig: {
                listenOpts: {
                    port: 3000,
                },
                baseUrl: 'http://localhost:3000',
            },
        };
    }
    async openPortal(page) {
        const targetId = getPageTargetId(page);
        const browser = page.browser();
        const wsUrl = browser.wsEndpoint();
        const url = await this.portalServer.hostPortal({
            wsUrl,
            targetId,
        });
        return url;
    }
    async closePortal(page) {
        const targetId = getPageTargetId(page);
        await this.portalServer.closePortal(targetId);
    }
    hasOpenPortal(page) {
        const targetId = getPageTargetId(page);
        return this.portalServer.hasOpenPortal(targetId);
    }
    async closeAllBrowserPortals(browser) {
        this.debug('Closing all portals for browser');
        const pages = await browser.pages();
        const closePortalPromises = pages.map(this.closePortal.bind(this));
        await Promise.all(closePortalPromises);
    }
    addCustomMethods(prop) {
        /* eslint-disable no-param-reassign */
        prop.openPortal = async () => this.openPortal(prop);
        prop.closePortal = async () => this.closePortal(prop);
        prop.hasOpenPortal = () => this.hasOpenPortal(prop);
    }
    async onPageCreated(page) {
        this.debug('onPageCreated', page.url());
        this.addCustomMethods(page);
        page.on('close', () => this.closePortal(page));
    }
    /** Add additions to already existing pages  */
    async onBrowser(browser) {
        const pages = await browser.pages();
        pages.forEach((page) => this.addCustomMethods(page));
        browser.on('disconnected', () => this.closeAllBrowserPortals(browser));
    }
}
/** Default export, PuppeteerExtraPluginRecaptcha  */
const defaultExport = (options) => {
    return new PuppeteerExtraPluginPortal(options);
};

export default defaultExport;
export { PuppeteerExtraPluginPortal };
//# sourceMappingURL=index.esm.js.map

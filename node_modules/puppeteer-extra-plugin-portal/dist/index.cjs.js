/*!
 * puppeteer-extra-plugin-portal v3.1.0 by claabs
 * https://github.com/claabs/puppeteer-extra-plugin-portal
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var puppeteerExtraPlugin = require('puppeteer-extra-plugin');
var url = require('url');
var express = require('express');
var http = require('http');
var path = require('path');
var https = require('https');
var events = require('events');
var httpProxyMiddleware = require('http-proxy-middleware');
var urlJoin = require('url-join');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var urlJoin__default = /*#__PURE__*/_interopDefaultLegacy(urlJoin);

const frontendRoot = path__default['default'].extname(__filename) === '.ts'
    ? path__default['default'].join(__dirname, '..', 'dist', 'frontend')
    : path__default['default'].join(__dirname, 'frontend');
class PortalServer {
    constructor(props) {
        var _a;
        this.openPortals = new Set();
        this.targetIdProxyMap = new Map();
        this.serverOpts = {};
        this.proxyLogger = () => {
            const subLogger = this.debug.extend('http-proxy-middleware');
            return {
                log: subLogger,
                debug: subLogger,
                error: subLogger,
                info: subLogger,
                warn: subLogger,
            };
        };
        this.debug = props.debug;
        this.listenOpts = props.listenOpts;
        this.serverOpts = props.serverOpts || {};
        this.webPortalBaseUrl = props.webPortalBaseUrl;
        this.app = express__default['default']();
        this.router = express__default['default'].Router();
        this.router.use(express__default['default'].static(frontendRoot));
        this.basePath = ((_a = props.webPortalBaseUrl) === null || _a === void 0 ? void 0 : _a.pathname) || '/';
        this.debug('basePath:', this.basePath);
        this.app.use(this.basePath, this.router);
    }
    upgradeHandler(req, socket, head) {
        const targetId = req.url.split('/').slice(-1)[0];
        const proxyMiddleware = this.targetIdProxyMap.get(targetId);
        if (proxyMiddleware === null || proxyMiddleware === void 0 ? void 0 : proxyMiddleware.upgrade) {
            proxyMiddleware.upgrade(req, socket, head);
        }
        else {
            this.debug(`No proxy middleware found for targetId "${targetId}" when upgrading`);
        }
    }
    async openServer() {
        if (!this.server) {
            this.debug('Starting the express server...');
            if (Object.entries(this.serverOpts).length > 0) {
                // The serverOpts are mostly HTTPS-related options, so use `https` if there's any options set
                this.server = https__default['default'].createServer(this.serverOpts, this.app);
            }
            else {
                // Otherwise, we just use `http`. This is pretty much the first half of `this.app.listen()`
                this.server = http__default['default'].createServer(this.app);
            }
            this.server = this.app.listen(this.listenOpts);
            await events.once(this.server, 'listening');
            this.debug('Express server now listening');
            // http-proxy-middleware requires a `server` object to add the upgrade path.
            // Since it doesn't exist when setting up the middleware, we need to pass it to it after we start listening on the server
            this.server.on('upgrade', this.upgradeHandler.bind(this));
        }
    }
    async closeServer() {
        if (this.server) {
            this.server.on('close', () => {
                this.debug('The express server has been closed');
            });
            this.debug('No more open portals, shutting down the express server...');
            this.server.close();
            this.server = undefined;
        }
    }
    async hostPortal(params) {
        this.debug('params.wsUrl', params.wsUrl);
        const wsProxy = httpProxyMiddleware.createProxyMiddleware(urlJoin__default['default'](this.basePath, `/ws/${params.targetId}`), {
            target: params.wsUrl,
            logLevel: this.debug.enabled ? 'debug' : 'silent',
            logProvider: this.proxyLogger,
            ws: true,
            changeOrigin: true,
        });
        this.targetIdProxyMap.set(params.targetId, wsProxy);
        this.router.use('/ws', wsProxy); // Proxy websockets
        if (this.openPortals.size === 0) {
            await this.openServer();
        }
        this.openPortals.add(params.targetId);
        const fullUrl = this.webPortalBaseUrl;
        fullUrl.searchParams.set('targetId', params.targetId);
        this.debug('fullUrl', fullUrl.toString());
        return fullUrl.toString();
    }
    async closePortal(targetId) {
        this.debug(`Closing portal for targetId "${targetId}""`);
        this.openPortals.delete(targetId);
        this.targetIdProxyMap.delete(targetId);
        if (this.openPortals.size === 0)
            this.closeServer();
    }
    hasOpenPortal(targetId) {
        return this.openPortals.has(targetId);
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
const getPageTargetId = (page) => {
    // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-explicit-any
    return page.target()._targetId;
};
/**
 * A puppeteer-extra plugin to let you interact with headless sessions remotely.
 * @noInheritDoc
 */
class PuppeteerExtraPluginPortal extends puppeteerExtraPlugin.PuppeteerExtraPlugin {
    constructor(opts) {
        var _a, _b;
        super(opts);
        this.debug('Initialized', this.opts);
        this.webPortalBaseUrl = new url.URL(this.opts.webPortalConfig.baseUrl);
        this.portalServer = new PortalServer({
            debug: this.debug,
            webPortalBaseUrl: this.webPortalBaseUrl,
            listenOpts: (_a = this.opts.webPortalConfig) === null || _a === void 0 ? void 0 : _a.listenOpts,
            serverOpts: (_b = this.opts.webPortalConfig) === null || _b === void 0 ? void 0 : _b.serverOpts,
        });
    }
    get name() {
        return 'portal';
    }
    get defaults() {
        return {
            webPortalConfig: {
                listenOpts: {
                    port: 3000,
                },
                baseUrl: 'http://localhost:3000',
            },
        };
    }
    async openPortal(page) {
        const targetId = getPageTargetId(page);
        const browser = page.browser();
        const wsUrl = browser.wsEndpoint();
        const url = await this.portalServer.hostPortal({
            wsUrl,
            targetId,
        });
        return url;
    }
    async closePortal(page) {
        const targetId = getPageTargetId(page);
        await this.portalServer.closePortal(targetId);
    }
    hasOpenPortal(page) {
        const targetId = getPageTargetId(page);
        return this.portalServer.hasOpenPortal(targetId);
    }
    async closeAllBrowserPortals(browser) {
        this.debug('Closing all portals for browser');
        const pages = await browser.pages();
        const closePortalPromises = pages.map(this.closePortal.bind(this));
        await Promise.all(closePortalPromises);
    }
    addCustomMethods(prop) {
        /* eslint-disable no-param-reassign */
        prop.openPortal = async () => this.openPortal(prop);
        prop.closePortal = async () => this.closePortal(prop);
        prop.hasOpenPortal = () => this.hasOpenPortal(prop);
    }
    async onPageCreated(page) {
        this.debug('onPageCreated', page.url());
        this.addCustomMethods(page);
        page.on('close', () => this.closePortal(page));
    }
    /** Add additions to already existing pages  */
    async onBrowser(browser) {
        const pages = await browser.pages();
        pages.forEach((page) => this.addCustomMethods(page));
        browser.on('disconnected', () => this.closeAllBrowserPortals(browser));
    }
}
/** Default export, PuppeteerExtraPluginRecaptcha  */
const defaultExport = (options) => {
    return new PuppeteerExtraPluginPortal(options);
};

exports.PuppeteerExtraPluginPortal = PuppeteerExtraPluginPortal;
exports.default = defaultExport;


  module.exports = exports.default || {}
  Object.entries(exports).forEach(([key, value]) => { module.exports[key] = value })
//# sourceMappingURL=index.cjs.js.map

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Accessibility.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Accessibility.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accessibility": () => (/* binding */ Accessibility)
/* harmony export */ });
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The Accessibility class provides methods for inspecting Chromium's
 * accessibility tree. The accessibility tree is used by assistive technology
 * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or
 * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.
 *
 * @remarks
 *
 * Accessibility is a very platform-specific thing. On different platforms,
 * there are different screen readers that might have wildly different output.
 *
 * Blink - Chrome's rendering engine - has a concept of "accessibility tree",
 * which is then translated into different platform-specific APIs. Accessibility
 * namespace gives users access to the Blink Accessibility Tree.
 *
 * Most of the accessibility tree gets filtered out when converting from Blink
 * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.
 * By default, Puppeteer tries to approximate this filtering, exposing only
 * the "interesting" nodes of the tree.
 *
 * @public
 */
class Accessibility {
    /**
     * @internal
     */
    constructor(client) {
        this._client = client;
    }
    /**
     * Captures the current state of the accessibility tree.
     * The returned object represents the root accessible node of the page.
     *
     * @remarks
     *
     * **NOTE** The Chromium accessibility tree contains nodes that go unused on
     * most platforms and by most screen readers. Puppeteer will discard them as
     * well for an easier to process tree, unless `interestingOnly` is set to
     * `false`.
     *
     * @example
     * An example of dumping the entire accessibility tree:
     * ```js
     * const snapshot = await page.accessibility.snapshot();
     * console.log(snapshot);
     * ```
     *
     * @example
     * An example of logging the focused node's name:
     * ```js
     * const snapshot = await page.accessibility.snapshot();
     * const node = findFocusedNode(snapshot);
     * console.log(node && node.name);
     *
     * function findFocusedNode(node) {
     *   if (node.focused)
     *     return node;
     *   for (const child of node.children || []) {
     *     const foundNode = findFocusedNode(child);
     *     return foundNode;
     *   }
     *   return null;
     * }
     * ```
     *
     * @returns An AXNode object representing the snapshot.
     *
     */
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null } = options;
        const { nodes } = await this._client.send('Accessibility.getFullAXTree');
        let backendNodeId = null;
        if (root) {
            const { node } = await this._client.send('DOM.describeNode', {
                objectId: root._remoteObject.objectId,
            });
            backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(nodes);
        let needle = defaultRoot;
        if (backendNodeId) {
            needle = defaultRoot.find((node) => node.payload.backendDOMNodeId === backendNodeId);
            if (!needle)
                return null;
        }
        if (!interestingOnly)
            return this.serializeTree(needle)[0];
        const interestingNodes = new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle))
            return null;
        return this.serializeTree(needle, interestingNodes)[0];
    }
    serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children)
            children.push(...this.serializeTree(child, interestingNodes));
        if (interestingNodes && !interestingNodes.has(node))
            return children;
        const serializedNode = node.serialize();
        if (children.length)
            serializedNode.children = children;
        return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl))
            collection.add(node);
        if (node.isLeafNode())
            return;
        insideControl = insideControl || node.isControl();
        for (const child of node.children)
            this.collectInterestingNodes(collection, child, insideControl);
    }
}
class AXNode {
    constructor(payload) {
        this.children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._hidden = false;
        this.payload = payload;
        this._name = this.payload.name ? this.payload.name.value : '';
        this._role = this.payload.role ? this.payload.role.value : 'Unknown';
        this._ignored = this.payload.ignored;
        for (const property of this.payload.properties || []) {
            if (property.name === 'editable') {
                this._richlyEditable = property.value.value === 'richtext';
                this._editable = true;
            }
            if (property.name === 'focusable')
                this._focusable = property.value.value;
            if (property.name === 'hidden')
                this._hidden = property.value.value;
        }
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'textbox' || this._role === 'searchbox';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this.children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    find(predicate) {
        if (predicate(this))
            return this;
        for (const child of this.children) {
            const result = child.find(predicate);
            if (result)
                return result;
        }
        return null;
    }
    isLeafNode() {
        if (!this.children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
            case 'treeitem':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this._role;
        if (role === 'Ignored' || this._hidden || this._ignored)
            return false;
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name;
    }
    serialize() {
        const properties = new Map();
        for (const property of this.payload.properties || [])
            properties.set(property.name.toLowerCase(), property.value.value);
        if (this.payload.name)
            properties.set('name', this.payload.name.value);
        if (this.payload.value)
            properties.set('value', this.payload.value.value);
        if (this.payload.description)
            properties.set('description', this.payload.description.value);
        const node = {
            role: this._role,
        };
        const userStringProperties = [
            'name',
            'value',
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        const getUserStringPropertyValue = (key) => properties.get(key);
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty))
                continue;
            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        const getBooleanPropertyValue = (key) => properties.get(key);
        for (const booleanProperty of booleanProperties) {
            // RootWebArea's treat focus differently than other nodes. They report whether
            // their frame  has focus, not whether focus is specifically on the root
            // node.
            if (booleanProperty === 'focused' && this._role === 'RootWebArea')
                continue;
            const value = getBooleanPropertyValue(booleanProperty);
            if (!value)
                continue;
            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ['checked', 'pressed'];
        for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty))
                continue;
            const value = properties.get(tristateProperty);
            node[tristateProperty] =
                value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        const getNumericalPropertyValue = (key) => properties.get(key);
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty))
                continue;
            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        const getTokenPropertyValue = (key) => properties.get(key);
        for (const tokenProperty of tokenProperties) {
            const value = getTokenPropertyValue(tokenProperty);
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
    }
    static createTree(payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
            nodeById.set(payload.nodeId, new AXNode(payload));
        for (const node of nodeById.values()) {
            for (const childId of node.payload.childIds || [])
                node.children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
    }
}
//# sourceMappingURL=Accessibility.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/AriaQueryHandler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/AriaQueryHandler.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ariaHandler": () => (/* binding */ ariaHandler)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function queryAXTree(client, element, accessibleName, role) {
    const { nodes } = await client.send('Accessibility.queryAXTree', {
        objectId: element._remoteObject.objectId,
        accessibleName,
        role,
    });
    const filteredNodes = nodes.filter((node) => node.role.value !== 'StaticText');
    return filteredNodes;
}
function parseAriaSelector(selector) {
    const normalize = (value) => value.replace(/ +/g, ' ').trim();
    const knownAttributes = new Set(['name', 'role']);
    const queryOptions = {};
    const attributeRegexp = /\[\s*(?<attribute>\w+)\s*=\s*"(?<value>\\.|[^"\\]*)"\s*\]/g;
    const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {
        attribute = attribute.trim();
        if (!knownAttributes.has(attribute))
            throw new Error(`Unknown aria attribute "${attribute}" in selector`);
        queryOptions[attribute] = normalize(value);
        return '';
    });
    if (defaultName && !queryOptions.name)
        queryOptions.name = normalize(defaultName);
    return queryOptions;
}
const queryOne = async (element, selector) => {
    const exeCtx = element.executionContext();
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(exeCtx._client, element, name, role);
    if (res.length < 1) {
        return null;
    }
    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);
};
const waitFor = async (domWorld, selector, options) => {
    const binding = {
        name: 'ariaQuerySelector',
        pptrFunction: async (selector) => {
            const document = await domWorld._document();
            const element = await queryOne(document, selector);
            return element;
        },
    };
    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);
};
const queryAll = async (element, selector) => {
    const exeCtx = element.executionContext();
    const { name, role } = parseAriaSelector(selector);
    const res = await queryAXTree(exeCtx._client, element, name, role);
    return Promise.all(res.map((axNode) => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));
};
const queryAllArray = async (element, selector) => {
    const elementHandles = await queryAll(element, selector);
    const exeCtx = element.executionContext();
    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);
    return jsHandle;
};
/**
 * @internal
 */
const ariaHandler = {
    queryOne,
    waitFor,
    queryAll,
    queryAllArray,
};
//# sourceMappingURL=AriaQueryHandler.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Browser": () => (/* binding */ Browser),
/* harmony export */   "BrowserContext": () => (/* binding */ BrowserContext)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Target.js");
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([
    ['geolocation', 'geolocation'],
    ['midi', 'midi'],
    ['notifications', 'notifications'],
    // TODO: push isn't a valid type?
    // ['push', 'push'],
    ['camera', 'videoCapture'],
    ['microphone', 'audioCapture'],
    ['background-sync', 'backgroundSync'],
    ['ambient-light-sensor', 'sensors'],
    ['accelerometer', 'sensors'],
    ['gyroscope', 'sensors'],
    ['magnetometer', 'sensors'],
    ['accessibility-events', 'accessibilityEvents'],
    ['clipboard-read', 'clipboardReadWrite'],
    ['clipboard-write', 'clipboardReadWrite'],
    ['payment-handler', 'paymentHandler'],
    ['idle-detection', 'idleDetection'],
    // chrome-specific permissions we have.
    ['midi-sysex', 'midiSysex'],
]);
/**
 * A Browser is created when Puppeteer connects to a Chromium instance, either through
 * {@link PuppeteerNode.launch} or {@link Puppeteer.connect}.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and will
 * emit various events which are documented in the {@link BrowserEmittedEvents} enum.
 *
 * @example
 *
 * An example of using a {@link Browser} to create a {@link Page}:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await browser.close();
 * })();
 * ```
 *
 * @example
 *
 * An example of disconnecting from and reconnecting to a {@link Browser}:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   // Store the endpoint to be able to reconnect to Chromium
 *   const browserWSEndpoint = browser.wsEndpoint();
 *   // Disconnect puppeteer from Chromium
 *   browser.disconnect();
 *
 *   // Use the endpoint to reestablish a connection
 *   const browser2 = await puppeteer.connect({browserWSEndpoint});
 *   // Close Chromium
 *   await browser2.close();
 * })();
 * ```
 *
 * @public
 */
class Browser extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback) {
        super();
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._process = process;
        this._connection = connection;
        this._closeCallback = closeCallback || function () { };
        this._targetFilterCallback = targetFilterCallback || (() => true);
        this._defaultContext = new BrowserContext(this._connection, this, null);
        this._contexts = new Map();
        for (const contextId of contextIds)
            this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));
        this._targets = new Map();
        this._connection.on(_Connection_js__WEBPACK_IMPORTED_MODULE_4__.ConnectionEmittedEvents.Disconnected, () => this.emit("disconnected" /* Disconnected */));
        this._connection.on('Target.targetCreated', this._targetCreated.bind(this));
        this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));
        this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));
    }
    /**
     * @internal
     */
    static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback) {
        const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback);
        await connection.send('Target.setDiscoverTargets', { discover: true });
        return browser;
    }
    /**
     * The spawned browser process. Returns `null` if the browser instance was created with
     * {@link Puppeteer.connect}.
     */
    process() {
        return this._process;
    }
    /**
     * Creates a new incognito browser context. This won't share cookies/cache with other
     * browser contexts.
     *
     * @example
     * ```js
     * (async () => {
     *  const browser = await puppeteer.launch();
     *   // Create a new incognito browser context.
     *   const context = await browser.createIncognitoBrowserContext();
     *   // Create a new page in a pristine context.
     *   const page = await context.newPage();
     *   // Do stuff
     *   await page.goto('https://example.com');
     * })();
     * ```
     */
    async createIncognitoBrowserContext() {
        const { browserContextId } = await this._connection.send('Target.createBrowserContext');
        const context = new BrowserContext(this._connection, this, browserContextId);
        this._contexts.set(browserContextId, context);
        return context;
    }
    /**
     * Returns an array of all open browser contexts. In a newly created browser, this will
     * return a single instance of {@link BrowserContext}.
     */
    browserContexts() {
        return [this._defaultContext, ...Array.from(this._contexts.values())];
    }
    /**
     * Returns the default browser context. The default browser context cannot be closed.
     */
    defaultBrowserContext() {
        return this._defaultContext;
    }
    /**
     * @internal
     * Used by BrowserContext directly so cannot be marked private.
     */
    async _disposeContext(contextId) {
        await this._connection.send('Target.disposeBrowserContext', {
            browserContextId: contextId || undefined,
        });
        this._contexts.delete(contextId);
    }
    async _targetCreated(event) {
        const targetInfo = event.targetInfo;
        const { browserContextId } = targetInfo;
        const context = browserContextId && this._contexts.has(browserContextId)
            ? this._contexts.get(browserContextId)
            : this._defaultContext;
        const shouldAttachToTarget = this._targetFilterCallback(targetInfo);
        if (!shouldAttachToTarget) {
            return;
        }
        const target = new _Target_js__WEBPACK_IMPORTED_MODULE_2__.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');
        this._targets.set(event.targetInfo.targetId, target);
        if (await target._initializedPromise) {
            this.emit("targetcreated" /* TargetCreated */, target);
            context.emit("targetcreated" /* TargetCreated */, target);
        }
    }
    async _targetDestroyed(event) {
        const target = this._targets.get(event.targetId);
        target._initializedCallback(false);
        this._targets.delete(event.targetId);
        target._closedCallback();
        if (await target._initializedPromise) {
            this.emit("targetdestroyed" /* TargetDestroyed */, target);
            target
                .browserContext()
                .emit("targetdestroyed" /* TargetDestroyed */, target);
        }
    }
    _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(target, 'target should exist before targetInfoChanged');
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
            this.emit("targetchanged" /* TargetChanged */, target);
            target
                .browserContext()
                .emit("targetchanged" /* TargetChanged */, target);
        }
    }
    /**
     * The browser websocket endpoint which can be used as an argument to
     * {@link Puppeteer.connect}.
     *
     * @returns The Browser websocket url.
     *
     * @remarks
     *
     * The format is `ws://${host}:${port}/devtools/browser/<id>`.
     *
     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
     * Learn more about the
     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
     * the {@link
     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
     * | browser endpoint}.
     */
    wsEndpoint() {
        return this._connection.url();
    }
    /**
     * Promise which resolves to a new {@link Page} object. The Page is created in
     * a default browser context.
     */
    async newPage() {
        return this._defaultContext.newPage();
    }
    /**
     * @internal
     * Used by BrowserContext directly so cannot be marked private.
     */
    async _createPageInContext(contextId) {
        const { targetId } = await this._connection.send('Target.createTarget', {
            url: 'about:blank',
            browserContextId: contextId || undefined,
        });
        const target = await this._targets.get(targetId);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(await target._initializedPromise, 'Failed to create target for page');
        const page = await target.page();
        return page;
    }
    /**
     * All active targets inside the Browser. In case of multiple browser contexts, returns
     * an array with all the targets in all browser contexts.
     */
    targets() {
        return Array.from(this._targets.values()).filter((target) => target._isInitialized);
    }
    /**
     * The target associated with the browser.
     */
    target() {
        return this.targets().find((target) => target.type() === 'browser');
    }
    /**
     * Searches for a target in all browser contexts.
     *
     * @param predicate - A function to be run for every target.
     * @returns The first target found that matches the `predicate` function.
     *
     * @example
     *
     * An example of finding a target for a page opened via `window.open`:
     * ```js
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');
     * ```
     */
    async waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this.targets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise((x) => (resolve = x));
        this.on("targetcreated" /* TargetCreated */, check);
        this.on("targetchanged" /* TargetChanged */, check);
        try {
            if (!timeout)
                return await targetPromise;
            return await _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener("targetcreated" /* TargetCreated */, check);
            this.removeListener("targetchanged" /* TargetChanged */, check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    /**
     * An array of all open pages inside the Browser.
     *
     * @remarks
     *
     * In case of multiple browser contexts, returns an array with all the pages in all
     * browser contexts. Non-visible pages, such as `"background_page"`, will not be listed
     * here. You can find them using {@link Target.page}.
     */
    async pages() {
        const contextPages = await Promise.all(this.browserContexts().map((context) => context.pages()));
        // Flatten array.
        return contextPages.reduce((acc, x) => acc.concat(x), []);
    }
    /**
     * A string representing the browser name and version.
     *
     * @remarks
     *
     * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For
     * non-headless, this is similar to `Chrome/61.0.3153.0`.
     *
     * The format of browser.version() might change with future releases of Chromium.
     */
    async version() {
        const version = await this._getVersion();
        return version.product;
    }
    /**
     * The browser's original user agent. Pages can override the browser user agent with
     * {@link Page.setUserAgent}.
     */
    async userAgent() {
        const version = await this._getVersion();
        return version.userAgent;
    }
    /**
     * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object
     * itself is considered to be disposed and cannot be used anymore.
     */
    async close() {
        await this._closeCallback.call(null);
        this.disconnect();
    }
    /**
     * Disconnects Puppeteer from the browser, but leaves the Chromium process running.
     * After calling `disconnect`, the {@link Browser} object is considered disposed and
     * cannot be used anymore.
     */
    disconnect() {
        this._connection.dispose();
    }
    /**
     * Indicates that the browser is connected.
     */
    isConnected() {
        return !this._connection._closed;
    }
    _getVersion() {
        return this._connection.send('Browser.getVersion');
    }
}
/**
 * BrowserContexts provide a way to operate multiple independent browser
 * sessions. When a browser is launched, it has a single BrowserContext used by
 * default. The method {@link Browser.newPage | Browser.newPage} creates a page
 * in the default browser context.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and
 * will emit various events which are documented in the
 * {@link BrowserContextEmittedEvents} enum.
 *
 * If a page opens another page, e.g. with a `window.open` call, the popup will
 * belong to the parent page's browser context.
 *
 * Puppeteer allows creation of "incognito" browser contexts with
 * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}
 * method. "Incognito" browser contexts don't write any browsing data to disk.
 *
 * @example
 * ```js
 * // Create a new incognito browser context
 * const context = await browser.createIncognitoBrowserContext();
 * // Create a new page inside context.
 * const page = await context.newPage();
 * // ... do stuff with page ...
 * await page.goto('https://example.com');
 * // Dispose context once it's no longer needed.
 * await context.close();
 * ```
 * @public
 */
class BrowserContext extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, browser, contextId) {
        super();
        this._connection = connection;
        this._browser = browser;
        this._id = contextId;
    }
    /**
     * An array of all active targets inside the browser context.
     */
    targets() {
        return this._browser
            .targets()
            .filter((target) => target.browserContext() === this);
    }
    /**
     * This searches for a target in this specific browser context.
     *
     * @example
     * An example of finding a target for a page opened via `window.open`:
     * ```js
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');
     * ```
     *
     * @param predicate - A function to be run for every target
     * @param options - An object of options. Accepts a timout,
     * which is the maximum wait time in milliseconds.
     * Pass `0` to disable the timeout. Defaults to 30 seconds.
     * @returns Promise which resolves to the first target found
     * that matches the `predicate` function.
     */
    waitForTarget(predicate, options = {}) {
        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);
    }
    /**
     * An array of all pages inside the browser context.
     *
     * @returns Promise which resolves to an array of all open pages.
     * Non visible pages, such as `"background_page"`, will not be listed here.
     * You can find them using {@link Target.page | the target page}.
     */
    async pages() {
        const pages = await Promise.all(this.targets()
            .filter((target) => target.type() === 'page')
            .map((target) => target.page()));
        return pages.filter((page) => !!page);
    }
    /**
     * Returns whether BrowserContext is incognito.
     * The default browser context is the only non-incognito browser context.
     *
     * @remarks
     * The default browser context cannot be closed.
     */
    isIncognito() {
        return !!this._id;
    }
    /**
     * @example
     * ```js
     * const context = browser.defaultBrowserContext();
     * await context.overridePermissions('https://html5demos.com', ['geolocation']);
     * ```
     *
     * @param origin - The origin to grant permissions to, e.g. "https://example.com".
     * @param permissions - An array of permissions to grant.
     * All permissions that are not listed here will be automatically denied.
     */
    async overridePermissions(origin, permissions) {
        const protocolPermissions = permissions.map((permission) => {
            const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
            if (!protocolPermission)
                throw new Error('Unknown permission: ' + permission);
            return protocolPermission;
        });
        await this._connection.send('Browser.grantPermissions', {
            origin,
            browserContextId: this._id || undefined,
            permissions: protocolPermissions,
        });
    }
    /**
     * Clears all permission overrides for the browser context.
     *
     * @example
     * ```js
     * const context = browser.defaultBrowserContext();
     * context.overridePermissions('https://example.com', ['clipboard-read']);
     * // do stuff ..
     * context.clearPermissionOverrides();
     * ```
     */
    async clearPermissionOverrides() {
        await this._connection.send('Browser.resetPermissions', {
            browserContextId: this._id || undefined,
        });
    }
    /**
     * Creates a new page in the browser context.
     */
    newPage() {
        return this._browser._createPageInContext(this._id);
    }
    /**
     * The browser this browser context belongs to.
     */
    browser() {
        return this._browser;
    }
    /**
     * Closes the browser context. All the targets that belong to the browser context
     * will be closed.
     *
     * @remarks
     * Only incognito browser contexts can be closed.
     */
    async close() {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._id, 'Non-incognito profiles cannot be closed!');
        await this._browser._disposeContext(this._id);
    }
}
//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connectToBrowser": () => (/* binding */ connectToBrowser)
/* harmony export */ });
/* harmony import */ var _Browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Browser.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _common_helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js");
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fetch.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/fetch.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const getWebSocketTransportClass = async () => {
    return _environment_js__WEBPACK_IMPORTED_MODULE_5__.isNode
        ? (await __webpack_require__.e(/*! import() */ "node_modules_puppeteer-core_lib_esm_puppeteer_node_NodeWebSocketTransport_js").then(__webpack_require__.bind(__webpack_require__, /*! ../node/NodeWebSocketTransport.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js"))).NodeWebSocketTransport
        : (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./BrowserWebSocketTransport.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js")))
            .BrowserWebSocketTransport;
};
/**
 * Users should never call this directly; it's called when calling
 * `puppeteer.connect`.
 * @internal
 */
const connectToBrowser = async (options) => {
    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, slowMo = 0, targetFilter, } = options;
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===
        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');
    let connection = null;
    if (transport) {
        connection = new _Connection_js__WEBPACK_IMPORTED_MODULE_3__.Connection('', transport, slowMo);
    }
    else if (browserWSEndpoint) {
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(browserWSEndpoint);
        connection = new _Connection_js__WEBPACK_IMPORTED_MODULE_3__.Connection(browserWSEndpoint, connectionTransport, slowMo);
    }
    else if (browserURL) {
        const connectionURL = await getWSEndpoint(browserURL);
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(connectionURL);
        connection = new _Connection_js__WEBPACK_IMPORTED_MODULE_3__.Connection(connectionURL, connectionTransport, slowMo);
    }
    const { browserContextIds } = await connection.send('Target.getBrowserContexts');
    return _Browser_js__WEBPACK_IMPORTED_MODULE_0__.Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send('Browser.close').catch(_common_helper_js__WEBPACK_IMPORTED_MODULE_2__.debugError), targetFilter);
};
async function getWSEndpoint(browserURL) {
    const endpointURL = new URL('/json/version', browserURL);
    const fetch = await (0,_fetch_js__WEBPACK_IMPORTED_MODULE_4__.getFetch)();
    try {
        const result = await fetch(endpointURL.toString(), {
            method: 'GET',
        });
        if (!result.ok) {
            throw new Error(`HTTP ${result.statusText}`);
        }
        const data = await result.json();
        return data.webSocketDebuggerUrl;
    }
    catch (error) {
        error.message =
            `Failed to fetch browser webSocket URL from ${endpointURL}: ` +
                error.message;
        throw error;
    }
}
//# sourceMappingURL=BrowserConnector.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserWebSocketTransport": () => (/* binding */ BrowserWebSocketTransport)
/* harmony export */ });
class BrowserWebSocketTransport {
    constructor(ws) {
        this._ws = ws;
        this._ws.addEventListener('message', (event) => {
            if (this.onmessage)
                this.onmessage.call(null, event.data);
        });
        this._ws.addEventListener('close', () => {
            if (this.onclose)
                this.onclose.call(null);
        });
        // Silently ignore all errors - we don't know what to do with them.
        this._ws.addEventListener('error', () => { });
        this.onmessage = null;
        this.onclose = null;
    }
    static create(url) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(url);
            ws.addEventListener('open', () => resolve(new BrowserWebSocketTransport(ws)));
            ws.addEventListener('error', reject);
        });
    }
    send(message) {
        this._ws.send(message);
    }
    close() {
        this._ws.close();
    }
}
//# sourceMappingURL=BrowserWebSocketTransport.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionEmittedEvents": () => (/* binding */ ConnectionEmittedEvents),
/* harmony export */   "Connection": () => (/* binding */ Connection),
/* harmony export */   "CDPSessionEmittedEvents": () => (/* binding */ CDPSessionEmittedEvents),
/* harmony export */   "CDPSession": () => (/* binding */ CDPSession)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const debugProtocolSend = (0,_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:protocol:SEND ►');
const debugProtocolReceive = (0,_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:protocol:RECV ◀');

/**
 * Internal events that the Connection class emits.
 *
 * @internal
 */
const ConnectionEmittedEvents = {
    Disconnected: Symbol('Connection.Disconnected'),
};
/**
 * @internal
 */
class Connection extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
    constructor(url, transport, delay = 0) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this._callbacks = new Map();
        this._url = url;
        this._delay = delay;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
    }
    static fromSession(session) {
        return session._connection;
    }
    /**
     * @param sessionId - The session id
     * @returns The current CDP session if it exists
     */
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    url() {
        return this._url;
    }
    send(method, ...paramArgs) {
        // There is only ever 1 param arg passed, but the Protocol defines it as an
        // array of 0 or 1 items See this comment:
        // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285
        // which explains why the protocol defines the params this way for better
        // type-inference.
        // So now we check if there are any params or not and deal with them accordingly.
        const params = paramArgs.length ? paramArgs[0] : undefined;
        const id = this._rawSend({ method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    _rawSend(message) {
        const id = ++this._lastId;
        const stringifiedMessage = JSON.stringify(Object.assign({}, message, { id }));
        debugProtocolSend(stringifiedMessage);
        this._transport.send(stringifiedMessage);
        return id;
    }
    async _onMessage(message) {
        if (this._delay)
            await new Promise((f) => setTimeout(f, this._delay));
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new CDPSession(this, object.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
            this.emit('sessionattached', session);
            const parentSession = this._sessions.get(object.sessionId);
            if (parentSession) {
                parentSession.emit('sessionattached', session);
            }
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
                session._onClosed();
                this._sessions.delete(object.params.sessionId);
                this.emit('sessiondetached', session);
                const parentSession = this._sessions.get(object.sessionId);
                if (parentSession) {
                    parentSession.emit('sessiondetached', session);
                }
            }
        }
        if (object.sessionId) {
            const session = this._sessions.get(object.sessionId);
            if (session)
                session._onMessage(object);
        }
        else if (object.id) {
            const callback = this._callbacks.get(object.id);
            // Callbacks could be all rejected if someone has called `.dispose()`.
            if (callback) {
                this._callbacks.delete(object.id);
                if (object.error)
                    callback.reject(createProtocolError(callback.error, callback.method, object));
                else
                    callback.resolve(object.result);
            }
        }
        else {
            this.emit(object.method, object.params);
        }
    }
    _onClose() {
        if (this._closed)
            return;
        this._closed = true;
        this._transport.onmessage = null;
        this._transport.onclose = null;
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        for (const session of this._sessions.values())
            session._onClosed();
        this._sessions.clear();
        this.emit(ConnectionEmittedEvents.Disconnected);
    }
    dispose() {
        this._onClose();
        this._transport.close();
    }
    /**
     * @param targetInfo - The target info
     * @returns The CDP session that is created
     */
    async createSession(targetInfo) {
        const { sessionId } = await this.send('Target.attachToTarget', {
            targetId: targetInfo.targetId,
            flatten: true,
        });
        return this._sessions.get(sessionId);
    }
}
/**
 * Internal events that the CDPSession class emits.
 *
 * @internal
 */
const CDPSessionEmittedEvents = {
    Disconnected: Symbol('CDPSession.Disconnected'),
};
/**
 * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.
 *
 * @remarks
 *
 * Protocol methods can be called with {@link CDPSession.send} method and protocol
 * events can be subscribed to with `CDPSession.on` method.
 *
 * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}
 * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md | Getting Started with DevTools Protocol}.
 *
 * @example
 * ```js
 * const client = await page.target().createCDPSession();
 * await client.send('Animation.enable');
 * client.on('Animation.animationCreated', () => console.log('Animation created!'));
 * const response = await client.send('Animation.getPlaybackRate');
 * console.log('playback rate is ' + response.playbackRate);
 * await client.send('Animation.setPlaybackRate', {
 *   playbackRate: response.playbackRate / 2
 * });
 * ```
 *
 * @public
 */
class CDPSession extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
    /**
     * @internal
     */
    constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
    }
    connection() {
        return this._connection;
    }
    send(method, ...paramArgs) {
        if (!this._connection)
            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        // See the comment in Connection#send explaining why we do this.
        const params = paramArgs.length ? paramArgs[0] : undefined;
        const id = this._connection._rawSend({
            sessionId: this._sessionId,
            method,
            params,
        });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    /**
     * @internal
     */
    _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!object.id);
            this.emit(object.method, object.params);
        }
    }
    /**
     * Detaches the cdpSession from the target. Once detached, the cdpSession object
     * won't emit any events and can't be used to send messages.
     */
    async detach() {
        if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        await this._connection.send('Target.detachFromTarget', {
            sessionId: this._sessionId,
        });
    }
    /**
     * @internal
     */
    _onClosed() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        this.emit(CDPSessionEmittedEvents.Disconnected);
    }
}
/**
 * @param {!Error} error
 * @param {string} method
 * @param {{error: {message: string, data: any}}} object
 * @returns {!Error}
 */
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${object.error.data}`;
    return rewriteError(error, message);
}
/**
 * @param {!Error} error
 * @param {string} message
 * @returns {!Error}
 */
function rewriteError(error, message) {
    error.message = message;
    return error;
}
//# sourceMappingURL=Connection.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js":
/*!********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsoleMessage": () => (/* binding */ ConsoleMessage)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ConsoleMessage objects are dispatched by page via the 'console' event.
 * @public
 */
class ConsoleMessage {
    /**
     * @public
     */
    constructor(type, text, args, stackTraceLocations) {
        this._type = type;
        this._text = text;
        this._args = args;
        this._stackTraceLocations = stackTraceLocations;
    }
    /**
     * @returns The type of the console message.
     */
    type() {
        return this._type;
    }
    /**
     * @returns The text of the console message.
     */
    text() {
        return this._text;
    }
    /**
     * @returns An array of arguments passed to the console.
     */
    args() {
        return this._args;
    }
    /**
     * @returns The location of the console message.
     */
    location() {
        return this._stackTraceLocations.length ? this._stackTraceLocations[0] : {};
    }
    /**
     * @returns The array of locations on the stack of the console message.
     */
    stackTrace() {
        return this._stackTraceLocations;
    }
}
//# sourceMappingURL=ConsoleMessage.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Coverage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Coverage.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Coverage": () => (/* binding */ Coverage),
/* harmony export */   "JSCoverage": () => (/* binding */ JSCoverage),
/* harmony export */   "CSSCoverage": () => (/* binding */ CSSCoverage)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExecutionContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * The Coverage class provides methods to gathers information about parts of
 * JavaScript and CSS that were used by the page.
 *
 * @remarks
 * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},
 * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.
 *
 * @example
 * An example of using JavaScript and CSS coverage to get percentage of initially
 * executed code:
 * ```js
 * // Enable both JavaScript and CSS coverage
 * await Promise.all([
 *   page.coverage.startJSCoverage(),
 *   page.coverage.startCSSCoverage()
 * ]);
 * // Navigate to page
 * await page.goto('https://example.com');
 * // Disable both JavaScript and CSS coverage
 * const [jsCoverage, cssCoverage] = await Promise.all([
 *   page.coverage.stopJSCoverage(),
 *   page.coverage.stopCSSCoverage(),
 * ]);
 * let totalBytes = 0;
 * let usedBytes = 0;
 * const coverage = [...jsCoverage, ...cssCoverage];
 * for (const entry of coverage) {
 *   totalBytes += entry.text.length;
 *   for (const range of entry.ranges)
 *     usedBytes += range.end - range.start - 1;
 * }
 * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);
 * ```
 * @public
 */
class Coverage {
    constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
    }
    /**
     * @param options - Set of configurable options for coverage defaults to `{
     * resetOnNavigation : true, reportAnonymousScripts : false }`
     * @returns Promise that resolves when coverage is started.
     *
     * @remarks
     * Anonymous scripts are ones that don't have an associated url. These are
     * scripts that are dynamically created on the page using `eval` or
     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
     * scripts will have `__puppeteer_evaluation_script__` as their URL.
     */
    async startJSCoverage(options = {}) {
        return await this._jsCoverage.start(options);
    }
    /**
     * @returns Promise that resolves to the array of coverage reports for
     * all scripts.
     *
     * @remarks
     * JavaScript Coverage doesn't include anonymous scripts by default.
     * However, scripts with sourceURLs are reported.
     */
    async stopJSCoverage() {
        return await this._jsCoverage.stop();
    }
    /**
     * @param options - Set of configurable options for coverage, defaults to `{
     * resetOnNavigation : true }`
     * @returns Promise that resolves when coverage is started.
     */
    async startCSSCoverage(options = {}) {
        return await this._cssCoverage.start(options);
    }
    /**
     * @returns Promise that resolves to the array of coverage reports
     * for all stylesheets.
     * @remarks
     * CSS Coverage doesn't include dynamically injected style tags
     * without sourceURLs.
     */
    async stopCSSCoverage() {
        return await this._cssCoverage.stop();
    }
}
/**
 * @public
 */
class JSCoverage {
    constructor(client) {
        this._enabled = false;
        this._scriptURLs = new Map();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
        this._reportAnonymousScripts = false;
        this._client = client;
    }
    async start(options = {}) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptURLs.clear();
        this._scriptSources.clear();
        this._eventListeners = [
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('Profiler.enable'),
            this._client.send('Profiler.startPreciseCoverage', {
                callCount: false,
                detailed: true,
            }),
            this._client.send('Debugger.enable'),
            this._client.send('Debugger.setSkipAllPauses', { skip: true }),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._scriptURLs.clear();
        this._scriptSources.clear();
    }
    async _onScriptParsed(event) {
        // Ignore puppeteer-injected scripts
        if (event.url === _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_2__.EVALUATION_SCRIPT_URL)
            return;
        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.
        if (!event.url && !this._reportAnonymousScripts)
            return;
        try {
            const response = await this._client.send('Debugger.getScriptSource', {
                scriptId: event.scriptId,
            });
            this._scriptURLs.set(event.scriptId, event.url);
            this._scriptSources.set(event.scriptId, response.scriptSource);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        }
    }
    async stop() {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._enabled, 'JSCoverage is not enabled');
        this._enabled = false;
        const result = await Promise.all([
            this._client.send('Profiler.takePreciseCoverage'),
            this._client.send('Profiler.stopPreciseCoverage'),
            this._client.send('Profiler.disable'),
            this._client.send('Debugger.disable'),
        ]);
        _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
            let url = this._scriptURLs.get(entry.scriptId);
            if (!url && this._reportAnonymousScripts)
                url = 'debugger://VM' + entry.scriptId;
            const text = this._scriptSources.get(entry.scriptId);
            if (text === undefined || url === undefined)
                continue;
            const flattenRanges = [];
            for (const func of entry.functions)
                flattenRanges.push(...func.ranges);
            const ranges = convertToDisjointRanges(flattenRanges);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
/**
 * @public
 */
class CSSCoverage {
    constructor(client) {
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
        this._reportAnonymousScripts = false;
        this._client = client;
    }
    async start(options = {}) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('DOM.enable'),
            this._client.send('CSS.enable'),
            this._client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
    }
    async _onStyleSheet(event) {
        const header = event.header;
        // Ignore anonymous scripts
        if (!header.sourceURL)
            return;
        try {
            const response = await this._client.send('CSS.getStyleSheetText', {
                styleSheetId: header.styleSheetId,
            });
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        }
    }
    async stop() {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._enabled, 'CSSCoverage is not enabled');
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this._client.send('CSS.disable'),
            this._client.send('DOM.disable'),
        ]);
        _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.removeEventListeners(this._eventListeners);
        // aggregate by styleSheetId
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    // Sort points to form a valid parenthesis sequence.
    points.sort((a, b) => {
        // Sort with increasing offsets.
        if (a.offset !== b.offset)
            return a.offset - b.offset;
        // All "end" points should go before "start" points.
        if (a.type !== b.type)
            return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        // For two "start" points, the one with longer range goes first.
        if (a.type === 0)
            return bLength - aLength;
        // For two "end" points, the one with shorter range goes first.
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    // Run scanning line to intersect all ranges.
    for (const point of points) {
        if (hitCountStack.length &&
            lastOffset < point.offset &&
            hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results.length ? results[results.length - 1] : null;
            if (lastResult && lastResult.end === lastOffset)
                lastResult.end = point.offset;
            else
                results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
            hitCountStack.push(point.range.count);
        else
            hitCountStack.pop();
    }
    // Filter out empty ranges.
    return results.filter((range) => range.end - range.start > 1);
}
//# sourceMappingURL=Coverage.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/DOMWorld.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/DOMWorld.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOMWorld": () => (/* binding */ DOMWorld),
/* harmony export */   "WaitTask": () => (/* binding */ WaitTask)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _LifecycleWatcher_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LifecycleWatcher.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/LifecycleWatcher.js");
/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./QueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * @internal
 */
class DOMWorld {
    constructor(frameManager, frame, timeoutSettings) {
        this._documentPromise = null;
        this._contextPromise = null;
        this._contextResolveCallback = null;
        this._detached = false;
        /**
         * @internal
         */
        this._waitTasks = new Set();
        /**
         * @internal
         * Contains mapping from functions that should be bound to Puppeteer functions.
         */
        this._boundFunctions = new Map();
        // Set of bindings that have been registered in the current context.
        this._ctxBindings = new Set();
        // If multiple waitFor are set up asynchronously, we need to wait for the
        // first one to set up the binding in the page before running the others.
        this._settingUpBinding = null;
        this._frameManager = frameManager;
        this._frame = frame;
        this._timeoutSettings = timeoutSettings;
        this._setContext(null);
        frameManager._client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));
    }
    frame() {
        return this._frame;
    }
    async _setContext(context) {
        if (context) {
            this._ctxBindings.clear();
            this._contextResolveCallback.call(null, context);
            this._contextResolveCallback = null;
            for (const waitTask of this._waitTasks)
                waitTask.rerun();
        }
        else {
            this._documentPromise = null;
            this._contextPromise = new Promise((fulfill) => {
                this._contextResolveCallback = fulfill;
            });
        }
    }
    _hasContext() {
        return !this._contextResolveCallback;
    }
    _detach() {
        this._detached = true;
        for (const waitTask of this._waitTasks)
            waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));
    }
    executionContext() {
        if (this._detached)
            throw new Error(`Execution context is not available in detached frame "${this._frame.url()}" (are you trying to evaluate?)`);
        return this._contextPromise;
    }
    async evaluateHandle(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluate(pageFunction, ...args);
    }
    async $(selector) {
        const document = await this._document();
        const value = await document.$(selector);
        return value;
    }
    async _document() {
        if (this._documentPromise)
            return this._documentPromise;
        this._documentPromise = this.executionContext().then(async (context) => {
            const document = await context.evaluateHandle('document');
            return document.asElement();
        });
        return this._documentPromise;
    }
    async $x(expression) {
        const document = await this._document();
        const value = await document.$x(expression);
        return value;
    }
    async $eval(selector, pageFunction, ...args) {
        const document = await this._document();
        return document.$eval(selector, pageFunction, ...args);
    }
    async $$eval(selector, pageFunction, ...args) {
        const document = await this._document();
        const value = await document.$$eval(selector, pageFunction, ...args);
        return value;
    }
    async $$(selector) {
        const document = await this._document();
        const value = await document.$$(selector);
        return value;
    }
    async content() {
        return await this.evaluate(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options = {}) {
        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        // We rely upon the fact that document.open() will reset frame lifecycle with "init"
        // lifecycle event. @see https://crrev.com/608658
        await this.evaluate((html) => {
            document.open();
            document.write(html);
            document.close();
        }, html);
        const watcher = new _LifecycleWatcher_js__WEBPACK_IMPORTED_MODULE_2__.LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);
        const error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.lifecyclePromise(),
        ]);
        watcher.dispose();
        if (error)
            throw error;
    }
    /**
     * Adds a script tag into the current context.
     *
     * @remarks
     *
     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer
     * in a browser environment you cannot pass a filepath and should use either
     * `url` or `content`.
     */
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (url !== null) {
            try {
                const context = await this.executionContext();
                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();
            }
            catch (error) {
                throw new Error(`Loading script from ${url} failed`);
            }
        }
        if (path !== null) {
            if (!_environment_js__WEBPACK_IMPORTED_MODULE_5__.isNode) {
                throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');
            }
            const fs = await _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.importFSModule();
            let contents = await fs.promises.readFile(path, 'utf8');
            contents += '//# sourceURL=' + path.replace(/\n/g, '');
            const context = await this.executionContext();
            return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();
        }
        if (content !== null) {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();
        }
        throw new Error('Provide an object with a `url`, `path` or `content` property');
        async function addScriptUrl(url, type) {
            const script = document.createElement('script');
            script.src = url;
            if (type)
                script.type = type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = rej;
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(content, type = 'text/javascript') {
            const script = document.createElement('script');
            script.type = type;
            script.text = content;
            let error = null;
            script.onerror = (e) => (error = e);
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    /**
     * Adds a style tag into the current context.
     *
     * @remarks
     *
     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer
     * in a browser environment you cannot pass a filepath and should use either
     * `url` or `content`.
     *
     */
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (url !== null) {
            try {
                const context = await this.executionContext();
                return (await context.evaluateHandle(addStyleUrl, url)).asElement();
            }
            catch (error) {
                throw new Error(`Loading style from ${url} failed`);
            }
        }
        if (path !== null) {
            if (!_environment_js__WEBPACK_IMPORTED_MODULE_5__.isNode) {
                throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');
            }
            const fs = await _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.importFSModule();
            let contents = await fs.promises.readFile(path, 'utf8');
            contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
            const context = await this.executionContext();
            return (await context.evaluateHandle(addStyleContent, contents)).asElement();
        }
        if (content !== null) {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addStyleContent, content)).asElement();
        }
        throw new Error('Provide an object with a `url`, `path` or `content` property');
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async click(selector, options) {
        const handle = await this.$(selector);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(handle, 'No node found for selector: ' + selector);
        await handle.click(options);
        await handle.dispose();
    }
    async focus(selector) {
        const handle = await this.$(selector);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(handle, 'No node found for selector: ' + selector);
        await handle.focus();
        await handle.dispose();
    }
    async hover(selector) {
        const handle = await this.$(selector);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(handle, 'No node found for selector: ' + selector);
        await handle.hover();
        await handle.dispose();
    }
    async select(selector, ...values) {
        const handle = await this.$(selector);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(handle, 'No node found for selector: ' + selector);
        const result = await handle.select(...values);
        await handle.dispose();
        return result;
    }
    async tap(selector) {
        const handle = await this.$(selector);
        await handle.tap();
        await handle.dispose();
    }
    async type(selector, text, options) {
        const handle = await this.$(selector);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(handle, 'No node found for selector: ' + selector);
        await handle.type(text, options);
        await handle.dispose();
    }
    async waitForSelector(selector, options) {
        const { updatedSelector, queryHandler } = (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_4__.getQueryHandlerAndSelector)(selector);
        return queryHandler.waitFor(this, updatedSelector, options);
    }
    /**
     * @internal
     */
    async addBindingToContext(context, name) {
        // Previous operation added the binding so we are done.
        if (this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {
            return;
        }
        // Wait for other operation to finish
        if (this._settingUpBinding) {
            await this._settingUpBinding;
            return this.addBindingToContext(context, name);
        }
        const bind = async (name) => {
            const expression = _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.pageBindingInitString('internal', name);
            try {
                // TODO: In theory, it would be enough to call this just once
                await context._client.send('Runtime.addBinding', {
                    name,
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore The protocol definition is not up to date.
                    executionContextName: context._contextName,
                });
                await context.evaluate(expression);
            }
            catch (error) {
                // We could have tried to evaluate in a context which was already
                // destroyed. This happens, for example, if the page is navigated while
                // we are trying to add the binding
                const ctxDestroyed = error.message.includes('Execution context was destroyed');
                const ctxNotFound = error.message.includes('Cannot find context with specified id');
                if (ctxDestroyed || ctxNotFound) {
                    return;
                }
                else {
                    (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
                    return;
                }
            }
            this._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));
        };
        this._settingUpBinding = bind(name);
        await this._settingUpBinding;
        this._settingUpBinding = null;
    }
    async _onBindingCalled(event) {
        let payload;
        if (!this._hasContext())
            return;
        const context = await this.executionContext();
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            // The binding was either called by something in the page or it was
            // called before our wrapper was initialized.
            return;
        }
        const { type, name, seq, args } = payload;
        if (type !== 'internal' ||
            !this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId)))
            return;
        if (context._contextId !== event.executionContextId)
            return;
        try {
            const result = await this._boundFunctions.get(name)(...args);
            await context.evaluate(deliverResult, name, seq, result);
        }
        catch (error) {
            // The WaitTask may already have been resolved by timing out, or the
            // exection context may have been destroyed.
            // In both caes, the promises above are rejected with a protocol error.
            // We can safely ignores these, as the WaitTask is re-installed in
            // the next execution context if needed.
            if (error.message.includes('Protocol error'))
                return;
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        }
        function deliverResult(name, seq, result) {
            globalThis[name].callbacks.get(seq).resolve(result);
            globalThis[name].callbacks.delete(seq);
        }
    }
    /**
     * @internal
     */
    async waitForSelectorInPage(queryOne, selector, options, binding) {
        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;
        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';
        const title = `selector \`${selector}\`${waitForHidden ? ' to be hidden' : ''}`;
        async function predicate(selector, waitForVisible, waitForHidden) {
            const node = predicateQueryHandler
                ? (await predicateQueryHandler(document, selector))
                : document.querySelector(selector);
            return checkWaitForOptions(node, waitForVisible, waitForHidden);
        }
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.makePredicateString(predicate, queryOne),
            title,
            polling,
            timeout,
            args: [selector, waitForVisible, waitForHidden],
            binding,
        };
        const waitTask = new WaitTask(waitTaskOptions);
        const jsHandle = await waitTask.promise;
        const elementHandle = jsHandle.asElement();
        if (!elementHandle) {
            await jsHandle.dispose();
            return null;
        }
        return elementHandle;
    }
    async waitForXPath(xpath, options) {
        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;
        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';
        const title = `XPath \`${xpath}\`${waitForHidden ? ' to be hidden' : ''}`;
        function predicate(xpath, waitForVisible, waitForHidden) {
            const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            return checkWaitForOptions(node, waitForVisible, waitForHidden);
        }
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.makePredicateString(predicate),
            title,
            polling,
            timeout,
            args: [xpath, waitForVisible, waitForHidden],
        };
        const waitTask = new WaitTask(waitTaskOptions);
        const jsHandle = await waitTask.promise;
        const elementHandle = jsHandle.asElement();
        if (!elementHandle) {
            await jsHandle.dispose();
            return null;
        }
        return elementHandle;
    }
    waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = 'raf', timeout = this._timeoutSettings.timeout() } = options;
        const waitTaskOptions = {
            domWorld: this,
            predicateBody: pageFunction,
            title: 'function',
            polling,
            timeout,
            args,
        };
        const waitTask = new WaitTask(waitTaskOptions);
        return waitTask.promise;
    }
    async title() {
        return this.evaluate(() => document.title);
    }
}
DOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;
/**
 * @internal
 */
class WaitTask {
    constructor(options) {
        this._runCount = 0;
        this._terminated = false;
        if (_helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isString(options.polling))
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);
        else if (_helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isNumber(options.polling))
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);
        else
            throw new Error('Unknown polling options: ' + options.polling);
        function getPredicateBody(predicateBody) {
            if (_helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isString(predicateBody))
                return `return (${predicateBody});`;
            return `return (${predicateBody})(...args);`;
        }
        this._domWorld = options.domWorld;
        this._polling = options.polling;
        this._timeout = options.timeout;
        this._predicateBody = getPredicateBody(options.predicateBody);
        this._args = options.args;
        this._binding = options.binding;
        this._runCount = 0;
        this._domWorld._waitTasks.add(this);
        if (this._binding) {
            this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);
        }
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        // Since page navigation requires us to re-install the pageScript, we should track
        // timeout on our end.
        if (options.timeout) {
            const timeoutError = new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);
            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);
        }
        this.rerun();
    }
    terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._cleanup();
    }
    async rerun() {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        const context = await this._domWorld.executionContext();
        if (this._terminated || runCount !== this._runCount)
            return;
        if (this._binding) {
            await this._domWorld.addBindingToContext(context, this._binding.name);
        }
        if (this._terminated || runCount !== this._runCount)
            return;
        try {
            success = await context.evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);
        }
        catch (error_) {
            error = error_;
        }
        if (this._terminated || runCount !== this._runCount) {
            if (success)
                await success.dispose();
            return;
        }
        // Ignore timeouts in pageScript - we track timeouts ourselves.
        // If the frame's execution context has already changed, `frame.evaluate` will
        // throw an error - ignore this predicate run altogether.
        if (!error &&
            (await this._domWorld.evaluate((s) => !s, success).catch(() => true))) {
            await success.dispose();
            return;
        }
        if (error) {
            if (error.message.includes('TypeError: binding is not a function')) {
                return this.rerun();
            }
            // When frame is detached the task should have been terminated by the DOMWorld.
            // This can fail if we were adding this task while the frame was detached,
            // so we terminate here instead.
            if (error.message.includes('Execution context is not available in detached frame')) {
                this.terminate(new Error('waitForFunction failed: frame got detached.'));
                return;
            }
            // When the page is navigated, the promise is rejected.
            // We will try again in the new execution context.
            if (error.message.includes('Execution context was destroyed'))
                return;
            // We could have tried to evaluate in a context which was already
            // destroyed.
            if (error.message.includes('Cannot find context with specified id'))
                return;
            this._reject(error);
        }
        else {
            this._resolve(success);
        }
        this._cleanup();
    }
    _cleanup() {
        clearTimeout(this._timeoutTimer);
        this._domWorld._waitTasks.delete(this);
    }
}
async function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {
    const predicate = new Function('...args', predicateBody);
    let timedOut = false;
    if (timeout)
        setTimeout(() => (timedOut = true), timeout);
    if (polling === 'raf')
        return await pollRaf();
    if (polling === 'mutation')
        return await pollMutation();
    if (typeof polling === 'number')
        return await pollInterval(polling);
    /**
     * @returns {!Promise<*>}
     */
    async function pollMutation() {
        const success = await predicate(...args);
        if (success)
            return Promise.resolve(success);
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        const observer = new MutationObserver(async () => {
            if (timedOut) {
                observer.disconnect();
                fulfill();
            }
            const success = await predicate(...args);
            if (success) {
                observer.disconnect();
                fulfill(success);
            }
        });
        observer.observe(document, {
            childList: true,
            subtree: true,
            attributes: true,
        });
        return result;
    }
    async function pollRaf() {
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        await onRaf();
        return result;
        async function onRaf() {
            if (timedOut) {
                fulfill();
                return;
            }
            const success = await predicate(...args);
            if (success)
                fulfill(success);
            else
                requestAnimationFrame(onRaf);
        }
    }
    async function pollInterval(pollInterval) {
        let fulfill;
        const result = new Promise((x) => (fulfill = x));
        await onTimeout();
        return result;
        async function onTimeout() {
            if (timedOut) {
                fulfill();
                return;
            }
            const success = await predicate(...args);
            if (success)
                fulfill(success);
            else
                setTimeout(onTimeout, pollInterval);
        }
    }
}
//# sourceMappingURL=DOMWorld.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debug": () => (/* binding */ debug)
/* harmony export */ });
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A debug function that can be used in any environment.
 *
 * @remarks
 *
 * If used in Node, it falls back to the
 * {@link https://www.npmjs.com/package/debug | debug module}. In the browser it
 * uses `console.log`.
 *
 * @param prefix - this will be prefixed to each log.
 * @returns a function that can be called to log to that debug channel.
 *
 * In Node, use the `DEBUG` environment variable to control logging:
 *
 * ```
 * DEBUG=* // logs all channels
 * DEBUG=foo // logs the `foo` channel
 * DEBUG=foo* // logs any channels starting with `foo`
 * ```
 *
 * In the browser, set `window.__PUPPETEER_DEBUG` to a string:
 *
 * ```
 * window.__PUPPETEER_DEBUG='*'; // logs all channels
 * window.__PUPPETEER_DEBUG='foo'; // logs the `foo` channel
 * window.__PUPPETEER_DEBUG='foo*'; // logs any channels starting with `foo`
 * ```
 *
 * @example
 * ```
 * const log = debug('Page');
 *
 * log('new page created')
 * // logs "Page: new page created"
 * ```
 */
const debug = (prefix) => {
    if (_environment_js__WEBPACK_IMPORTED_MODULE_0__.isNode) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        return __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")(prefix);
    }
    return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel)
            return;
        const everythingShouldBeLogged = debugLevel === '*';
        const prefixMatchesDebugLevel = everythingShouldBeLogged ||
            /**
             * If the debug level is `foo*`, that means we match any prefix that
             * starts with `foo`. If the level is `foo`, we match only the prefix
             * `foo`.
             */
            (debugLevel.endsWith('*')
                ? prefix.startsWith(debugLevel)
                : prefix === debugLevel);
        if (!prefixMatchesDebugLevel)
            return;
        // eslint-disable-next-line no-console
        console.log(`${prefix}:`, ...logArgs);
    };
};
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/DeviceDescriptors.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/DeviceDescriptors.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "devicesMap": () => (/* binding */ devicesMap)
/* harmony export */ });
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const devices = [
    {
        name: 'Blackberry PlayBook',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 600,
            height: 1024,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Blackberry PlayBook landscape',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 1024,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'BlackBerry Z30',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'BlackBerry Z30 landscape',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note 3',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note 3 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note II',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note II landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S III',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S III landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S5',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Mini',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Mini landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Pro',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 1366,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Pro landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1366,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 4',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 320,
            height: 480,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 4 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 480,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 5',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 5 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone SE',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone SE landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone X',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone X landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone XR',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone XR landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 828,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 828,
            height: 414,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'JioPhone 2',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 240,
            height: 320,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'JioPhone 2 landscape',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 320,
            height: 240,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Kindle Fire HDX',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Kindle Fire HDX landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'LG Optimus L70',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'LG Optimus L70 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Microsoft Lumia 550',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950 landscape',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 10',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 10 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 4',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5X',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5X landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6P',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6P landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 7',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 600,
            height: 960,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 7 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 960,
            height: 600,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia Lumia 520',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 320,
            height: 533,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia Lumia 520 landscape',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 533,
            height: 320,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia N9',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 480,
            height: 854,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia N9 landscape',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 854,
            height: 480,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 731,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 731,
            height: 411,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2 XL',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 823,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 XL landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 823,
            height: 411,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
];
/**
 * @internal
 */
const devicesMap = {};
for (const device of devices)
    devicesMap[device.name] = device;
//# sourceMappingURL=DeviceDescriptors.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Dialog.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Dialog.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dialog": () => (/* binding */ Dialog)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Dialog instances are dispatched by the {@link Page} via the `dialog` event.
 *
 * @remarks
 *
 * @example
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   page.on('dialog', async dialog => {
 *     console.log(dialog.message());
 *     await dialog.dismiss();
 *     await browser.close();
 *   });
 *   page.evaluate(() => alert('1'));
 * })();
 * ```
 * @public
 */
class Dialog {
    /**
     * @internal
     */
    constructor(client, type, message, defaultValue = '') {
        this._handled = false;
        this._client = client;
        this._type = type;
        this._message = message;
        this._defaultValue = defaultValue;
    }
    /**
     * @returns The type of the dialog.
     */
    type() {
        return this._type;
    }
    /**
     * @returns The message displayed in the dialog.
     */
    message() {
        return this._message;
    }
    /**
     * @returns The default value of the prompt, or an empty string if the dialog
     * is not a `prompt`.
     */
    defaultValue() {
        return this._defaultValue;
    }
    /**
     * @param promptText - optional text that will be entered in the dialog
     * prompt. Has no effect if the dialog's type is not `prompt`.
     *
     * @returns A promise that resolves when the dialog has been accepted.
     */
    async accept(promptText) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._handled, 'Cannot accept dialog which is already handled!');
        this._handled = true;
        await this._client.send('Page.handleJavaScriptDialog', {
            accept: true,
            promptText: promptText,
        });
    }
    /**
     * @returns A promise which will resolve once the dialog has been dismissed
     */
    async dismiss() {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._handled, 'Cannot dismiss dialog which is already handled!');
        this._handled = true;
        await this._client.send('Page.handleJavaScriptDialog', {
            accept: false,
        });
    }
}
//# sourceMappingURL=Dialog.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EmulationManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/EmulationManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EmulationManager": () => (/* binding */ EmulationManager)
/* harmony export */ });
class EmulationManager {
    constructor(client) {
        this._emulatingMobile = false;
        this._hasTouch = false;
        this._client = client;
    }
    async emulateViewport(viewport) {
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = viewport.deviceScaleFactor || 1;
        const screenOrientation = viewport.isLandscape
            ? { angle: 90, type: 'landscapePrimary' }
            : { angle: 0, type: 'portraitPrimary' };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
            this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile,
                width,
                height,
                deviceScaleFactor,
                screenOrientation,
            }),
            this._client.send('Emulation.setTouchEmulationEnabled', {
                enabled: hasTouch,
            }),
        ]);
        const reloadNeeded = this._emulatingMobile !== mobile || this._hasTouch !== hasTouch;
        this._emulatingMobile = mobile;
        this._hasTouch = hasTouch;
        return reloadNeeded;
    }
}
//# sourceMappingURL=EmulationManager.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomError": () => (/* binding */ CustomError),
/* harmony export */   "TimeoutError": () => (/* binding */ TimeoutError),
/* harmony export */   "puppeteerErrors": () => (/* binding */ puppeteerErrors)
/* harmony export */ });
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @public
 */
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
/**
 * TimeoutError is emitted whenever certain operations are terminated due to timeout.
 *
 * @remarks
 *
 * Example operations are {@link Page.waitForSelector | page.waitForSelector}
 * or {@link PuppeteerNode.launch | puppeteer.launch}.
 *
 * @public
 */
class TimeoutError extends CustomError {
}
/**
 * @public
 */
const puppeteerErrors = {
    TimeoutError,
};
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitter": () => (/* binding */ EventEmitter)
/* harmony export */ });
/* harmony import */ var _vendor_mitt_src_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/mitt/src/index.js */ "./node_modules/puppeteer-core/lib/esm/vendor/mitt/src/index.js");

/**
 * The EventEmitter class that many Puppeteer classes extend.
 *
 * @remarks
 *
 * This allows you to listen to events that Puppeteer classes fire and act
 * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and
 * {@link EventEmitter.off | off} to bind
 * and unbind to event listeners.
 *
 * @public
 */
class EventEmitter {
    /**
     * @internal
     */
    constructor() {
        this.eventsMap = new Map();
        this.emitter = (0,_vendor_mitt_src_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(this.eventsMap);
    }
    /**
     * Bind an event listener to fire when an event occurs.
     * @param event - the event type you'd like to listen to. Can be a string or symbol.
     * @param handler  - the function to be called when the event occurs.
     * @returns `this` to enable you to chain method calls.
     */
    on(event, handler) {
        this.emitter.on(event, handler);
        return this;
    }
    /**
     * Remove an event listener from firing.
     * @param event - the event type you'd like to stop listening to.
     * @param handler  - the function that should be removed.
     * @returns `this` to enable you to chain method calls.
     */
    off(event, handler) {
        this.emitter.off(event, handler);
        return this;
    }
    /**
     * Remove an event listener.
     * @deprecated please use {@link EventEmitter.off} instead.
     */
    removeListener(event, handler) {
        this.off(event, handler);
        return this;
    }
    /**
     * Add an event listener.
     * @deprecated please use {@link EventEmitter.on} instead.
     */
    addListener(event, handler) {
        this.on(event, handler);
        return this;
    }
    /**
     * Emit an event and call any associated listeners.
     *
     * @param event - the event you'd like to emit
     * @param eventData - any data you'd like to emit with the event
     * @returns `true` if there are any listeners, `false` if there are not.
     */
    emit(event, eventData) {
        this.emitter.emit(event, eventData);
        return this.eventListenersCount(event) > 0;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param event - the event you'd like to listen to
     * @param handler - the handler function to run when the event occurs
     * @returns `this` to enable you to chain method calls.
     */
    once(event, handler) {
        const onceHandler = (eventData) => {
            handler(eventData);
            this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
    }
    /**
     * Gets the number of listeners for a given event.
     *
     * @param event - the event to get the listener count for
     * @returns the number of listeners bound to the given event
     */
    listenerCount(event) {
        return this.eventListenersCount(event);
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     * @param event - the event to remove listeners for.
     * @returns `this` to enable you to chain method calls.
     */
    removeAllListeners(event) {
        if (event) {
            this.eventsMap.delete(event);
        }
        else {
            this.eventsMap.clear();
        }
        return this;
    }
    eventListenersCount(event) {
        return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;
    }
}
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVALUATION_SCRIPT_URL": () => (/* binding */ EVALUATION_SCRIPT_URL),
/* harmony export */   "ExecutionContext": () => (/* binding */ ExecutionContext)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @public
 */
const EVALUATION_SCRIPT_URL = '__puppeteer_evaluation_script__';
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
/**
 * This class represents a context for JavaScript execution. A [Page] might have
 * many execution contexts:
 * - each
 *   {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe |
 *   frame } has "default" execution context that is always created after frame is
 *   attached to DOM. This context is returned by the
 *   {@link Frame.executionContext} method.
 * - {@link https://developer.chrome.com/extensions | Extension}'s content scripts
 *   create additional execution contexts.
 *
 * Besides pages, execution contexts can be found in
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |
 * workers }.
 *
 * @public
 */
class ExecutionContext {
    /**
     * @internal
     */
    constructor(client, contextPayload, world) {
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
        this._contextName = contextPayload.name;
    }
    /**
     * @remarks
     *
     * Not every execution context is associated with a frame. For
     * example, workers and extensions have execution contexts that are not
     * associated with frames.
     *
     * @returns The frame associated with this execution context.
     */
    frame() {
        return this._world ? this._world.frame() : null;
    }
    /**
     * @remarks
     * If the function passed to the `executionContext.evaluate` returns a
     * Promise, then `executionContext.evaluate` would wait for the promise to
     * resolve and return its value. If the function passed to the
     * `executionContext.evaluate` returns a non-serializable value, then
     * `executionContext.evaluate` resolves to `undefined`. DevTools Protocol also
     * supports transferring some additional values that are not serializable by
     * `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
     *
     *
     * @example
     * ```js
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```js
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the
     * `executionContext.* evaluate`:
     * ```js
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *    (a, b) => a + b, oneHandle, * twoHandle
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     * @param pageFunction - a function to be evaluated in the `executionContext`
     * @param args - argument to pass to the page function
     *
     * @returns A promise that resolves to the return value of the given function.
     */
    async evaluate(pageFunction, ...args) {
        return await this._evaluateInternal(true, pageFunction, ...args);
    }
    /**
     * @remarks
     * The only difference between `executionContext.evaluate` and
     * `executionContext.evaluateHandle` is that `executionContext.evaluateHandle`
     * returns an in-page object (a {@link JSHandle}).
     * If the function passed to the `executionContext.evaluateHandle` returns a
     * Promise, then `executionContext.evaluateHandle` would wait for the
     * promise to resolve and return its value.
     *
     * @example
     * ```js
     * const context = await page.mainFrame().executionContext();
     * const aHandle = await context.evaluateHandle(() => Promise.resolve(self));
     * aHandle; // Handle for the global object.
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```js
     * // Handle for the '3' * object.
     * const aHandle = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * JSHandle instances can be passed as arguments
     * to the `executionContext.* evaluateHandle`:
     *
     * ```js
     * const aHandle = await context.evaluateHandle(() => document.body);
     * const resultHandle = await context.evaluateHandle(body => body.innerHTML, * aHandle);
     * console.log(await resultHandle.jsonValue()); // prints body's innerHTML
     * await aHandle.dispose();
     * await resultHandle.dispose();
     * ```
     *
     * @param pageFunction - a function to be evaluated in the `executionContext`
     * @param args - argument to pass to the page function
     *
     * @returns A promise that resolves to the return value of the given function
     * as an in-page object (a {@link JSHandle}).
     */
    async evaluateHandle(pageFunction, ...args) {
        return this._evaluateInternal(false, pageFunction, ...args);
    }
    async _evaluateInternal(returnByValue, pageFunction, ...args) {
        const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;
        if (_helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)
                ? expression
                : expression + '\n' + suffix;
            const { exceptionDetails, result: remoteObject } = await this._client
                .send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            })
                .catch(rewriteError);
            if (exceptionDetails)
                throw new Error('Evaluation failed: ' + _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.getExceptionMessage(exceptionDetails));
            return returnByValue
                ? _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.valueFromRemoteObject(remoteObject)
                : (0,_JSHandle_js__WEBPACK_IMPORTED_MODULE_2__.createJSHandle)(this, remoteObject);
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (error) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText =
                    'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (error) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        let callFunctionOnPromise;
        try {
            callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: functionText + '\n' + suffix + '\n',
                executionContextId: this._contextId,
                arguments: args.map(convertArgument.bind(this)),
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            });
        }
        catch (error) {
            if (error instanceof TypeError &&
                error.message.startsWith('Converting circular structure to JSON'))
                error.message += ' Are you passing a nested JSHandle?';
            throw error;
        }
        const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.getExceptionMessage(exceptionDetails));
        return returnByValue
            ? _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.valueFromRemoteObject(remoteObject)
            : (0,_JSHandle_js__WEBPACK_IMPORTED_MODULE_2__.createJSHandle)(this, remoteObject);
        /**
         * @param {*} arg
         * @returns {*}
         * @this {ExecutionContext}
         */
        function convertArgument(arg) {
            if (typeof arg === 'bigint')
                // eslint-disable-line valid-typeof
                return { unserializableValue: `${arg.toString()}n` };
            if (Object.is(arg, -0))
                return { unserializableValue: '-0' };
            if (Object.is(arg, Infinity))
                return { unserializableValue: 'Infinity' };
            if (Object.is(arg, -Infinity))
                return { unserializableValue: '-Infinity' };
            if (Object.is(arg, NaN))
                return { unserializableValue: 'NaN' };
            const objectHandle = arg && arg instanceof _JSHandle_js__WEBPACK_IMPORTED_MODULE_2__.JSHandle ? arg : null;
            if (objectHandle) {
                if (objectHandle._context !== this)
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                if (objectHandle._disposed)
                    throw new Error('JSHandle is disposed!');
                if (objectHandle._remoteObject.unserializableValue)
                    return {
                        unserializableValue: objectHandle._remoteObject.unserializableValue,
                    };
                if (!objectHandle._remoteObject.objectId)
                    return { value: objectHandle._remoteObject.value };
                return { objectId: objectHandle._remoteObject.objectId };
            }
            return { value: arg };
        }
        function rewriteError(error) {
            if (error.message.includes('Object reference chain is too long'))
                return { result: { type: 'undefined' } };
            if (error.message.includes("Object couldn't be returned by value"))
                return { result: { type: 'undefined' } };
            if (error.message.endsWith('Cannot find context with specified id') ||
                error.message.endsWith('Inspected target navigated or closed'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    /**
     * This method iterates the JavaScript heap and finds all the objects with the
     * given prototype.
     * @remarks
     * @example
     * ```js
     * // Create a Map object
     * await page.evaluate(() => window.map = new Map());
     * // Get a handle to the Map object prototype
     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
     * // Query all map instances into an array
     * const mapInstances = await page.queryObjects(mapPrototype);
     * // Count amount of map objects in heap
     * const count = await page.evaluate(maps => maps.length, mapInstances);
     * await mapInstances.dispose();
     * await mapPrototype.dispose();
     * ```
     *
     * @param prototypeHandle - a handle to the object prototype
     *
     * @returns A handle to an array of objects with the given prototype.
     */
    async queryObjects(prototypeHandle) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!prototypeHandle._disposed, 'Prototype JSHandle is disposed!');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(prototypeHandle._remoteObject.objectId, 'Prototype JSHandle must not be referencing primitive value');
        const response = await this._client.send('Runtime.queryObjects', {
            prototypeObjectId: prototypeHandle._remoteObject.objectId,
        });
        return (0,_JSHandle_js__WEBPACK_IMPORTED_MODULE_2__.createJSHandle)(this, response.objects);
    }
    /**
     * @internal
     */
    async _adoptBackendNodeId(backendNodeId) {
        const { object } = await this._client.send('DOM.resolveNode', {
            backendNodeId: backendNodeId,
            executionContextId: this._contextId,
        });
        return (0,_JSHandle_js__WEBPACK_IMPORTED_MODULE_2__.createJSHandle)(this, object);
    }
    /**
     * @internal
     */
    async _adoptElementHandle(elementHandle) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(elementHandle.executionContext() !== this, 'Cannot adopt handle that already belongs to this execution context');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._world, 'Cannot adopt handle without DOMWorld');
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: elementHandle._remoteObject.objectId,
        });
        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId);
    }
}
//# sourceMappingURL=ExecutionContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileChooser": () => (/* binding */ FileChooser)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * File choosers let you react to the page requesting for a file.
 * @remarks
 * `FileChooser` objects are returned via the `page.waitForFileChooser` method.
 * @example
 * An example of using `FileChooser`:
 * ```js
 * const [fileChooser] = await Promise.all([
 *   page.waitForFileChooser(),
 *   page.click('#upload-file-button'), // some button that triggers file selection
 * ]);
 * await fileChooser.accept(['/tmp/myfile.pdf']);
 * ```
 * **NOTE** In browsers, only one file chooser can be opened at a time.
 * All file choosers must be accepted or canceled. Not doing so will prevent
 * subsequent file choosers from appearing.
 * @public
 */
class FileChooser {
    /**
     * @internal
     */
    constructor(element, event) {
        this._handled = false;
        this._element = element;
        this._multiple = event.mode !== 'selectSingle';
    }
    /**
     * Whether file chooser allow for {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple} file selection.
     */
    isMultiple() {
        return this._multiple;
    }
    /**
     * Accept the file chooser request with given paths.
     * @param filePaths - If some of the  `filePaths` are relative paths,
     * then they are resolved relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     */
    async accept(filePaths) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._handled, 'Cannot accept FileChooser which is already handled!');
        this._handled = true;
        await this._element.uploadFile(...filePaths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    cancel() {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._handled, 'Cannot cancel FileChooser which is already handled!');
        this._handled = true;
    }
}
//# sourceMappingURL=FileChooser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameManager.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrameManagerEmittedEvents": () => (/* binding */ FrameManagerEmittedEvents),
/* harmony export */   "FrameManager": () => (/* binding */ FrameManager),
/* harmony export */   "Frame": () => (/* binding */ Frame)
/* harmony export */ });
/* harmony import */ var _common_Debug_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExecutionContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js");
/* harmony import */ var _LifecycleWatcher_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LifecycleWatcher.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/LifecycleWatcher.js");
/* harmony import */ var _DOMWorld_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DOMWorld.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/DOMWorld.js");
/* harmony import */ var _NetworkManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./NetworkManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








const UTILITY_WORLD_NAME = '__puppeteer_utility_world__';
/**
 * We use symbols to prevent external parties listening to these events.
 * They are internal to Puppeteer.
 *
 * @internal
 */
const FrameManagerEmittedEvents = {
    FrameAttached: Symbol('FrameManager.FrameAttached'),
    FrameNavigated: Symbol('FrameManager.FrameNavigated'),
    FrameDetached: Symbol('FrameManager.FrameDetached'),
    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),
    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),
    ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),
    ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),
};
/**
 * @internal
 */
class FrameManager extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
        super();
        this._frames = new Map();
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client = client;
        this._page = page;
        this._networkManager = new _NetworkManager_js__WEBPACK_IMPORTED_MODULE_7__.NetworkManager(client, ignoreHTTPSErrors, this);
        this._timeoutSettings = timeoutSettings;
        this._client.on('Page.frameAttached', (event) => this._onFrameAttached(event.frameId, event.parentFrameId));
        this._client.on('Page.frameNavigated', (event) => this._onFrameNavigated(event.frame));
        this._client.on('Page.navigatedWithinDocument', (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));
        this._client.on('Page.frameDetached', (event) => this._onFrameDetached(event.frameId));
        this._client.on('Page.frameStoppedLoading', (event) => this._onFrameStoppedLoading(event.frameId));
        this._client.on('Runtime.executionContextCreated', (event) => this._onExecutionContextCreated(event.context));
        this._client.on('Runtime.executionContextDestroyed', (event) => this._onExecutionContextDestroyed(event.executionContextId));
        this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());
        this._client.on('Page.lifecycleEvent', (event) => this._onLifecycleEvent(event));
        this._client.on('Target.attachedToTarget', async (event) => this._onFrameMoved(event));
    }
    async initialize() {
        const result = await Promise.all([
            this._client.send('Page.enable'),
            this._client.send('Page.getFrameTree'),
        ]);
        const { frameTree } = result[1];
        this._handleFrameTree(frameTree);
        await Promise.all([
            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
            this._client
                .send('Runtime.enable')
                .then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
            this._networkManager.initialize(),
        ]);
    }
    networkManager() {
        return this._networkManager;
    }
    async navigateFrame(frame, url, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const { referer = this._networkManager.extraHTTPHeaders()['referer'], waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        const watcher = new _LifecycleWatcher_js__WEBPACK_IMPORTED_MODULE_5__.LifecycleWatcher(this, frame, waitUntil, timeout);
        let ensureNewDocumentNavigation = false;
        let error = await Promise.race([
            navigate(this._client, url, referer, frame._id),
            watcher.timeoutOrTerminationPromise(),
        ]);
        if (!error) {
            error = await Promise.race([
                watcher.timeoutOrTerminationPromise(),
                ensureNewDocumentNavigation
                    ? watcher.newDocumentNavigationPromise()
                    : watcher.sameDocumentNavigationPromise(),
            ]);
        }
        watcher.dispose();
        if (error)
            throw error;
        return watcher.navigationResponse();
        async function navigate(client, url, referrer, frameId) {
            try {
                const response = await client.send('Page.navigate', {
                    url,
                    referrer,
                    frameId,
                });
                ensureNewDocumentNavigation = !!response.loaderId;
                return response.errorText
                    ? new Error(`${response.errorText} at ${url}`)
                    : null;
            }
            catch (error) {
                return error;
            }
        }
    }
    async waitForFrameNavigation(frame, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;
        const watcher = new _LifecycleWatcher_js__WEBPACK_IMPORTED_MODULE_5__.LifecycleWatcher(this, frame, waitUntil, timeout);
        const error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.sameDocumentNavigationPromise(),
            watcher.newDocumentNavigationPromise(),
        ]);
        watcher.dispose();
        if (error)
            throw error;
        return watcher.navigationResponse();
    }
    async _onFrameMoved(event) {
        if (event.targetInfo.type !== 'iframe') {
            return;
        }
        // TODO(sadym): Remove debug message once proper OOPIF support is
        // implemented: https://github.com/puppeteer/puppeteer/issues/2548
        (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_0__.debug)('puppeteer:frame')(`The frame '${event.targetInfo.targetId}' moved to another session. ` +
            `Out-of-process iframes (OOPIF) are not supported by Puppeteer yet. ` +
            `https://github.com/puppeteer/puppeteer/issues/2548`);
    }
    _onLifecycleEvent(event) {
        const frame = this._frames.get(event.frameId);
        if (!frame)
            return;
        frame._onLifecycleEvent(event.loaderId, event.name);
        this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);
    }
    _onFrameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._onLoadingStopped();
        this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);
    }
    _handleFrameTree(frameTree) {
        if (frameTree.frame.parentId)
            this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);
        this._onFrameNavigated(frameTree.frame);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    page() {
        return this._page;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        return Array.from(this._frames.values());
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    _onFrameAttached(frameId, parentFrameId) {
        if (this._frames.has(frameId))
            return;
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(parentFrameId);
        const parentFrame = this._frames.get(parentFrameId);
        const frame = new Frame(this, parentFrame, frameId);
        this._frames.set(frame._id, frame);
        this.emit(FrameManagerEmittedEvents.FrameAttached, frame);
    }
    _onFrameNavigated(framePayload) {
        const isMainFrame = !framePayload.parentId;
        let frame = isMainFrame
            ? this._mainFrame
            : this._frames.get(framePayload.id);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');
        // Detach all child frames first.
        if (frame) {
            for (const child of frame.childFrames())
                this._removeFramesRecursively(child);
        }
        // Update or create main frame.
        if (isMainFrame) {
            if (frame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(frame._id);
                frame._id = framePayload.id;
            }
            else {
                // Initial main frame navigation.
                frame = new Frame(this, null, framePayload.id);
            }
            this._frames.set(framePayload.id, frame);
            this._mainFrame = frame;
        }
        // Update frame payload.
        frame._navigated(framePayload);
        this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);
    }
    async _ensureIsolatedWorld(name) {
        if (this._isolatedWorlds.has(name))
            return;
        this._isolatedWorlds.add(name);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `//# sourceURL=${_ExecutionContext_js__WEBPACK_IMPORTED_MODULE_4__.EVALUATION_SCRIPT_URL}`,
            worldName: name,
        });
        // Frames might be removed before we send this.
        await Promise.all(this.frames().map((frame) => this._client
            .send('Page.createIsolatedWorld', {
            frameId: frame._id,
            worldName: name,
            grantUniveralAccess: true,
        })
            .catch(_helper_js__WEBPACK_IMPORTED_MODULE_3__.debugError)));
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._navigatedWithinDocument(url);
        this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
        this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);
    }
    _onFrameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    _onExecutionContextCreated(contextPayload) {
        const auxData = contextPayload.auxData;
        const frameId = auxData ? auxData.frameId : null;
        const frame = this._frames.get(frameId) || null;
        let world = null;
        if (frame) {
            if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {
                world = frame._mainWorld;
            }
            else if (contextPayload.name === UTILITY_WORLD_NAME &&
                !frame._secondaryWorld._hasContext()) {
                // In case of multiple sessions to the same target, there's a race between
                // connections so we might end up creating multiple isolated worlds.
                // We can use either.
                world = frame._secondaryWorld;
            }
        }
        const context = new _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionContext(this._client, contextPayload, world);
        if (world)
            world._setContext(context);
        this._contextIdToContext.set(contextPayload.id, context);
    }
    _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        if (context._world)
            context._world._setContext(null);
    }
    _onExecutionContextsCleared() {
        for (const context of this._contextIdToContext.values()) {
            if (context._world)
                context._world._setContext(null);
        }
        this._contextIdToContext.clear();
    }
    executionContextById(contextId) {
        const context = this._contextIdToContext.get(contextId);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(context, 'INTERNAL ERROR: missing context with id = ' + contextId);
        return context;
    }
    _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._detach();
        this._frames.delete(frame._id);
        this.emit(FrameManagerEmittedEvents.FrameDetached, frame);
    }
}
/**
 * At every point of time, page exposes its current frame tree via the
 * {@link Page.mainFrame | page.mainFrame} and
 * {@link Frame.childFrames | frame.childFrames} methods.
 *
 * @remarks
 *
 * `Frame` object lifecycles are controlled by three events that are all
 * dispatched on the page object:
 *
 * - {@link PageEmittedEvents.FrameAttached}
 *
 * - {@link PageEmittedEvents.FrameNavigated}
 *
 * - {@link PageEmittedEvents.FrameDetached}
 *
 * @Example
 * An example of dumping frame tree:
 *
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com/chrome/browser/canary.html');
 *   dumpFrameTree(page.mainFrame(), '');
 *   await browser.close();
 *
 *   function dumpFrameTree(frame, indent) {
 *     console.log(indent + frame.url());
 *     for (const child of frame.childFrames()) {
 *     dumpFrameTree(child, indent + '  ');
 *     }
 *   }
 * })();
 * ```
 *
 * @Example
 * An example of getting text from an iframe element:
 *
 * ```js
 * const frame = page.frames().find(frame => frame.name() === 'myframe');
 * const text = await frame.$eval('.selector', element => element.textContent);
 * console.log(text);
 * ```
 *
 * @public
 */
class Frame {
    /**
     * @internal
     */
    constructor(frameManager, parentFrame, frameId) {
        this._url = '';
        this._detached = false;
        /**
         * @internal
         */
        this._loaderId = '';
        /**
         * @internal
         */
        this._lifecycleEvents = new Set();
        this._frameManager = frameManager;
        this._parentFrame = parentFrame;
        this._url = '';
        this._id = frameId;
        this._detached = false;
        this._loaderId = '';
        this._mainWorld = new _DOMWorld_js__WEBPACK_IMPORTED_MODULE_6__.DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._secondaryWorld = new _DOMWorld_js__WEBPACK_IMPORTED_MODULE_6__.DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._childFrames = new Set();
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    /**
     * @remarks
     *
     * `frame.goto` will throw an error if:
     * - there's an SSL error (e.g. in case of self-signed certificates).
     *
     * - target URL is invalid.
     *
     * - the `timeout` is exceeded during navigation.
     *
     * - the remote server does not respond or is unreachable.
     *
     * - the main resource failed to load.
     *
     * `frame.goto` will not throw an error when any valid HTTP status code is
     * returned by the remote server, including 404 "Not Found" and 500 "Internal
     * Server Error".  The status code for such responses can be retrieved by
     * calling {@link HTTPResponse.status}.
     *
     * NOTE: `frame.goto` either throws an error or returns a main resource
     * response. The only exceptions are navigation to `about:blank` or
     * navigation to the same URL with a different hash, which would succeed and
     * return `null`.
     *
     * NOTE: Headless mode doesn't support navigation to a PDF document. See
     * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
     * issue}.
     *
     * @param url - the URL to navigate the frame to. This should include the
     * scheme, e.g. `https://`.
     * @param options - navigation options. `waitUntil` is useful to define when
     * the navigation should be considered successful - see the docs for
     * {@link PuppeteerLifeCycleEvent} for more details.
     *
     * @returns A promise which resolves to the main resource response. In case of
     * multiple redirects, the navigation will resolve with the response of the
     * last redirect.
     */
    async goto(url, options = {}) {
        return await this._frameManager.navigateFrame(this, url, options);
    }
    /**
     * @remarks
     *
     * This resolves when the frame navigates to a new URL. It is useful for when
     * you run code which will indirectly cause the frame to navigate. Consider
     * this example:
     *
     * ```js
     * const [response] = await Promise.all([
     *   // The navigation promise resolves after navigation has finished
     *   frame.waitForNavigation(),
     *   // Clicking the link will indirectly cause a navigation
     *   frame.click('a.my-link'),
     * ]);
     * ```
     *
     * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.
     *
     * @param options - options to configure when the navigation is consided finished.
     * @returns a promise that resolves when the frame navigates to a new URL.
     */
    async waitForNavigation(options = {}) {
        return await this._frameManager.waitForFrameNavigation(this, options);
    }
    /**
     * @returns a promise that resolves to the frame's default execution context.
     */
    executionContext() {
        return this._mainWorld.executionContext();
    }
    /**
     * @remarks
     *
     * The only difference between {@link Frame.evaluate} and
     * `frame.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * This method behaves identically to {@link Page.evaluateHandle} except it's
     * run within the context of the `frame`, rather than the entire page.
     *
     * @param pageFunction - a function that is run within the frame
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
        return this._mainWorld.evaluateHandle(pageFunction, ...args);
    }
    /**
     * @remarks
     *
     * This method behaves identically to {@link Page.evaluate} except it's run
     * within the context of the `frame`, rather than the entire page.
     *
     * @param pageFunction - a function that is run within the frame
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluate(pageFunction, ...args) {
        return this._mainWorld.evaluate(pageFunction, ...args);
    }
    /**
     * This method queries the frame for the given selector.
     *
     * @param selector - a selector to query for.
     * @returns A promise which resolves to an `ElementHandle` pointing at the
     * element, or `null` if it was not found.
     */
    async $(selector) {
        return this._mainWorld.$(selector);
    }
    /**
     * This method evaluates the given XPath expression and returns the results.
     *
     * @param expression - the XPath expression to evaluate.
     */
    async $x(expression) {
        return this._mainWorld.$x(expression);
    }
    /**
     * @remarks
     *
     * This method runs `document.querySelector` within
     * the frame and passes it as the first argument to `pageFunction`.
     *
     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for
     * the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector - the selector to query for
     * @param pageFunction - the function to be evaluated in the frame's context
     * @param args - additional arguments to pass to `pageFuncton`
     */
    async $eval(selector, pageFunction, ...args) {
        return this._mainWorld.$eval(selector, pageFunction, ...args);
    }
    /**
     * @remarks
     *
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the frame and passes it as the first argument to `pageFunction`.
     *
     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for
     * the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector - the selector to query for
     * @param pageFunction - the function to be evaluated in the frame's context
     * @param args - additional arguments to pass to `pageFuncton`
     */
    async $$eval(selector, pageFunction, ...args) {
        return this._mainWorld.$$eval(selector, pageFunction, ...args);
    }
    /**
     * This runs `document.querySelectorAll` in the frame and returns the result.
     *
     * @param selector - a selector to search for
     * @returns An array of element handles pointing to the found frame elements.
     */
    async $$(selector) {
        return this._mainWorld.$$(selector);
    }
    /**
     * @returns the full HTML contents of the frame, including the doctype.
     */
    async content() {
        return this._secondaryWorld.content();
    }
    /**
     * Set the content of the frame.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - options to configure how long before timing out and at
     * what point to consider the content setting successful.
     */
    async setContent(html, options = {}) {
        return this._secondaryWorld.setContent(html, options);
    }
    /**
     * @remarks
     *
     * If the name is empty, it returns the `id` attribute instead.
     *
     * Note: This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @returns the frame's `name` attribute as specified in the tag.
     */
    name() {
        return this._name || '';
    }
    /**
     * @returns the frame's URL.
     */
    url() {
        return this._url;
    }
    /**
     * @returns the parent `Frame`, if any. Detached and main frames return `null`.
     */
    parentFrame() {
        return this._parentFrame;
    }
    /**
     * @returns an array of child frames.
     */
    childFrames() {
        return Array.from(this._childFrames);
    }
    /**
     * @returns `true` if the frame has been detached, or `false` otherwise.
     */
    isDetached() {
        return this._detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - configure the script to add to the page.
     *
     * @returns a promise that resolves to the added tag when the script's
     * `onload` event fires or when the script content was injected into the
     * frame.
     */
    async addScriptTag(options) {
        return this._mainWorld.addScriptTag(options);
    }
    /**
     * Adds a `<link rel="stylesheet">` tag into the page with the desired url or
     * a `<style type="text/css">` tag with the content.
     *
     * @param options - configure the CSS to add to the page.
     *
     * @returns a promise that resolves to the added tag when the stylesheets's
     * `onload` event fires or when the CSS content was injected into the
     * frame.
     */
    async addStyleTag(options) {
        return this._mainWorld.addStyleTag(options);
    }
    /**
     *
     * This method clicks the first element found that matches `selector`.
     *
     * @remarks
     *
     * This method scrolls the element into view if needed, and then uses
     * {@link Page.mouse} to click in the center of the element. If there's no
     * element matching `selector`, the method throws an error.
     *
     * Bear in mind that if `click()` triggers a navigation event and there's a
     * separate `page.waitForNavigation()` promise to be resolved, you may end up
     * with a race condition that yields unexpected results. The correct pattern
     * for click and wait for navigation is the following:
     *
     * ```javascript
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     * @param selector - the selector to search for to click. If there are
     * multiple elements, the first will be clicked.
     */
    async click(selector, options = {}) {
        return this._secondaryWorld.click(selector, options);
    }
    /**
     * This method fetches an element with `selector` and focuses it.
     *
     * @remarks
     * If there's no element matching `selector`, the method throws an error.
     *
     * @param selector - the selector for the element to focus. If there are
     * multiple elements, the first will be focused.
     */
    async focus(selector) {
        return this._secondaryWorld.focus(selector);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to hover over the center of the
     * element.
     *
     * @remarks
     * If there's no element matching `selector`, the method throws an
     *
     * @param selector - the selector for the element to hover. If there are
     * multiple elements, the first will be hovered.
     */
    async hover(selector) {
        return this._secondaryWorld.hover(selector);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have
     * been selected.
     *
     * @remarks
     *
     * If there's no `<select>` element matching `selector`, the
     * method throws an error.
     *
     * @example
     * ```js
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - a selector to query the frame for
     * @param values - an array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     */
    select(selector, ...values) {
        return this._secondaryWorld.select(selector, ...values);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen} to tap in the center of the
     * element.
     *
     * @remarks
     *
     * If there's no element matching `selector`, the method throws an error.
     *
     * @param selector - the selector to tap.
     * @returns a promise that resolves when the element has been tapped.
     */
    async tap(selector) {
        return this._secondaryWorld.tap(selector);
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     * ```js
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     *
     * @returns a promise that resolves when the typing is complete.
     */
    async type(selector, text, options) {
        return this._mainWorld.type(selector, text, options);
    }
    /**
     * @remarks
     *
     * This method behaves differently depending on the first parameter. If it's a
     * `string`, it will be treated as a `selector` or `xpath` (if the string
     * starts with `//`). This method then is a shortcut for
     * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.
     *
     * If the first argument is a function this method is a shortcut for
     * {@link Frame.waitForFunction}.
     *
     * If the first argument is a `number`, it's treated as a timeout in
     * milliseconds and the method returns a promise which resolves after the
     * timeout.
     *
     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to
     * wait for.
     * @param options - optional waiting parameters.
     * @param args - arguments to pass to `pageFunction`.
     *
     * @deprecated Don't use this method directly. Instead use the more explicit
     * methods available: {@link Frame.waitForSelector},
     * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or
     * {@link Frame.waitForTimeout}.
     */
    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        const xPathPattern = '//';
        console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');
        if (_helper_js__WEBPACK_IMPORTED_MODULE_3__.helper.isString(selectorOrFunctionOrTimeout)) {
            const string = selectorOrFunctionOrTimeout;
            if (string.startsWith(xPathPattern))
                return this.waitForXPath(string, options);
            return this.waitForSelector(string, options);
        }
        if (_helper_js__WEBPACK_IMPORTED_MODULE_3__.helper.isNumber(selectorOrFunctionOrTimeout))
            return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === 'function')
            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));
    }
    /**
     * Causes your script to wait for the given number of milliseconds.
     *
     * @remarks
     * It's generally recommended to not wait for a number of seconds, but instead
     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
     *
     * @example
     *
     * Wait for 1 second:
     *
     * ```
     * await frame.waitForTimeout(1000);
     * ```
     *
     * @param milliseconds - the number of milliseconds to wait.
     */
    waitForTimeout(milliseconds) {
        return new Promise((resolve) => {
            setTimeout(resolve, milliseconds);
        });
    }
    /**
     * @remarks
     *
     *
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately.
     * If the selector doesn't appear after the `timeout` milliseconds of waiting,
     * the function will throw.
     *
     * This method works across navigations.
     *
     * @example
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page.mainFrame()
     *   .waitForSelector('img')
     *   .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     * @param selector - the selector to wait for.
     * @param options - options to define if the element should be visible and how
     * long to wait before timing out.
     * @returns a promise which resolves when an element matching the selector
     * string is added to the DOM.
     */
    async waitForSelector(selector, options = {}) {
        const handle = await this._secondaryWorld.waitForSelector(selector, options);
        if (!handle)
            return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
    }
    /**
     * @remarks
     * Wait for the `xpath` to appear in page. If at the moment of calling the
     * method the `xpath` already exists, the method will return immediately. If
     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * For a code example, see the example for {@link Frame.waitForSelector}. That
     * function behaves identically other than taking a CSS selector rather than
     * an XPath.
     *
     * @param xpath - the XPath expression to wait for.
     * @param options  - options to configure the visiblity of the element and how
     * long to wait before timing out.
     */
    async waitForXPath(xpath, options = {}) {
        const handle = await this._secondaryWorld.waitForXPath(xpath, options);
        if (!handle)
            return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
    }
    /**
     * @remarks
     *
     * @example
     *
     * The `waitForFunction` can be used to observe viewport size change:
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     * .  const browser = await puppeteer.launch();
     * .  const page = await browser.newPage();
     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
     * .  page.setViewport({width: 50, height: 50});
     * .  await watchDog;
     * .  await browser.close();
     * })();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```js
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector
     *);
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    waitForFunction(pageFunction, options = {}, ...args) {
        return this._mainWorld.waitForFunction(pageFunction, options, ...args);
    }
    /**
     * @returns the frame's title.
     */
    async title() {
        return this._secondaryWorld.title();
    }
    /**
     * @internal
     */
    _navigated(framePayload) {
        this._name = framePayload.name;
        this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;
    }
    /**
     * @internal
     */
    _navigatedWithinDocument(url) {
        this._url = url;
    }
    /**
     * @internal
     */
    _onLifecycleEvent(loaderId, name) {
        if (name === 'init') {
            this._loaderId = loaderId;
            this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
    }
    /**
     * @internal
     */
    _onLoadingStopped() {
        this._lifecycleEvents.add('DOMContentLoaded');
        this._lifecycleEvents.add('load');
    }
    /**
     * @internal
     */
    _detach() {
        this._detached = true;
        this._mainWorld._detach();
        this._secondaryWorld._detach();
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
}
function assertNoLegacyNavigationOptions(options) {
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(options.waitUntil !== 'networkidle', 'ERROR: "networkidle" option is no longer supported. Use "networkidle2" instead');
}
//# sourceMappingURL=FrameManager.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPRequest.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPRequest.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTTPRequest": () => (/* binding */ HTTPRequest)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");


/**
 *
 * Represents an HTTP request sent by a page.
 * @remarks
 *
 * Whenever the page sends a request, such as for a network resource, the
 * following events are emitted by Puppeteer's `page`:
 *
 * - `request`:  emitted when the request is issued by the page.
 * - `requestfinished` - emitted when the response body is downloaded and the
 *   request is complete.
 *
 * If request fails at some point, then instead of `requestfinished` event the
 * `requestfailed` event is emitted.
 *
 * All of these events provide an instance of `HTTPRequest` representing the
 * request that occurred:
 *
 * ```
 * page.on('request', request => ...)
 * ```
 *
 * NOTE: HTTP Error responses, such as 404 or 503, are still successful
 * responses from HTTP standpoint, so request will complete with
 * `requestfinished` event.
 *
 * If request gets a 'redirect' response, the request is successfully finished
 * with the `requestfinished` event, and a new request is issued to a
 * redirected url.
 *
 * @public
 */
class HTTPRequest {
    /**
     * @internal
     */
    constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
        /**
         * @internal
         */
        this._failureText = null;
        /**
         * @internal
         */
        this._response = null;
        /**
         * @internal
         */
        this._fromMemoryCache = false;
        this._interceptionHandled = false;
        this._headers = {};
        this._client = client;
        this._requestId = event.requestId;
        this._isNavigationRequest =
            event.requestId === event.loaderId && event.type === 'Document';
        this._interceptionId = interceptionId;
        this._allowInterception = allowInterception;
        this._url = event.request.url;
        this._resourceType = event.type.toLowerCase();
        this._method = event.request.method;
        this._postData = event.request.postData;
        this._frame = frame;
        this._redirectChain = redirectChain;
        for (const key of Object.keys(event.request.headers))
            this._headers[key.toLowerCase()] = event.request.headers[key];
    }
    /**
     * @returns the URL of the request
     */
    url() {
        return this._url;
    }
    /**
     * Contains the request's resource type as it was perceived by the rendering
     * engine.
     */
    resourceType() {
        return this._resourceType;
    }
    /**
     * @returns the method used (`GET`, `POST`, etc.)
     */
    method() {
        return this._method;
    }
    /**
     * @returns the request's post body, if any.
     */
    postData() {
        return this._postData;
    }
    /**
     * @returns an object with HTTP headers associated with the request. All
     * header names are lower-case.
     */
    headers() {
        return this._headers;
    }
    /**
     * @returns A matching `HTTPResponse` object, or null if the response has not
     * been received yet.
     */
    response() {
        return this._response;
    }
    /**
     * @returns the frame that initiated the request, or null if navigating to
     * error pages.
     */
    frame() {
        return this._frame;
    }
    /**
     * @returns true if the request is the driver of the current frame's navigation.
     */
    isNavigationRequest() {
        return this._isNavigationRequest;
    }
    /**
     * A `redirectChain` is a chain of requests initiated to fetch a resource.
     * @remarks
     *
     * `redirectChain` is shared between all the requests of the same chain.
     *
     * For example, if the website `http://example.com` has a single redirect to
     * `https://example.com`, then the chain will contain one request:
     *
     * ```js
     * const response = await page.goto('http://example.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 1
     * console.log(chain[0].url()); // 'http://example.com'
     * ```
     *
     * If the website `https://google.com` has no redirects, then the chain will be empty:
     *
     * ```js
     * const response = await page.goto('https://google.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 0
     * ```
     *
     * @returns the chain of requests - if a server responds with at least a
     * single redirect, this chain will contain all requests that were redirected.
     */
    redirectChain() {
        return this._redirectChain.slice();
    }
    /**
     * Access information about the request's failure.
     *
     * @remarks
     *
     * @example
     *
     * Example of logging all failed requests:
     *
     * ```js
     * page.on('requestfailed', request => {
     *   console.log(request.url() + ' ' + request.failure().errorText);
     * });
     * ```
     *
     * @returns `null` unless the request failed. If the request fails this can
     * return an object with `errorText` containing a human-readable error
     * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be
     * failure text if the request fails.
     */
    failure() {
        if (!this._failureText)
            return null;
        return {
            errorText: this._failureText,
        };
    }
    /**
     * Continues request with optional request overrides.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     *
     * @example
     * ```js
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   // Override headers
     *   const headers = Object.assign({}, request.headers(), {
     *     foo: 'bar', // set "foo" header
     *     origin: undefined, // remove "origin" header
     *   });
     *   request.continue({headers});
     * });
     * ```
     *
     * @param overrides - optional overrides to apply to the request.
     */
    async continue(overrides = {}) {
        // Request interception is not supported for data: urls.
        if (this._url.startsWith('data:'))
            return;
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._allowInterception, 'Request Interception is not enabled!');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._interceptionHandled, 'Request is already handled!');
        const { url, method, postData, headers } = overrides;
        this._interceptionHandled = true;
        const postDataBinaryBase64 = postData
            ? Buffer.from(postData).toString('base64')
            : undefined;
        await this._client
            .send('Fetch.continueRequest', {
            requestId: this._interceptionId,
            url,
            method,
            postData: postDataBinaryBase64,
            headers: headers ? headersArray(headers) : undefined,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        });
    }
    /**
     * Fulfills a request with the given response.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     *
     * @example
     * An example of fulfilling all requests with 404 responses:
     * ```js
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   request.respond({
     *     status: 404,
     *     contentType: 'text/plain',
     *     body: 'Not Found!'
     *   });
     * });
     * ```
     *
     * NOTE: Mocking responses for dataURL requests is not supported.
     * Calling `request.respond` for a dataURL request is a noop.
     *
     * @param response - the response to fulfill the request with.
     */
    async respond(response) {
        // Mocking responses for dataURL requests is not currently supported.
        if (this._url.startsWith('data:'))
            return;
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._allowInterception, 'Request Interception is not enabled!');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        const responseBody = response.body && _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isString(response.body)
            ? Buffer.from(response.body)
            : response.body || null;
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = String(response.headers[header]);
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));
        await this._client
            .send('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: response.status || 200,
            responsePhrase: STATUS_TEXTS[response.status || 200],
            responseHeaders: headersArray(responseHeaders),
            body: responseBody ? responseBody.toString('base64') : undefined,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        });
    }
    /**
     * Aborts a request.
     *
     * @remarks
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}. If it is not enabled, this method will
     * throw an exception immediately.
     *
     * @param errorCode - optional error code to provide.
     */
    async abort(errorCode = 'failed') {
        // Request interception is not supported for data: urls.
        if (this._url.startsWith('data:'))
            return;
        const errorReason = errorReasons[errorCode];
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(errorReason, 'Unknown error code: ' + errorCode);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(this._allowInterception, 'Request Interception is not enabled!');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        await this._client
            .send('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason,
        })
            .catch((error) => {
            // In certain cases, protocol will return error if the request was
            // already canceled or the page was closed. We should tolerate these
            // errors.
            (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error);
        });
    }
}
const errorReasons = {
    aborted: 'Aborted',
    accessdenied: 'AccessDenied',
    addressunreachable: 'AddressUnreachable',
    blockedbyclient: 'BlockedByClient',
    blockedbyresponse: 'BlockedByResponse',
    connectionaborted: 'ConnectionAborted',
    connectionclosed: 'ConnectionClosed',
    connectionfailed: 'ConnectionFailed',
    connectionrefused: 'ConnectionRefused',
    connectionreset: 'ConnectionReset',
    internetdisconnected: 'InternetDisconnected',
    namenotresolved: 'NameNotResolved',
    timedout: 'TimedOut',
    failed: 'Failed',
};
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        if (!Object.is(headers[name], undefined))
            result.push({ name, value: headers[name] + '' });
    }
    return result;
}
// List taken from
// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
// with extra 306 and 418 codes.
const STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};
//# sourceMappingURL=HTTPRequest.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPResponse.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPResponse.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTTPResponse": () => (/* binding */ HTTPResponse)
/* harmony export */ });
/* harmony import */ var _SecurityDetails_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SecurityDetails.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js");

/**
 * The HTTPResponse class represents responses which are received by the
 * {@link Page} class.
 *
 * @public
 */
class HTTPResponse {
    /**
     * @internal
     */
    constructor(client, request, responsePayload) {
        this._contentPromise = null;
        this._headers = {};
        this._client = client;
        this._request = request;
        this._bodyLoadedPromise = new Promise((fulfill) => {
            this._bodyLoadedPromiseFulfill = fulfill;
        });
        this._remoteAddress = {
            ip: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort,
        };
        this._status = responsePayload.status;
        this._statusText = responsePayload.statusText;
        this._url = request.url();
        this._fromDiskCache = !!responsePayload.fromDiskCache;
        this._fromServiceWorker = !!responsePayload.fromServiceWorker;
        for (const key of Object.keys(responsePayload.headers))
            this._headers[key.toLowerCase()] = responsePayload.headers[key];
        this._securityDetails = responsePayload.securityDetails
            ? new _SecurityDetails_js__WEBPACK_IMPORTED_MODULE_0__.SecurityDetails(responsePayload.securityDetails)
            : null;
    }
    /**
     * @internal
     */
    _resolveBody(err) {
        return this._bodyLoadedPromiseFulfill(err);
    }
    /**
     * @returns The IP address and port number used to connect to the remote
     * server.
     */
    remoteAddress() {
        return this._remoteAddress;
    }
    /**
     * @returns The URL of the response.
     */
    url() {
        return this._url;
    }
    /**
     * @returns True if the response was successful (status in the range 200-299).
     */
    ok() {
        // TODO: document === 0 case?
        return this._status === 0 || (this._status >= 200 && this._status <= 299);
    }
    /**
     * @returns The status code of the response (e.g., 200 for a success).
     */
    status() {
        return this._status;
    }
    /**
     * @returns  The status text of the response (e.g. usually an "OK" for a
     * success).
     */
    statusText() {
        return this._statusText;
    }
    /**
     * @returns An object with HTTP headers associated with the response. All
     * header names are lower-case.
     */
    headers() {
        return this._headers;
    }
    /**
     * @returns {@link SecurityDetails} if the response was received over the
     * secure connection, or `null` otherwise.
     */
    securityDetails() {
        return this._securityDetails;
    }
    /**
     * @returns Promise which resolves to a buffer with response body.
     */
    buffer() {
        if (!this._contentPromise) {
            this._contentPromise = this._bodyLoadedPromise.then(async (error) => {
                if (error)
                    throw error;
                const response = await this._client.send('Network.getResponseBody', {
                    requestId: this._request._requestId,
                });
                return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
            });
        }
        return this._contentPromise;
    }
    /**
     * @returns Promise which resolves to a text representation of response body.
     */
    async text() {
        const content = await this.buffer();
        return content.toString('utf8');
    }
    /**
     *
     * @returns Promise which resolves to a JSON representation of response body.
     *
     * @remarks
     *
     * This method will throw if the response body is not parsable via
     * `JSON.parse`.
     */
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    /**
     * @returns A matching {@link HTTPRequest} object.
     */
    request() {
        return this._request;
    }
    /**
     * @returns True if the response was served from either the browser's disk
     * cache or memory cache.
     */
    fromCache() {
        return this._fromDiskCache || this._request._fromMemoryCache;
    }
    /**
     * @returns True if the response was served by a service worker.
     */
    fromServiceWorker() {
        return this._fromServiceWorker;
    }
    /**
     * @returns A {@link Frame} that initiated this response, or `null` if
     * navigating to error pages.
     */
    frame() {
        return this._request.frame();
    }
}
//# sourceMappingURL=HTTPResponse.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Input.js":
/*!***********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Input.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Keyboard": () => (/* binding */ Keyboard),
/* harmony export */   "Mouse": () => (/* binding */ Mouse),
/* harmony export */   "Touchscreen": () => (/* binding */ Touchscreen)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _USKeyboardLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./USKeyboardLayout.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Keyboard provides an api for managing a virtual keyboard.
 * The high level api is {@link Keyboard."type"},
 * which takes raw characters and generates proper keydown, keypress/input,
 * and keyup events on your page.
 *
 * @remarks
 * For finer control, you can use {@link Keyboard.down},
 * {@link Keyboard.up}, and {@link Keyboard.sendCharacter}
 * to manually fire events as if they were generated from a real keyboard.
 *
 * On MacOS, keyboard shortcuts like `⌘ A` -\> Select All do not work.
 * See {@link https://github.com/puppeteer/puppeteer/issues/1313 | #1313}.
 *
 * @example
 * An example of holding down `Shift` in order to select and delete some text:
 * ```js
 * await page.keyboard.type('Hello World!');
 * await page.keyboard.press('ArrowLeft');
 *
 * await page.keyboard.down('Shift');
 * for (let i = 0; i < ' World'.length; i++)
 *   await page.keyboard.press('ArrowLeft');
 * await page.keyboard.up('Shift');
 *
 * await page.keyboard.press('Backspace');
 * // Result text will end up saying 'Hello!'
 * ```
 *
 * @example
 * An example of pressing `A`
 * ```js
 * await page.keyboard.down('Shift');
 * await page.keyboard.press('KeyA');
 * await page.keyboard.up('Shift');
 * ```
 *
 * @public
 */
class Keyboard {
    /** @internal */
    constructor(client) {
        /** @internal */
        this._modifiers = 0;
        this._pressedKeys = new Set();
        this._client = client;
    }
    /**
     * Dispatches a `keydown` event.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also generated.
     * The `text` option can be specified to force an input event to be generated.
     * If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`,
     * subsequent key presses will be sent with that modifier active.
     * To release the modifier key, use {@link Keyboard.up}.
     *
     * After the key is pressed once, subsequent calls to
     * {@link Keyboard.down} will have
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat | repeat}
     * set to true. To release the key, use {@link Keyboard.up}.
     *
     * Modifier keys DO influence {@link Keyboard.down}.
     * Holding down `Shift` will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     *
     * @param options - An object of options. Accepts text which, if specified,
     * generates an input event with this text.
     */
    async down(key, options = { text: undefined }) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        this._modifiers |= this._modifierBit(description.key);
        const text = options.text === undefined ? description.text : options.text;
        await this._client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: this._modifiers,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            key: description.key,
            text: text,
            unmodifiedText: text,
            autoRepeat,
            location: description.location,
            isKeypad: description.location === 3,
        });
    }
    _modifierBit(key) {
        if (key === 'Alt')
            return 1;
        if (key === 'Control')
            return 2;
        if (key === 'Meta')
            return 4;
        if (key === 'Shift')
            return 8;
        return 0;
    }
    _keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
            key: '',
            keyCode: 0,
            code: '',
            text: '',
            location: 0,
        };
        const definition = _USKeyboardLayout_js__WEBPACK_IMPORTED_MODULE_1__.keyDefinitions[keyString];
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(definition, `Unknown key: "${keyString}"`);
        if (definition.key)
            description.key = definition.key;
        if (shift && definition.shiftKey)
            description.key = definition.shiftKey;
        if (definition.keyCode)
            description.keyCode = definition.keyCode;
        if (shift && definition.shiftKeyCode)
            description.keyCode = definition.shiftKeyCode;
        if (definition.code)
            description.code = definition.code;
        if (definition.location)
            description.location = definition.location;
        if (description.key.length === 1)
            description.text = description.key;
        if (definition.text)
            description.text = definition.text;
        if (shift && definition.shiftText)
            description.text = definition.shiftText;
        // if any modifiers besides shift are pressed, no text should be sent
        if (this._modifiers & ~8)
            description.text = '';
        return description;
    }
    /**
     * Dispatches a `keyup` event.
     *
     * @param key - Name of key to release, such as `ArrowLeft`.
     * See {@link KeyInput | KeyInput}
     * for a list of all key names.
     */
    async up(key) {
        const description = this._keyDescriptionForString(key);
        this._modifiers &= ~this._modifierBit(description.key);
        this._pressedKeys.delete(description.code);
        await this._client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: this._modifiers,
            key: description.key,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            location: description.location,
        });
    }
    /**
     * Dispatches a `keypress` and `input` event.
     * This does not send a `keydown` or `keyup` event.
     *
     * @remarks
     * Modifier keys DO NOT effect {@link Keyboard.sendCharacter | Keyboard.sendCharacter}.
     * Holding down `Shift` will not type the text in upper case.
     *
     * @example
     * ```js
     * page.keyboard.sendCharacter('嗨');
     * ```
     *
     * @param char - Character to send into the page.
     */
    async sendCharacter(char) {
        await this._client.send('Input.insertText', { text: char });
    }
    charIsKey(char) {
        return !!_USKeyboardLayout_js__WEBPACK_IMPORTED_MODULE_1__.keyDefinitions[char];
    }
    /**
     * Sends a `keydown`, `keypress`/`input`,
     * and `keyup` event for each character in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link Keyboard.press}.
     *
     * Modifier keys DO NOT effect `keyboard.type`.
     * Holding down `Shift` will not type the text in upper case.
     *
     * @example
     * ```js
     * await page.keyboard.type('Hello'); // Types instantly
     * await page.keyboard.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param text - A text to type into a focused element.
     * @param options - An object of options. Accepts delay which,
     * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
     * Defaults to 0.
     */
    async type(text, options = {}) {
        const delay = options.delay || null;
        for (const char of text) {
            if (this.charIsKey(char)) {
                await this.press(char, { delay });
            }
            else {
                if (delay)
                    await new Promise((f) => setTimeout(f, delay));
                await this.sendCharacter(char);
            }
        }
    }
    /**
     * Shortcut for {@link Keyboard.down}
     * and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * Modifier keys DO effect {@link Keyboard.press}.
     * Holding down `Shift` will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     *
     * @param options - An object of options. Accepts text which, if specified,
     * generates an input event with this text. Accepts delay which,
     * if specified, is the time to wait between `keydown` and `keyup` in milliseconds.
     * Defaults to 0.
     */
    async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay)
            await new Promise((f) => setTimeout(f, options.delay));
        await this.up(key);
    }
}
/**
 * The Mouse class operates in main-frame CSS pixels
 * relative to the top-left corner of the viewport.
 * @remarks
 * Every `page` object has its own Mouse, accessible with [`page.mouse`](#pagemouse).
 *
 * @example
 * ```js
 * // Using ‘page.mouse’ to trace a 100x100 square.
 * await page.mouse.move(0, 0);
 * await page.mouse.down();
 * await page.mouse.move(0, 100);
 * await page.mouse.move(100, 100);
 * await page.mouse.move(100, 0);
 * await page.mouse.move(0, 0);
 * await page.mouse.up();
 * ```
 *
 * **Note**: The mouse events trigger synthetic `MouseEvent`s.
 * This means that it does not fully replicate the functionality of what a normal user
 * would be able to do with their mouse.
 *
 * For example, dragging and selecting text is not possible using `page.mouse`.
 * Instead, you can use the {@link https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/getSelection | `DocumentOrShadowRoot.getSelection()`} functionality implemented in the platform.
 *
 * @example
 * For example, if you want to select all content between nodes:
 * ```js
 * await page.evaluate((from, to) => {
 *   const selection = from.getRootNode().getSelection();
 *   const range = document.createRange();
 *   range.setStartBefore(from);
 *   range.setEndAfter(to);
 *   selection.removeAllRanges();
 *   selection.addRange(range);
 * }, fromJSHandle, toJSHandle);
 * ```
 * If you then would want to copy-paste your selection, you can use the clipboard api:
 * ```js
 * // The clipboard api does not allow you to copy, unless the tab is focused.
 * await page.bringToFront();
 * await page.evaluate(() => {
 *   // Copy the selected content to the clipboard
 *   document.execCommand('copy');
 *   // Obtain the content of the clipboard as a string
 *   return navigator.clipboard.readText();
 * });
 * ```
 * **Note**: If you want access to the clipboard API,
 * you have to give it permission to do so:
 * ```js
 * await browser.defaultBrowserContext().overridePermissions(
 *   '<your origin>', ['clipboard-read', 'clipboard-write']
 * );
 * ```
 * @public
 */
class Mouse {
    /**
     * @internal
     */
    constructor(client, keyboard) {
        this._x = 0;
        this._y = 0;
        this._button = 'none';
        this._client = client;
        this._keyboard = keyboard;
    }
    /**
     * Dispatches a `mousemove` event.
     * @param x - Horizontal position of the mouse.
     * @param y - Vertical position of the mouse.
     * @param options - Optional object. If specified, the `steps` property
     * sends intermediate `mousemove` events when set to `1` (default).
     */
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const fromX = this._x, fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
            await this._client.send('Input.dispatchMouseEvent', {
                type: 'mouseMoved',
                button: this._button,
                x: fromX + (this._x - fromX) * (i / steps),
                y: fromY + (this._y - fromY) * (i / steps),
                modifiers: this._keyboard._modifiers,
            });
        }
    }
    /**
     * Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.
     * @param x - Horizontal position of the mouse.
     * @param y - Vertical position of the mouse.
     * @param options - Optional `MouseOptions`.
     */
    async click(x, y, options = {}) {
        const { delay = null } = options;
        if (delay !== null) {
            await this.move(x, y);
            await this.down(options);
            await new Promise((f) => setTimeout(f, delay));
            await this.up(options);
        }
        else {
            await this.move(x, y);
            await this.down(options);
            await this.up(options);
        }
    }
    /**
     * Dispatches a `mousedown` event.
     * @param options - Optional `MouseOptions`.
     */
    async down(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._button = button;
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mousePressed',
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount,
        });
    }
    /**
     * Dispatches a `mouseup` event.
     * @param options - Optional `MouseOptions`.
     */
    async up(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._button = 'none';
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseReleased',
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount,
        });
    }
    /**
     * Dispatches a `mousewheel` event.
     * @param options - Optional: `MouseWheelOptions`.
     *
     * @example
     * An example of zooming into an element:
     * ```js
     * await page.goto('https://mdn.mozillademos.org/en-US/docs/Web/API/Element/wheel_event$samples/Scaling_an_element_via_the_wheel?revision=1587366');
     *
     * const elem = await page.$('div');
     * const boundingBox = await elem.boundingBox();
     * await page.mouse.move(
     *   boundingBox.x + boundingBox.width / 2,
     *   boundingBox.y + boundingBox.height / 2
     * );
     *
     * await page.mouse.wheel({ deltaY: -100 })
     * ```
     */
    async wheel(options = {}) {
        const { deltaX = 0, deltaY = 0 } = options;
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseWheel',
            x: this._x,
            y: this._y,
            deltaX,
            deltaY,
            modifiers: this._keyboard._modifiers,
            pointerType: 'mouse',
        });
    }
}
/**
 * The Touchscreen class exposes touchscreen events.
 * @public
 */
class Touchscreen {
    /**
     * @internal
     */
    constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
    }
    /**
     * Dispatches a `touchstart` and `touchend` event.
     * @param x - Horizontal position of the tap.
     * @param y - Vertical position of the tap.
     */
    async tap(x, y) {
        const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
        await this._client.send('Input.dispatchTouchEvent', {
            type: 'touchStart',
            touchPoints,
            modifiers: this._keyboard._modifiers,
        });
        await this._client.send('Input.dispatchTouchEvent', {
            type: 'touchEnd',
            touchPoints: [],
            modifiers: this._keyboard._modifiers,
        });
    }
}
//# sourceMappingURL=Input.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createJSHandle": () => (/* binding */ createJSHandle),
/* harmony export */   "JSHandle": () => (/* binding */ JSHandle),
/* harmony export */   "ElementHandle": () => (/* binding */ ElementHandle)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @internal
 */
function createJSHandle(context, remoteObject) {
    const frame = context.frame();
    if (remoteObject.subtype === 'node' && frame) {
        const frameManager = frame._frameManager;
        return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);
    }
    return new JSHandle(context, context._client, remoteObject);
}
/**
 * Represents an in-page JavaScript object. JSHandles can be created with the
 * {@link Page.evaluateHandle | page.evaluateHandle} method.
 *
 * @example
 * ```js
 * const windowHandle = await page.evaluateHandle(() => window);
 * ```
 *
 * JSHandle prevents the referenced JavaScript object from being garbage-collected
 * unless the handle is {@link JSHandle.dispose | disposed}. JSHandles are auto-
 * disposed when their origin frame gets navigated or the parent context gets destroyed.
 *
 * JSHandle instances can be used as arguments for {@link Page.$eval},
 * {@link Page.evaluate}, and {@link Page.evaluateHandle}.
 *
 * @public
 */
class JSHandle {
    /**
     * @internal
     */
    constructor(context, client, remoteObject) {
        /**
         * @internal
         */
        this._disposed = false;
        this._context = context;
        this._client = client;
        this._remoteObject = remoteObject;
    }
    /** Returns the execution context the handle belongs to.
     */
    executionContext() {
        return this._context;
    }
    /**
     * This method passes this handle as the first argument to `pageFunction`.
     * If `pageFunction` returns a Promise, then `handle.evaluate` would wait
     * for the promise to resolve and return its value.
     *
     * @example
     * ```js
     * const tweetHandle = await page.$('.tweet .retweets');
     * expect(await tweetHandle.evaluate(node => node.innerText)).toBe('10');
     * ```
     */
    async evaluate(pageFunction, ...args) {
        return await this.executionContext().evaluate(pageFunction, this, ...args);
    }
    /**
     * This method passes this handle as the first argument to `pageFunction`.
     *
     * @remarks
     *
     * The only difference between `jsHandle.evaluate` and
     * `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle`
     * returns an in-page object (JSHandle).
     *
     * If the function passed to `jsHandle.evaluateHandle` returns a Promise,
     * then `evaluateHandle.evaluateHandle` waits for the promise to resolve and
     * returns its value.
     *
     * See {@link Page.evaluateHandle} for more details.
     */
    async evaluateHandle(pageFunction, ...args) {
        return await this.executionContext().evaluateHandle(pageFunction, this, ...args);
    }
    /** Fetches a single property from the referenced object.
     */
    async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName) => {
            const result = { __proto__: null };
            result[propertyName] = object[propertyName];
            return result;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName) || null;
        await objectHandle.dispose();
        return result;
    }
    /**
     * The method returns a map with property names as keys and JSHandle
     * instances for the property values.
     *
     * @example
     * ```js
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element)
     *     children.push(element);
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
        const response = await this._client.send('Runtime.getProperties', {
            objectId: this._remoteObject.objectId,
            ownProperties: true,
        });
        const result = new Map();
        for (const property of response.result) {
            if (!property.enumerable)
                continue;
            result.set(property.name, createJSHandle(this._context, property.value));
        }
        return result;
    }
    /**
     * @returns Returns a JSON representation of the object.If the object has a
     * `toJSON` function, it will not be called.
     * @remarks
     *
     * The JSON is generated by running {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify | JSON.stringify}
     * on the object in page and consequent {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse | JSON.parse} in puppeteer.
     * **NOTE** The method throws if the referenced object is not stringifiable.
     */
    async jsonValue() {
        if (this._remoteObject.objectId) {
            const response = await this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: 'function() { return this; }',
                objectId: this._remoteObject.objectId,
                returnByValue: true,
                awaitPromise: true,
            });
            return _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.valueFromRemoteObject(response.result);
        }
        return _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.valueFromRemoteObject(this._remoteObject);
    }
    /**
     * @returns Either `null` or the object handle itself, if the object
     * handle is an instance of {@link ElementHandle}.
     */
    asElement() {
        /*  This always returns null, but subclasses can override this and return an
            ElementHandle.
        */
        return null;
    }
    /**
     * Stops referencing the element handle, and resolves when the object handle is
     * successfully disposed of.
     */
    async dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        await _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.releaseObject(this._client, this._remoteObject);
    }
    /**
     * Returns a string representation of the JSHandle.
     *
     * @remarks Useful during debugging.
     */
    toString() {
        if (this._remoteObject.objectId) {
            const type = this._remoteObject.subtype || this._remoteObject.type;
            return 'JSHandle@' + type;
        }
        return 'JSHandle:' + _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.valueFromRemoteObject(this._remoteObject);
    }
}
/**
 * ElementHandle represents an in-page DOM element.
 *
 * @remarks
 *
 * ElementHandles can be created with the {@link Page.$} method.
 *
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *  const browser = await puppeteer.launch();
 *  const page = await browser.newPage();
 *  await page.goto('https://example.com');
 *  const hrefElement = await page.$('a');
 *  await hrefElement.click();
 *  // ...
 * })();
 * ```
 *
 * ElementHandle prevents the DOM element from being garbage-collected unless the
 * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed
 * when their origin frame gets navigated.
 *
 * ElementHandle instances can be used as arguments in {@link Page.$eval} and
 * {@link Page.evaluate} methods.
 *
 * If you're using TypeScript, ElementHandle takes a generic argument that
 * denotes the type of element the handle is holding within. For example, if you
 * have a handle to a `<select>` element, you can type it as
 * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.
 *
 * @public
 */
class ElementHandle extends JSHandle {
    /**
     * @internal
     */
    constructor(context, client, remoteObject, page, frameManager) {
        super(context, client, remoteObject);
        this._client = client;
        this._remoteObject = remoteObject;
        this._page = page;
        this._frameManager = frameManager;
    }
    asElement() {
        return this;
    }
    /**
     * Resolves to the content frame for element handles referencing
     * iframe nodes, or null otherwise
     */
    async contentFrame() {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: this._remoteObject.objectId,
        });
        if (typeof nodeInfo.node.frameId !== 'string')
            return null;
        return this._frameManager.frame(nodeInfo.node.frameId);
    }
    async _scrollIntoViewIfNeeded() {
        const error = await this.evaluate(async (element, pageJavascriptEnabled) => {
            if (!element.isConnected)
                return 'Node is detached from document';
            if (element.nodeType !== Node.ELEMENT_NODE)
                return 'Node is not of type HTMLElement';
            // force-scroll if page's javascript is disabled.
            if (!pageJavascriptEnabled) {
                element.scrollIntoView({
                    block: 'center',
                    inline: 'center',
                    // @ts-expect-error Chrome still supports behavior: instant but
                    // it's not in the spec so TS shouts We don't want to make this
                    // breaking change in Puppeteer yet so we'll ignore the line.
                    behavior: 'instant',
                });
                return false;
            }
            const visibleRatio = await new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
            });
            if (visibleRatio !== 1.0) {
                element.scrollIntoView({
                    block: 'center',
                    inline: 'center',
                    // @ts-expect-error Chrome still supports behavior: instant but
                    // it's not in the spec so TS shouts We don't want to make this
                    // breaking change in Puppeteer yet so we'll ignore the line.
                    behavior: 'instant',
                });
            }
            return false;
        }, this._page.isJavaScriptEnabled());
        if (error)
            throw new Error(error);
    }
    async _clickablePoint() {
        const [result, layoutMetrics] = await Promise.all([
            this._client
                .send('DOM.getContentQuads', {
                objectId: this._remoteObject.objectId,
            })
                .catch(_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError),
            this._client.send('Page.getLayoutMetrics'),
        ]);
        if (!result || !result.quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Filter out quads that have too small area to click into.
        const { clientWidth, clientHeight } = layoutMetrics.layoutViewport;
        const quads = result.quads
            .map((quad) => this._fromProtocolQuad(quad))
            .map((quad) => this._intersectQuadWithViewport(quad, clientWidth, clientHeight))
            .filter((quad) => computeQuadArea(quad) > 1);
        if (!quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Return the middle point of the first quad.
        const quad = quads[0];
        let x = 0;
        let y = 0;
        for (const point of quad) {
            x += point.x;
            y += point.y;
        }
        return {
            x: x / 4,
            y: y / 4,
        };
    }
    _getBoxModel() {
        const params = {
            objectId: this._remoteObject.objectId,
        };
        return this._client
            .send('DOM.getBoxModel', params)
            .catch((error) => (0,_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError)(error));
    }
    _fromProtocolQuad(quad) {
        return [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] },
        ];
    }
    _intersectQuadWithViewport(quad, width, height) {
        return quad.map((point) => ({
            x: Math.min(Math.max(point.x, 0), width),
            y: Math.min(Math.max(point.y, 0), height),
        }));
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.move(x, y);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(options = {}) {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.click(x, y, options);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     * ```js
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     * @param values - Values of options to select. If the `<select>` has the
     *    `multiple` attribute, all values are considered, otherwise only the first
     *    one is taken into account.
     */
    async select(...values) {
        for (const value of values)
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(_helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.isString(value), 'Values must be strings. Found value "' +
                value +
                '" of type "' +
                typeof value +
                '"');
        return this.evaluate((element, values) => {
            if (!(element instanceof HTMLSelectElement))
                throw new Error('Element is not a <select> element.');
            const options = Array.from(element.options);
            element.value = undefined;
            for (const option of options) {
                option.selected = values.includes(option.value);
                if (option.selected && !element.multiple)
                    break;
            }
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            return options
                .filter((option) => option.selected)
                .map((option) => option.value);
        }, values);
    }
    /**
     * This method expects `elementHandle` to point to an
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}.
     * @param filePaths - Sets the value of the file input to these paths.
     *    If some of the  `filePaths` are relative paths, then they are resolved
     *    relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}
     */
    async uploadFile(...filePaths) {
        const isMultiple = await this.evaluate((element) => {
            if (!(element instanceof HTMLInputElement)) {
                throw new Error('uploadFile can only be called on an input element.');
            }
            return element.multiple;
        });
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.isNode) {
            throw new Error(`JSHandle#uploadFile can only be used in Node environments.`);
        }
        /*
         This import is only needed for `uploadFile`, so keep it scoped here to
         avoid paying the cost unnecessarily.
        */
        const path = await __webpack_require__.e(/*! import() */ "vendors-node_modules_path-browserify_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! path */ "./node_modules/path-browserify/index.js", 23));
        const fs = await _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.importFSModule();
        // Locate all files and confirm that they exist.
        const files = await Promise.all(filePaths.map(async (filePath) => {
            const resolvedPath = path.resolve(filePath);
            try {
                await fs.promises.access(resolvedPath, fs.constants.R_OK);
            }
            catch (error) {
                if (error.code === 'ENOENT')
                    throw new Error(`${filePath} does not exist or is not readable`);
            }
            return resolvedPath;
        }));
        const { objectId } = this._remoteObject;
        const { node } = await this._client.send('DOM.describeNode', { objectId });
        const { backendNodeId } = node;
        /*  The zero-length array is a special case, it seems that
            DOM.setFileInputFiles does not actually update the files in that case,
            so the solution is to eval the element value to a new FileList directly.
        */
        if (files.length === 0) {
            await this.evaluate((element) => {
                element.files = new DataTransfer().files;
                // Dispatch events for this case because it should behave akin to a user action.
                element.dispatchEvent(new Event('input', { bubbles: true }));
                element.dispatchEvent(new Event('change', { bubbles: true }));
            });
        }
        else {
            await this._client.send('DOM.setFileInputFiles', {
                objectId,
                files,
                backendNodeId,
            });
        }
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.touchscreen.tap(x, y);
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
        await this.evaluate((element) => element.focus());
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     * ```js
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```js
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     */
    async type(text, options) {
        await this.focus();
        await this._page.keyboard.type(text, options);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     *    See {@link KeyInput} for a list of all key names.
     */
    async press(key, options) {
        await this.focus();
        await this._page.keyboard.press(key, options);
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is not visible.
     */
    async boundingBox() {
        const result = await this._getBoxModel();
        if (!result)
            return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x, y, width, height };
    }
    /**
     * This method returns boxes of the element, or `null` if the element is not visible.
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
        const result = await this._getBoxModel();
        if (!result)
            return null;
        const { content, padding, border, margin, width, height } = result.model;
        return {
            content: this._fromProtocolQuad(content),
            padding: this._fromProtocolQuad(padding),
            border: this._fromProtocolQuad(border),
            margin: this._fromProtocolQuad(margin),
            width,
            height,
        };
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Page.screenshot} to take a screenshot of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async screenshot(options = {}) {
        let needsViewportReset = false;
        let boundingBox = await this.boundingBox();
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');
        const viewport = this._page.viewport();
        if (viewport &&
            (boundingBox.width > viewport.width ||
                boundingBox.height > viewport.height)) {
            const newViewport = {
                width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
                height: Math.max(viewport.height, Math.ceil(boundingBox.height)),
            };
            await this._page.setViewport(Object.assign({}, viewport, newViewport));
            needsViewportReset = true;
        }
        await this._scrollIntoViewIfNeeded();
        boundingBox = await this.boundingBox();
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boundingBox.width !== 0, 'Node has 0 width.');
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(boundingBox.height !== 0, 'Node has 0 height.');
        const { layoutViewport: { pageX, pageY }, } = await this._client.send('Page.getLayoutMetrics');
        const clip = Object.assign({}, boundingBox);
        clip.x += pageX;
        clip.y += pageY;
        const imageData = await this._page.screenshot(Object.assign({}, {
            clip,
        }, options));
        if (needsViewportReset)
            await this._page.setViewport(viewport);
        return imageData;
    }
    /**
     * Runs `element.querySelector` within the page. If no element matches the selector,
     * the return value resolves to `null`.
     */
    async $(selector) {
        const { updatedSelector, queryHandler } = (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.getQueryHandlerAndSelector)(selector);
        return queryHandler.queryOne(this, updatedSelector);
    }
    /**
     * Runs `element.querySelectorAll` within the page. If no elements match the selector,
     * the return value resolves to `[]`.
     */
    async $$(selector) {
        const { updatedSelector, queryHandler } = (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.getQueryHandlerAndSelector)(selector);
        return queryHandler.queryAll(this, updatedSelector);
    }
    /**
     * This method runs `document.querySelector` within the element and passes it as
     * the first argument to `pageFunction`. If there's no element matching `selector`,
     * the method throws an error.
     *
     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise
     * to resolve and return its value.
     *
     * @example
     * ```js
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');
     * ```
     */
    async $eval(selector, pageFunction, ...args) {
        const elementHandle = await this.$(selector);
        if (!elementHandle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await elementHandle.evaluate(pageFunction, ...args);
        await elementHandle.dispose();
        /**
         * This `as` is a little unfortunate but helps TS understand the behavior of
         * `elementHandle.evaluate`. If evaluate returns an element it will return an
         * ElementHandle instance, rather than the plain object. All the
         * WrapElementHandle type does is wrap ReturnType into
         * ElementHandle<ReturnType> if it is an ElementHandle, or leave it alone as
         * ReturnType if it isn't.
         */
        return result;
    }
    /**
     * This method runs `document.querySelectorAll` within the element and passes it as
     * the first argument to `pageFunction`. If there's no element matching `selector`,
     * the method throws an error.
     *
     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the
     * promise to resolve and return its value.
     *
     * @example
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * @example
     * ```js
     * const feedHandle = await page.$('.feed');
     * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)))
     *  .toEqual(['Hello!', 'Hi!']);
     * ```
     */
    async $$eval(selector, pageFunction, ...args) {
        const { updatedSelector, queryHandler } = (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.getQueryHandlerAndSelector)(selector);
        const arrayHandle = await queryHandler.queryAllArray(this, updatedSelector);
        const result = await arrayHandle.evaluate(pageFunction, ...args);
        await arrayHandle.dispose();
        /* This `as` exists for the same reason as the `as` in $eval above.
         * See the comment there for a full explanation.
         */
        return result;
    }
    /**
     * The method evaluates the XPath expression relative to the elementHandle.
     * If there are no such elements, the method will resolve to an empty array.
     * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}
     */
    async $x(expression) {
        const arrayHandle = await this.evaluateHandle((element, expression) => {
            const document = element.ownerDocument || element;
            const iterator = document.evaluate(expression, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
            const array = [];
            let item;
            while ((item = iterator.iterateNext()))
                array.push(item);
            return array;
        }, expression);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
        }
        return result;
    }
    /**
     * Resolves to true if the element is visible in the current viewport.
     */
    async isIntersectingViewport() {
        return await this.evaluate(async (element) => {
            const visibleRatio = await new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
            });
            return visibleRatio > 0;
        });
    }
}
function computeQuadArea(quad) {
    /* Compute sum of all directed areas of adjacent triangles
      https://en.wikipedia.org/wiki/Polygon#Simple_polygons
    */
    let area = 0;
    for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
    }
    return Math.abs(area);
}
//# sourceMappingURL=JSHandle.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/LifecycleWatcher.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/LifecycleWatcher.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LifecycleWatcher": () => (/* binding */ LifecycleWatcher)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _FrameManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FrameManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameManager.js");
/* harmony import */ var _NetworkManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NetworkManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js");
/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const puppeteerToProtocolLifecycle = new Map([
    ['load', 'load'],
    ['domcontentloaded', 'DOMContentLoaded'],
    ['networkidle0', 'networkIdle'],
    ['networkidle2', 'networkAlmostIdle'],
]);
/**
 * @internal
 */
class LifecycleWatcher {
    constructor(frameManager, frame, waitUntil, timeout) {
        if (Array.isArray(waitUntil))
            waitUntil = waitUntil.slice();
        else if (typeof waitUntil === 'string')
            waitUntil = [waitUntil];
        this._expectedLifecycle = waitUntil.map((value) => {
            const protocolEvent = puppeteerToProtocolLifecycle.get(value);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(protocolEvent, 'Unknown value for options.waitUntil: ' + value);
            return protocolEvent;
        });
        this._frameManager = frameManager;
        this._frame = frame;
        this._initialLoaderId = frame._loaderId;
        this._timeout = timeout;
        this._navigationRequest = null;
        this._eventListeners = [
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(frameManager._client, _Connection_js__WEBPACK_IMPORTED_MODULE_5__.CDPSessionEmittedEvents.Disconnected, () => this._terminate(new Error('Navigation failed because browser has disconnected!'))),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._frameManager, _FrameManager_js__WEBPACK_IMPORTED_MODULE_3__.FrameManagerEmittedEvents.LifecycleEvent, this._checkLifecycleComplete.bind(this)),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._frameManager, _FrameManager_js__WEBPACK_IMPORTED_MODULE_3__.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, this._navigatedWithinDocument.bind(this)),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._frameManager, _FrameManager_js__WEBPACK_IMPORTED_MODULE_3__.FrameManagerEmittedEvents.FrameDetached, this._onFrameDetached.bind(this)),
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.addEventListener(this._frameManager.networkManager(), _NetworkManager_js__WEBPACK_IMPORTED_MODULE_4__.NetworkManagerEmittedEvents.Request, this._onRequest.bind(this)),
        ];
        this._sameDocumentNavigationPromise = new Promise((fulfill) => {
            this._sameDocumentNavigationCompleteCallback = fulfill;
        });
        this._lifecyclePromise = new Promise((fulfill) => {
            this._lifecycleCallback = fulfill;
        });
        this._newDocumentNavigationPromise = new Promise((fulfill) => {
            this._newDocumentNavigationCompleteCallback = fulfill;
        });
        this._timeoutPromise = this._createTimeoutPromise();
        this._terminationPromise = new Promise((fulfill) => {
            this._terminationCallback = fulfill;
        });
        this._checkLifecycleComplete();
    }
    _onRequest(request) {
        if (request.frame() !== this._frame || !request.isNavigationRequest())
            return;
        this._navigationRequest = request;
    }
    _onFrameDetached(frame) {
        if (this._frame === frame) {
            this._terminationCallback.call(null, new Error('Navigating frame was detached'));
            return;
        }
        this._checkLifecycleComplete();
    }
    navigationResponse() {
        return this._navigationRequest ? this._navigationRequest.response() : null;
    }
    _terminate(error) {
        this._terminationCallback.call(null, error);
    }
    sameDocumentNavigationPromise() {
        return this._sameDocumentNavigationPromise;
    }
    newDocumentNavigationPromise() {
        return this._newDocumentNavigationPromise;
    }
    lifecyclePromise() {
        return this._lifecyclePromise;
    }
    timeoutOrTerminationPromise() {
        return Promise.race([this._timeoutPromise, this._terminationPromise]);
    }
    _createTimeoutPromise() {
        if (!this._timeout)
            return new Promise(() => { });
        const errorMessage = 'Navigation timeout of ' + this._timeout + ' ms exceeded';
        return new Promise((fulfill) => (this._maximumTimer = setTimeout(fulfill, this._timeout))).then(() => new _Errors_js__WEBPACK_IMPORTED_MODULE_2__.TimeoutError(errorMessage));
    }
    _navigatedWithinDocument(frame) {
        if (frame !== this._frame)
            return;
        this._hasSameDocumentNavigation = true;
        this._checkLifecycleComplete();
    }
    _checkLifecycleComplete() {
        // We expect navigation to commit.
        if (!checkLifecycle(this._frame, this._expectedLifecycle))
            return;
        this._lifecycleCallback();
        if (this._frame._loaderId === this._initialLoaderId &&
            !this._hasSameDocumentNavigation)
            return;
        if (this._hasSameDocumentNavigation)
            this._sameDocumentNavigationCompleteCallback();
        if (this._frame._loaderId !== this._initialLoaderId)
            this._newDocumentNavigationCompleteCallback();
        /**
         * @param {!Frame} frame
         * @param {!Array<string>} expectedLifecycle
         * @returns {boolean}
         */
        function checkLifecycle(frame, expectedLifecycle) {
            for (const event of expectedLifecycle) {
                if (!frame._lifecycleEvents.has(event))
                    return false;
            }
            for (const child of frame.childFrames()) {
                if (!checkLifecycle(child, expectedLifecycle))
                    return false;
            }
            return true;
        }
    }
    dispose() {
        _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.removeEventListeners(this._eventListeners);
        clearTimeout(this._maximumTimer);
    }
}
//# sourceMappingURL=LifecycleWatcher.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkConditions.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkConditions.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "networkConditions": () => (/* binding */ networkConditions)
/* harmony export */ });
/**
 * Copyright 2021 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @public
 */
const networkConditions = {
    'Slow 3G': {
        download: ((500 * 1000) / 8) * 0.8,
        upload: ((500 * 1000) / 8) * 0.8,
        latency: 400 * 5,
    },
    'Fast 3G': {
        download: ((1.6 * 1000 * 1000) / 8) * 0.9,
        upload: ((750 * 1000) / 8) * 0.9,
        latency: 150 * 3.75,
    },
};
//# sourceMappingURL=NetworkConditions.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NetworkManagerEmittedEvents": () => (/* binding */ NetworkManagerEmittedEvents),
/* harmony export */   "NetworkManager": () => (/* binding */ NetworkManager)
/* harmony export */ });
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPRequest.js");
/* harmony import */ var _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPResponse.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * We use symbols to prevent any external parties listening to these events.
 * They are internal to Puppeteer.
 *
 * @internal
 */
const NetworkManagerEmittedEvents = {
    Request: Symbol('NetworkManager.Request'),
    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),
    Response: Symbol('NetworkManager.Response'),
    RequestFailed: Symbol('NetworkManager.RequestFailed'),
    RequestFinished: Symbol('NetworkManager.RequestFinished'),
};
/**
 * @internal
 */
class NetworkManager extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    constructor(client, ignoreHTTPSErrors, frameManager) {
        super();
        /*
         * There are four possible orders of events:
         *  A. `_onRequestWillBeSent`
         *  B. `_onRequestWillBeSent`, `_onRequestPaused`
         *  C. `_onRequestPaused`, `_onRequestWillBeSent`
         *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`
         *     (see crbug.com/1196004)
         *
         * For `_onRequest` we need the event from `_onRequestWillBeSent` and
         * optionally the `interceptionId` from `_onRequestPaused`.
         *
         * If request interception is disabled, call `_onRequest` once per call to
         * `_onRequestWillBeSent`.
         * If request interception is enabled, call `_onRequest` once per call to
         * `_onRequestPaused` (once per `interceptionId`).
         *
         * Events are stored to allow for subsequent events to call `_onRequest`.
         *
         * Note that (chains of) redirect requests have the same `requestId` (!) as
         * the original request. We have to anticipate series of events like these:
         *  A. `_onRequestWillBeSent`,
         *     `_onRequestWillBeSent`, ...
         *  B. `_onRequestWillBeSent`, `_onRequestPaused`,
         *     `_onRequestWillBeSent`, `_onRequestPaused`, ...
         *  C. `_onRequestWillBeSent`, `_onRequestPaused`,
         *     `_onRequestPaused`, `_onRequestWillBeSent`, ...
         *  D. `_onRequestPaused`, `_onRequestWillBeSent`,
         *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...
         *     (see crbug.com/1196004)
         */
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._requestIdToRequestPausedEvent = new Map();
        this._requestIdToRequest = new Map();
        this._extraHTTPHeaders = {};
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._userCacheDisabled = false;
        this._emulatedNetworkConditions = {
            offline: false,
            upload: -1,
            download: -1,
            latency: 0,
        };
        this._client = client;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._frameManager = frameManager;
        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));
        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));
        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));
        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));
        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));
        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));
        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));
    }
    async initialize() {
        await this._client.send('Network.enable');
        if (this._ignoreHTTPSErrors)
            await this._client.send('Security.setIgnoreCertificateErrors', {
                ignore: true,
            });
    }
    async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
    }
    async setExtraHTTPHeaders(extraHTTPHeaders) {
        this._extraHTTPHeaders = {};
        for (const key of Object.keys(extraHTTPHeaders)) {
            const value = extraHTTPHeaders[key];
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(_helper_js__WEBPACK_IMPORTED_MODULE_2__.helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            this._extraHTTPHeaders[key.toLowerCase()] = value;
        }
        await this._client.send('Network.setExtraHTTPHeaders', {
            headers: this._extraHTTPHeaders,
        });
    }
    extraHTTPHeaders() {
        return Object.assign({}, this._extraHTTPHeaders);
    }
    async setOfflineMode(value) {
        this._emulatedNetworkConditions.offline = value;
        await this._updateNetworkConditions();
    }
    async emulateNetworkConditions(networkConditions) {
        this._emulatedNetworkConditions.upload = networkConditions
            ? networkConditions.upload
            : -1;
        this._emulatedNetworkConditions.download = networkConditions
            ? networkConditions.download
            : -1;
        this._emulatedNetworkConditions.latency = networkConditions
            ? networkConditions.latency
            : 0;
        await this._updateNetworkConditions();
    }
    async _updateNetworkConditions() {
        await this._client.send('Network.emulateNetworkConditions', {
            offline: this._emulatedNetworkConditions.offline,
            latency: this._emulatedNetworkConditions.latency,
            uploadThroughput: this._emulatedNetworkConditions.upload,
            downloadThroughput: this._emulatedNetworkConditions.download,
        });
    }
    async setUserAgent(userAgent) {
        await this._client.send('Network.setUserAgentOverride', { userAgent });
    }
    async setCacheEnabled(enabled) {
        this._userCacheDisabled = !enabled;
        await this._updateProtocolCacheDisabled();
    }
    async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
    }
    async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
            return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.enable', {
                    handleAuthRequests: true,
                    patterns: [{ urlPattern: '*' }],
                }),
            ]);
        }
        else {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.disable'),
            ]);
        }
    }
    _cacheDisabled() {
        return this._userCacheDisabled;
    }
    async _updateProtocolCacheDisabled() {
        await this._client.send('Network.setCacheDisabled', {
            cacheDisabled: this._cacheDisabled(),
        });
    }
    _onRequestWillBeSent(event) {
        // Request interception doesn't happen for data URLs with Network Service.
        if (this._userRequestInterceptionEnabled &&
            !event.request.url.startsWith('data:')) {
            const requestId = event.requestId;
            const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
            this._requestIdToRequestWillBeSentEvent.set(requestId, event);
            if (requestPausedEvent) {
                const interceptionId = requestPausedEvent.requestId;
                this._onRequest(event, interceptionId);
                this._requestIdToRequestPausedEvent.delete(requestId);
            }
            return;
        }
        this._onRequest(event, null);
    }
    _onAuthRequired(event) {
        let response = 'Default';
        if (this._attemptedAuthentications.has(event.requestId)) {
            response = 'CancelAuth';
        }
        else if (this._credentials) {
            response = 'ProvideCredentials';
            this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || {
            username: undefined,
            password: undefined,
        };
        this._client
            .send('Fetch.continueWithAuth', {
            requestId: event.requestId,
            authChallengeResponse: { response, username, password },
        })
            .catch(_helper_js__WEBPACK_IMPORTED_MODULE_2__.debugError);
    }
    _onRequestPaused(event) {
        if (!this._userRequestInterceptionEnabled &&
            this._protocolRequestInterceptionEnabled) {
            this._client
                .send('Fetch.continueRequest', {
                requestId: event.requestId,
            })
                .catch(_helper_js__WEBPACK_IMPORTED_MODULE_2__.debugError);
        }
        const requestId = event.networkId;
        const interceptionId = event.requestId;
        if (!requestId) {
            return;
        }
        let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        // redirect requests have the same `requestId`,
        if (requestWillBeSentEvent &&
            (requestWillBeSentEvent.request.url !== event.request.url ||
                requestWillBeSentEvent.request.method !== event.request.method)) {
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
            requestWillBeSentEvent = null;
        }
        if (requestWillBeSentEvent) {
            this._onRequest(requestWillBeSentEvent, interceptionId);
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
        }
        else {
            this._requestIdToRequestPausedEvent.set(requestId, event);
        }
    }
    _onRequest(event, interceptionId) {
        let redirectChain = [];
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the
            // requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse);
                redirectChain = request._redirectChain;
            }
        }
        const frame = event.frameId
            ? this._frameManager.frame(event.frameId)
            : null;
        const request = new _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_3__.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);
        this._requestIdToRequest.set(event.requestId, request);
        this.emit(NetworkManagerEmittedEvents.Request, request);
    }
    _onRequestServedFromCache(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
            request._fromMemoryCache = true;
        this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);
    }
    _handleRequestRedirect(request, responsePayload) {
        const response = new _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_4__.HTTPResponse(this._client, request, responsePayload);
        request._response = response;
        request._redirectChain.push(request);
        response._resolveBody(new Error('Response body is unavailable for redirect responses'));
        this._forgetRequest(request, false);
        this.emit(NetworkManagerEmittedEvents.Response, response);
        this.emit(NetworkManagerEmittedEvents.RequestFinished, request);
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = new _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_4__.HTTPResponse(this._client, request, event.response);
        request._response = response;
        this.emit(NetworkManagerEmittedEvents.Response, response);
    }
    _forgetRequest(request, events) {
        const requestId = request._requestId;
        const interceptionId = request._interceptionId;
        this._requestIdToRequest.delete(requestId);
        this._attemptedAuthentications.delete(interceptionId);
        if (events) {
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
            this._requestIdToRequestPausedEvent.delete(requestId);
        }
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        if (request.response())
            request.response()._resolveBody(null);
        this._forgetRequest(request, true);
        this.emit(NetworkManagerEmittedEvents.RequestFinished, request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        request._failureText = event.errorText;
        const response = request.response();
        if (response)
            response._resolveBody(null);
        this._forgetRequest(request, true);
        this.emit(NetworkManagerEmittedEvents.RequestFailed, request);
    }
}
//# sourceMappingURL=NetworkManager.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "paperFormats": () => (/* binding */ paperFormats)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const paperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 },
};
//# sourceMappingURL=PDFOptions.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Page.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Page.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Page": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js");
/* harmony import */ var _Dialog_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dialog.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Dialog.js");
/* harmony import */ var _EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EmulationManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EmulationManager.js");
/* harmony import */ var _FrameManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FrameManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameManager.js");
/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Input.js");
/* harmony import */ var _Tracing_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Tracing.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Tracing.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _Coverage_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Coverage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Coverage.js");
/* harmony import */ var _WebWorker_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/WebWorker.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js");
/* harmony import */ var _NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./NetworkManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js");
/* harmony import */ var _Accessibility_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Accessibility.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Accessibility.js");
/* harmony import */ var _TimeoutSettings_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TimeoutSettings.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js");
/* harmony import */ var _FileChooser_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./FileChooser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js");
/* harmony import */ var _ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ConsoleMessage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js");
/* harmony import */ var _PDFOptions_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./PDFOptions.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















class ScreenshotTaskQueue {
    constructor() {
        this._chain = Promise.resolve(undefined);
    }
    postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => { });
        return result;
    }
}
/**
 * Page provides methods to interact with a single tab or
 * {@link https://developer.chrome.com/extensions/background_pages | extension background page} in Chromium.
 *
 * @remarks
 *
 * One Browser instance might have multiple Page instances.
 *
 * @example
 * This example creates a page, navigates it to a URL, and then * saves a screenshot:
 * ```js
 * const puppeteer = require('puppeteer');
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await page.screenshot({path: 'screenshot.png'});
 *   await browser.close();
 * })();
 * ```
 *
 * The Page class extends from Puppeteer's {@link EventEmitter} class and will
 * emit various events which are documented in the {@link PageEmittedEvents} enum.
 *
 * @example
 * This example logs a message for a single page `load` event:
 * ```js
 * page.once('load', () => console.log('Page loaded!'));
 * ```
 *
 * To unsubscribe from events use the `off` method:
 *
 * ```js
 * function logRequest(interceptedRequest) {
 *   console.log('A request was made:', interceptedRequest.url());
 * }
 * page.on('request', logRequest);
 * // Sometime later...
 * page.off('request', logRequest);
 * ```
 * @public
 */
class Page extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     * @internal
     */
    constructor(client, target, ignoreHTTPSErrors) {
        super();
        this._closed = false;
        this._timeoutSettings = new _TimeoutSettings_js__WEBPACK_IMPORTED_MODULE_14__.TimeoutSettings();
        this._pageBindings = new Map();
        this._javascriptEnabled = true;
        this._workers = new Map();
        // TODO: improve this typedef - it's a function that takes a file chooser or
        // something?
        this._fileChooserInterceptors = new Set();
        this._client = client;
        this._target = target;
        this._keyboard = new _Input_js__WEBPACK_IMPORTED_MODULE_5__.Keyboard(client);
        this._mouse = new _Input_js__WEBPACK_IMPORTED_MODULE_5__.Mouse(client, this._keyboard);
        this._touchscreen = new _Input_js__WEBPACK_IMPORTED_MODULE_5__.Touchscreen(client, this._keyboard);
        this._accessibility = new _Accessibility_js__WEBPACK_IMPORTED_MODULE_13__.Accessibility(client);
        this._frameManager = new _FrameManager_js__WEBPACK_IMPORTED_MODULE_4__.FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
        this._emulationManager = new _EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__.EmulationManager(client);
        this._tracing = new _Tracing_js__WEBPACK_IMPORTED_MODULE_6__.Tracing(client);
        this._coverage = new _Coverage_js__WEBPACK_IMPORTED_MODULE_9__.Coverage(client);
        this._screenshotTaskQueue = new ScreenshotTaskQueue();
        this._viewport = null;
        client.on('Target.attachedToTarget', (event) => {
            if (event.targetInfo.type !== 'worker' &&
                event.targetInfo.type !== 'iframe') {
                // If we don't detach from service workers, they will never die.
                // We still want to attach to workers for emitting events.
                // We still want to attach to iframes so sessions may interact with them.
                // We detach from all other types out of an abundance of caution.
                // See https://source.chromium.org/chromium/chromium/src/+/master:content/browser/devtools/devtools_agent_host_impl.cc?q=f:devtools%20-f:out%20%22::kTypePage%5B%5D%22&ss=chromium
                // for the complete list of available types.
                client
                    .send('Target.detachFromTarget', {
                    sessionId: event.sessionId,
                })
                    .catch(_helper_js__WEBPACK_IMPORTED_MODULE_8__.debugError);
                return;
            }
            const session = _Connection_js__WEBPACK_IMPORTED_MODULE_1__.Connection.fromSession(client).session(event.sessionId);
            const worker = new _WebWorker_js__WEBPACK_IMPORTED_MODULE_10__.WebWorker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));
            this._workers.set(event.sessionId, worker);
            this.emit("workercreated" /* WorkerCreated */, worker);
        });
        client.on('Target.detachedFromTarget', (event) => {
            const worker = this._workers.get(event.sessionId);
            if (!worker)
                return;
            this._workers.delete(event.sessionId);
            this.emit("workerdestroyed" /* WorkerDestroyed */, worker);
        });
        this._frameManager.on(_FrameManager_js__WEBPACK_IMPORTED_MODULE_4__.FrameManagerEmittedEvents.FrameAttached, (event) => this.emit("frameattached" /* FrameAttached */, event));
        this._frameManager.on(_FrameManager_js__WEBPACK_IMPORTED_MODULE_4__.FrameManagerEmittedEvents.FrameDetached, (event) => this.emit("framedetached" /* FrameDetached */, event));
        this._frameManager.on(_FrameManager_js__WEBPACK_IMPORTED_MODULE_4__.FrameManagerEmittedEvents.FrameNavigated, (event) => this.emit("framenavigated" /* FrameNavigated */, event));
        const networkManager = this._frameManager.networkManager();
        networkManager.on(_NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.Request, (event) => this.emit("request" /* Request */, event));
        networkManager.on(_NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.RequestServedFromCache, (event) => this.emit("requestservedfromcache" /* RequestServedFromCache */, event));
        networkManager.on(_NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.Response, (event) => this.emit("response" /* Response */, event));
        networkManager.on(_NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.RequestFailed, (event) => this.emit("requestfailed" /* RequestFailed */, event));
        networkManager.on(_NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.RequestFinished, (event) => this.emit("requestfinished" /* RequestFinished */, event));
        this._fileChooserInterceptors = new Set();
        client.on('Page.domContentEventFired', () => this.emit("domcontentloaded" /* DOMContentLoaded */));
        client.on('Page.loadEventFired', () => this.emit("load" /* Load */));
        client.on('Runtime.consoleAPICalled', (event) => this._onConsoleAPI(event));
        client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));
        client.on('Page.javascriptDialogOpening', (event) => this._onDialog(event));
        client.on('Runtime.exceptionThrown', (exception) => this._handleException(exception.exceptionDetails));
        client.on('Inspector.targetCrashed', () => this._onTargetCrashed());
        client.on('Performance.metrics', (event) => this._emitMetrics(event));
        client.on('Log.entryAdded', (event) => this._onLogEntryAdded(event));
        client.on('Page.fileChooserOpened', (event) => this._onFileChooser(event));
        this._target._isClosedPromise.then(() => {
            this.emit("close" /* Close */);
            this._closed = true;
        });
    }
    /**
     * @internal
     */
    static async create(client, target, ignoreHTTPSErrors, defaultViewport) {
        const page = new Page(client, target, ignoreHTTPSErrors);
        await page._initialize();
        if (defaultViewport)
            await page.setViewport(defaultViewport);
        return page;
    }
    async _initialize() {
        await Promise.all([
            this._frameManager.initialize(),
            this._client.send('Target.setAutoAttach', {
                autoAttach: true,
                waitForDebuggerOnStart: false,
                flatten: true,
            }),
            this._client.send('Performance.enable'),
            this._client.send('Log.enable'),
        ]);
    }
    async _onFileChooser(event) {
        if (!this._fileChooserInterceptors.size)
            return;
        const frame = this._frameManager.frame(event.frameId);
        const context = await frame.executionContext();
        const element = await context._adoptBackendNodeId(event.backendNodeId);
        const interceptors = Array.from(this._fileChooserInterceptors);
        this._fileChooserInterceptors.clear();
        const fileChooser = new _FileChooser_js__WEBPACK_IMPORTED_MODULE_15__.FileChooser(element, event);
        for (const interceptor of interceptors)
            interceptor.call(null, fileChooser);
    }
    /**
     * @returns `true` if the page has JavaScript enabled, `false` otherwise.
     */
    isJavaScriptEnabled() {
        return this._javascriptEnabled;
    }
    /**
     * Listen to page events.
     */
    on(eventName, handler) {
        // Note: this method only exists to define the types; we delegate the impl
        // to EventEmitter.
        return super.on(eventName, handler);
    }
    once(eventName, handler) {
        // Note: this method only exists to define the types; we delegate the impl
        // to EventEmitter.
        return super.once(eventName, handler);
    }
    /**
     * @param options - Optional waiting parameters
     * @returns Resolves after a page requests a file picker.
     */
    async waitForFileChooser(options = {}) {
        if (!this._fileChooserInterceptors.size)
            await this._client.send('Page.setInterceptFileChooserDialog', {
                enabled: true,
            });
        const { timeout = this._timeoutSettings.timeout() } = options;
        let callback;
        const promise = new Promise((x) => (callback = x));
        this._fileChooserInterceptors.add(callback);
        return _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.waitWithTimeout(promise, 'waiting for file chooser', timeout)
            .catch((error) => {
            this._fileChooserInterceptors.delete(callback);
            throw error;
        });
    }
    /**
     * Sets the page's geolocation.
     *
     * @remarks
     * Consider using {@link BrowserContext.overridePermissions} to grant
     * permissions for the page to read its geolocation.
     *
     * @example
     * ```js
     * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});
     * ```
     */
    async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180)
            throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        if (latitude < -90 || latitude > 90)
            throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        if (accuracy < 0)
            throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        await this._client.send('Emulation.setGeolocationOverride', {
            longitude,
            latitude,
            accuracy,
        });
    }
    /**
     * @returns A target this page was created from.
     */
    target() {
        return this._target;
    }
    /**
     * @returns The browser this page belongs to.
     */
    browser() {
        return this._target.browser();
    }
    /**
     * @returns The browser context that the page belongs to
     */
    browserContext() {
        return this._target.browserContext();
    }
    _onTargetCrashed() {
        this.emit('error', new Error('Page crashed!'));
    }
    _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
            args.map((arg) => _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.releaseObject(this._client, arg));
        if (source !== 'worker')
            this.emit("console" /* Console */, new _ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_16__.ConsoleMessage(level, text, [], [{ url, lineNumber }]));
    }
    /**
     * @returns The page's main frame.
     */
    mainFrame() {
        return this._frameManager.mainFrame();
    }
    get keyboard() {
        return this._keyboard;
    }
    get touchscreen() {
        return this._touchscreen;
    }
    get coverage() {
        return this._coverage;
    }
    get tracing() {
        return this._tracing;
    }
    get accessibility() {
        return this._accessibility;
    }
    /**
     * @returns An array of all frames attached to the page.
     */
    frames() {
        return this._frameManager.frames();
    }
    /**
     * @returns all of the dedicated
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorkers}
     * associated with the page.
     */
    workers() {
        return Array.from(this._workers.values());
    }
    /**
     * @param value - Whether to enable request interception.
     *
     * @remarks
     * Activating request interception enables {@link HTTPRequest.abort},
     * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods.  This
     * provides the capability to modify network requests that are made by a page.
     *
     * Once request interception is enabled, every request will stall unless it's
     * continued, responded or aborted; or completed using the browser cache.
     *
     * @example
     * An example of a naïve request interceptor that aborts all image requests:
     * ```js
     * const puppeteer = require('puppeteer');
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.setRequestInterception(true);
     *   page.on('request', interceptedRequest => {
     *     if (interceptedRequest.url().endsWith('.png') ||
     *         interceptedRequest.url().endsWith('.jpg'))
     *       interceptedRequest.abort();
     *     else
     *       interceptedRequest.continue();
     *     });
     *   await page.goto('https://example.com');
     *   await browser.close();
     * })();
     * ```
     */
    async setRequestInterception(value) {
        return this._frameManager.networkManager().setRequestInterception(value);
    }
    /**
     * @param enabled - When `true`, enables offline mode for the page.
     */
    setOfflineMode(enabled) {
        return this._frameManager.networkManager().setOfflineMode(enabled);
    }
    emulateNetworkConditions(networkConditions) {
        return this._frameManager
            .networkManager()
            .emulateNetworkConditions(networkConditions);
    }
    /**
     * @param timeout - Maximum navigation time in milliseconds.
     */
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    /**
     * @param timeout - Maximum time in milliseconds.
     */
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    /**
     * Runs `document.querySelector` within the page. If no element matches the
     * selector, the return value resolves to `null`.
     *
     * @remarks
     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
     *
     * @param selector - A `selector` to query page for
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query page for.
     */
    async $(selector) {
        return this.mainFrame().$(selector);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluteHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     * ```
     * const aHandle = await page.evaluateHandle('document')
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     * ```
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     * ```
     * const button = await page.evaluateHandle(() => document.querySelector('button'));
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     *  a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
        const context = await this.mainFrame().executionContext();
        return context.evaluateHandle(pageFunction, ...args);
    }
    /**
     * This method iterates the JavaScript heap and finds all objects with the
     * given prototype.
     *
     * @remarks
     *
     * @example
     *
     * ```js
     * // Create a Map object
     * await page.evaluate(() => window.map = new Map());
     * // Get a handle to the Map object prototype
     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
     * // Query all map instances into an array
     * const mapInstances = await page.queryObjects(mapPrototype);
     * // Count amount of map objects in heap
     * const count = await page.evaluate(maps => maps.length, mapInstances);
     * await mapInstances.dispose();
     * await mapPrototype.dispose();
     * ```
     * @param prototypeHandle - a handle to the object prototype.
     */
    async queryObjects(prototypeHandle) {
        const context = await this.mainFrame().executionContext();
        return context.queryObjects(prototypeHandle);
    }
    /**
     * This method runs `document.querySelector` within the page and passes the
     * result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval('#search', (el: HTMLInputElement) => el.value);
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *  '#search', (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of `document.querySelector(selector)` as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(selector, pageFunction, ...args) {
        return this.mainFrame().$eval(selector, pageFunction, ...args);
    }
    /**
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the page and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent)
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * await page.$$eval('input', (elements: HTMLInputElement[]) => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const allInputValues = await page.$$eval<string[]>(
     *  'input', (elements: HTMLInputElement[]) => elements.map(e => e.textContent)
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context. Will
     * be passed the result of `Array.from(document.querySelectorAll(selector))`
     * as its first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(selector, pageFunction, ...args) {
        return this.mainFrame().$$eval(selector, pageFunction, ...args);
    }
    async $$(selector) {
        return this.mainFrame().$$(selector);
    }
    async $x(expression) {
        return this.mainFrame().$x(expression);
    }
    /**
     * If no URLs are specified, this method returns cookies for the current page
     * URL. If URLs are specified, only cookies for those URLs are returned.
     */
    async cookies(...urls) {
        const originalCookies = (await this._client.send('Network.getCookies', {
            urls: urls.length ? urls : [this.url()],
        })).cookies;
        const unsupportedCookieAttributes = ['priority'];
        const filterUnsupportedAttributes = (cookie) => {
            for (const attr of unsupportedCookieAttributes)
                delete cookie[attr];
            return cookie;
        };
        return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
            const item = Object.assign({}, cookie);
            if (!cookie.url && pageURL.startsWith('http'))
                item.url = pageURL;
            await this._client.send('Network.deleteCookies', item);
        }
    }
    async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith('http');
        const items = cookies.map((cookie) => {
            const item = Object.assign({}, cookie);
            if (!item.url && startsWithHTTP)
                item.url = pageURL;
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(item.url !== 'about:blank', `Blank page can not have cookie "${item.name}"`);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie "${item.name}"`);
            return item;
        });
        await this.deleteCookie(...items);
        if (items.length)
            await this._client.send('Network.setCookies', { cookies: items });
    }
    async addScriptTag(options) {
        return this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
        return this.mainFrame().addStyleTag(options);
    }
    async exposeFunction(name, puppeteerFunction) {
        if (this._pageBindings.has(name))
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        this._pageBindings.set(name, puppeteerFunction);
        const expression = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.pageBindingInitString('exposedFun', name);
        await this._client.send('Runtime.addBinding', { name: name });
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: expression,
        });
        await Promise.all(this.frames().map((frame) => frame.evaluate(expression).catch(_helper_js__WEBPACK_IMPORTED_MODULE_8__.debugError)));
    }
    async authenticate(credentials) {
        return this._frameManager.networkManager().authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
        return this._frameManager.networkManager().setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent) {
        return this._frameManager.networkManager().setUserAgent(userAgent);
    }
    async metrics() {
        const response = await this._client.send('Performance.getMetrics');
        return this._buildMetricsObject(response.metrics);
    }
    _emitMetrics(event) {
        this.emit("metrics" /* Metrics */, {
            title: event.title,
            metrics: this._buildMetricsObject(event.metrics),
        });
    }
    _buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
            if (supportedMetrics.has(metric.name))
                result[metric.name] = metric.value;
        }
        return result;
    }
    _handleException(exceptionDetails) {
        const message = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.getExceptionMessage(exceptionDetails);
        const err = new Error(message);
        err.stack = ''; // Don't report clientside error with a node stack attached
        this.emit("pageerror" /* PageError */, err);
    }
    async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Puppeteer clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/puppeteer/puppeteer/issues/3865
            return;
        }
        const context = this._frameManager.executionContextById(event.executionContextId);
        const values = event.args.map((arg) => (0,_JSHandle_js__WEBPACK_IMPORTED_MODULE_11__.createJSHandle)(context, arg));
        this._addConsoleMessage(event.type, values, event.stackTrace);
    }
    async _onBindingCalled(event) {
        let payload;
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            // The binding was either called by something in the page or it was
            // called before our wrapper was initialized.
            return;
        }
        const { type, name, seq, args } = payload;
        if (type !== 'exposedFun' || !this._pageBindings.has(name))
            return;
        let expression = null;
        try {
            const result = await this._pageBindings.get(name)(...args);
            expression = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.pageBindingDeliverResultString(name, seq, result);
        }
        catch (error) {
            if (error instanceof Error)
                expression = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.pageBindingDeliverErrorString(name, seq, error.message, error.stack);
            else
                expression = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.pageBindingDeliverErrorValueString(name, seq, error);
        }
        this._client
            .send('Runtime.evaluate', {
            expression,
            contextId: event.executionContextId,
        })
            .catch(_helper_js__WEBPACK_IMPORTED_MODULE_8__.debugError);
    }
    _addConsoleMessage(type, args, stackTrace) {
        if (!this.listenerCount("console" /* Console */)) {
            args.forEach((arg) => arg.dispose());
            return;
        }
        const textTokens = [];
        for (const arg of args) {
            const remoteObject = arg._remoteObject;
            if (remoteObject.objectId)
                textTokens.push(arg.toString());
            else
                textTokens.push(_helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.valueFromRemoteObject(remoteObject));
        }
        const stackTraceLocations = [];
        if (stackTrace) {
            for (const callFrame of stackTrace.callFrames) {
                stackTraceLocations.push({
                    url: callFrame.url,
                    lineNumber: callFrame.lineNumber,
                    columnNumber: callFrame.columnNumber,
                });
            }
        }
        const message = new _ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_16__.ConsoleMessage(type, textTokens.join(' '), args, stackTraceLocations);
        this.emit("console" /* Console */, message);
    }
    _onDialog(event) {
        let dialogType = null;
        const validDialogTypes = new Set([
            'alert',
            'confirm',
            'prompt',
            'beforeunload',
        ]);
        if (validDialogTypes.has(event.type)) {
            dialogType = event.type;
        }
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(dialogType, 'Unknown javascript dialog type: ' + event.type);
        const dialog = new _Dialog_js__WEBPACK_IMPORTED_MODULE_2__.Dialog(this._client, dialogType, event.message, event.defaultPrompt);
        this.emit("dialog" /* Dialog */, dialog);
    }
    /**
     * Resets default white background
     */
    async _resetDefaultBackgroundColor() {
        await this._client.send('Emulation.setDefaultBackgroundColorOverride');
    }
    /**
     * Hides default white background
     */
    async _setTransparentBackgroundColor() {
        await this._client.send('Emulation.setDefaultBackgroundColorOverride', {
            color: { r: 0, g: 0, b: 0, a: 0 },
        });
    }
    url() {
        return this.mainFrame().url();
    }
    async content() {
        return await this._frameManager.mainFrame().content();
    }
    async setContent(html, options = {}) {
        await this._frameManager.mainFrame().setContent(html, options);
    }
    async goto(url, options = {}) {
        return await this._frameManager.mainFrame().goto(url, options);
    }
    async reload(options) {
        const result = await Promise.all([
            this.waitForNavigation(options),
            this._client.send('Page.reload'),
        ]);
        return result[0];
    }
    async waitForNavigation(options = {}) {
        return await this._frameManager.mainFrame().waitForNavigation(options);
    }
    _sessionClosePromise() {
        if (!this._disconnectPromise)
            this._disconnectPromise = new Promise((fulfill) => this._client.once(_Connection_js__WEBPACK_IMPORTED_MODULE_1__.CDPSessionEmittedEvents.Disconnected, () => fulfill(new Error('Target closed'))));
        return this._disconnectPromise;
    }
    async waitForRequest(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.waitForEvent(this._frameManager.networkManager(), _NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.Request, (request) => {
            if (_helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.isString(urlOrPredicate))
                return urlOrPredicate === request.url();
            if (typeof urlOrPredicate === 'function')
                return !!urlOrPredicate(request);
            return false;
        }, timeout, this._sessionClosePromise());
    }
    async waitForResponse(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.waitForEvent(this._frameManager.networkManager(), _NetworkManager_js__WEBPACK_IMPORTED_MODULE_12__.NetworkManagerEmittedEvents.Response, async (response) => {
            if (_helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.isString(urlOrPredicate))
                return urlOrPredicate === response.url();
            if (typeof urlOrPredicate === 'function')
                return !!(await urlOrPredicate(response));
            return false;
        }, timeout, this._sessionClosePromise());
    }
    async goBack(options = {}) {
        return this._go(-1, options);
    }
    async goForward(options = {}) {
        return this._go(+1, options);
    }
    async _go(delta, options) {
        const history = await this._client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
            return null;
        const result = await Promise.all([
            this.waitForNavigation(options),
            this._client.send('Page.navigateToHistoryEntry', { entryId: entry.id }),
        ]);
        return result[0];
    }
    async bringToFront() {
        await this._client.send('Page.bringToFront');
    }
    async emulate(options) {
        await Promise.all([
            this.setViewport(options.viewport),
            this.setUserAgent(options.userAgent),
        ]);
    }
    async setJavaScriptEnabled(enabled) {
        if (this._javascriptEnabled === enabled)
            return;
        this._javascriptEnabled = enabled;
        await this._client.send('Emulation.setScriptExecutionDisabled', {
            value: !enabled,
        });
    }
    async setBypassCSP(enabled) {
        await this._client.send('Page.setBypassCSP', { enabled });
    }
    async emulateMediaType(type) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(type === 'screen' || type === 'print' || type === null, 'Unsupported media type: ' + type);
        await this._client.send('Emulation.setEmulatedMedia', {
            media: type || '',
        });
    }
    async emulateMediaFeatures(features) {
        if (features === null)
            await this._client.send('Emulation.setEmulatedMedia', { features: null });
        if (Array.isArray(features)) {
            features.every((mediaFeature) => {
                const name = mediaFeature.name;
                (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), 'Unsupported media feature: ' + name);
                return true;
            });
            await this._client.send('Emulation.setEmulatedMedia', {
                features: features,
            });
        }
    }
    async emulateTimezone(timezoneId) {
        try {
            await this._client.send('Emulation.setTimezoneOverride', {
                timezoneId: timezoneId || '',
            });
        }
        catch (error) {
            if (error.message.includes('Invalid timezone'))
                throw new Error(`Invalid timezone ID: ${timezoneId}`);
            throw error;
        }
    }
    /**
     * Emulates the idle state.
     * If no arguments set, clears idle state emulation.
     *
     * @example
     * ```js
     * // set idle emulation
     * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});
     *
     * // do some checks here
     * ...
     *
     * // clear idle emulation
     * await page.emulateIdleState();
     * ```
     *
     * @param overrides - Mock idle state. If not set, clears idle overrides
     * @param isUserActive - Mock isUserActive
     * @param isScreenUnlocked - Mock isScreenUnlocked
     */
    async emulateIdleState(overrides) {
        if (overrides) {
            await this._client.send('Emulation.setIdleOverride', {
                isUserActive: overrides.isUserActive,
                isScreenUnlocked: overrides.isScreenUnlocked,
            });
        }
        else {
            await this._client.send('Emulation.clearIdleOverride');
        }
    }
    /**
     * Simulates the given vision deficiency on the page.
     *
     * @example
     * ```js
     * const puppeteer = require('puppeteer');
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.goto('https://v8.dev/blog/10-years');
     *
     *   await page.emulateVisionDeficiency('achromatopsia');
     *   await page.screenshot({ path: 'achromatopsia.png' });
     *
     *   await page.emulateVisionDeficiency('deuteranopia');
     *   await page.screenshot({ path: 'deuteranopia.png' });
     *
     *   await page.emulateVisionDeficiency('blurredVision');
     *   await page.screenshot({ path: 'blurred-vision.png' });
     *
     *   await browser.close();
     * })();
     * ```
     *
     * @param type - the type of deficiency to simulate, or `'none'` to reset.
     */
    async emulateVisionDeficiency(type) {
        const visionDeficiencies = new Set([
            'none',
            'achromatopsia',
            'blurredVision',
            'deuteranopia',
            'protanopia',
            'tritanopia',
        ]);
        try {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
            await this._client.send('Emulation.setEmulatedVisionDeficiency', {
                type: type || 'none',
            });
        }
        catch (error) {
            throw error;
        }
    }
    async setViewport(viewport) {
        const needsReload = await this._emulationManager.emulateViewport(viewport);
        this._viewport = viewport;
        if (needsReload)
            await this.reload();
    }
    viewport() {
        return this._viewport;
    }
    /**
     * @remarks
     *
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluteHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```js
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     * ```
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```
     * const aHandle = await page.evaluate<() => number>(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
        return this._frameManager.mainFrame().evaluate(pageFunction, ...args);
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
        const source = _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.evaluationString(pageFunction, ...args);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source,
        });
    }
    async setCacheEnabled(enabled = true) {
        await this._frameManager.networkManager().setCacheEnabled(enabled);
    }
    async screenshot(options = {}) {
        let screenshotType = null;
        // options.type takes precedence over inferring the type from options.path
        // because it may be a 0-length file with no extension created beforehand
        // (i.e. as a temp file).
        if (options.type) {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);
            screenshotType = options.type;
        }
        else if (options.path) {
            const filePath = options.path;
            const extension = filePath
                .slice(filePath.lastIndexOf('.') + 1)
                .toLowerCase();
            if (extension === 'png')
                screenshotType = 'png';
            else if (extension === 'jpg' || extension === 'jpeg')
                screenshotType = 'jpeg';
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(screenshotType, `Unsupported screenshot type for extension \`.${extension}\``);
        }
        if (!screenshotType)
            screenshotType = 'png';
        if (options.quality) {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(screenshotType === 'jpeg', 'options.quality is unsupported for the ' +
                screenshotType +
                ' screenshots');
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' +
                typeof options.quality);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' +
                options.quality);
        }
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');
        if (options.clip) {
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' +
                typeof options.clip.x);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' +
                typeof options.clip.y);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' +
                typeof options.clip.width);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' +
                typeof options.clip.height);
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
        }
        return this._screenshotTaskQueue.postTask(() => this._screenshotTask(screenshotType, options));
    }
    async _screenshotTask(format, options) {
        await this._client.send('Target.activateTarget', {
            targetId: this._target._targetId,
        });
        let clip = options.clip ? processClip(options.clip) : undefined;
        let { captureBeyondViewport = true } = options;
        captureBeyondViewport =
            typeof captureBeyondViewport === 'boolean' ? captureBeyondViewport : true;
        if (options.fullPage) {
            const metrics = await this._client.send('Page.getLayoutMetrics');
            const width = Math.ceil(metrics.contentSize.width);
            const height = Math.ceil(metrics.contentSize.height);
            // Overwrite clip for full page.
            clip = { x: 0, y: 0, width, height, scale: 1 };
            if (!captureBeyondViewport) {
                const { isMobile = false, deviceScaleFactor = 1, isLandscape = false, } = this._viewport || {};
                const screenOrientation = isLandscape
                    ? { angle: 90, type: 'landscapePrimary' }
                    : { angle: 0, type: 'portraitPrimary' };
                await this._client.send('Emulation.setDeviceMetricsOverride', {
                    mobile: isMobile,
                    width,
                    height,
                    deviceScaleFactor,
                    screenOrientation,
                });
            }
        }
        const shouldSetDefaultBackground = options.omitBackground && format === 'png';
        if (shouldSetDefaultBackground) {
            await this._setTransparentBackgroundColor();
        }
        const result = await this._client.send('Page.captureScreenshot', {
            format,
            quality: options.quality,
            clip,
            captureBeyondViewport,
        });
        if (shouldSetDefaultBackground) {
            await this._resetDefaultBackgroundColor();
        }
        if (options.fullPage && this._viewport)
            await this.setViewport(this._viewport);
        const buffer = options.encoding === 'base64'
            ? result.data
            : Buffer.from(result.data, 'base64');
        if (options.path) {
            if (!_environment_js__WEBPACK_IMPORTED_MODULE_18__.isNode) {
                throw new Error('Screenshots can only be written to a file path in a Node environment.');
            }
            const fs = await _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.importFSModule();
            await fs.promises.writeFile(options.path, buffer);
        }
        return buffer;
        function processClip(clip) {
            const x = Math.round(clip.x);
            const y = Math.round(clip.y);
            const width = Math.round(clip.width + clip.x - x);
            const height = Math.round(clip.height + clip.y - y);
            return { x, y, width, height, scale: 1 };
        }
    }
    /**
     * Generatees a PDF of the page with the `print` CSS media type.
     * @remarks
     *
     * IMPORTANT: PDF generation is only supported in Chrome headless mode.
     *
     * To generate a PDF with the `screen` media type, call
     * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before
     * calling `page.pdf()`.
     *
     * By default, `page.pdf()` generates a pdf with modified colors for printing.
     * Use the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}
     * property to force rendering of exact colors.
     *
     *
     * @param options - options for generating the PDF.
     */
    async pdf(options = {}) {
        const { scale = 1, displayHeaderFooter = false, headerTemplate = '', footerTemplate = '', printBackground = false, landscape = false, pageRanges = '', preferCSSPageSize = false, margin = {}, path = null, omitBackground = false, } = options;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options.format) {
            const format = _PDFOptions_js__WEBPACK_IMPORTED_MODULE_17__.paperFormats[options.format.toLowerCase()];
            (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(format, 'Unknown paper format: ' + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
        }
        else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight =
                convertPrintParameterToInches(options.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        if (omitBackground) {
            await this._setTransparentBackgroundColor();
        }
        const result = await this._client.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize,
        });
        if (omitBackground) {
            await this._resetDefaultBackgroundColor();
        }
        return await _helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.readProtocolStream(this._client, result.stream, path);
    }
    async title() {
        return this.mainFrame().title();
    }
    async close(options = { runBeforeUnload: undefined }) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!!this._client._connection, 'Protocol error: Connection closed. Most likely the page has been closed.');
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
            await this._client.send('Page.close');
        }
        else {
            await this._client._connection.send('Target.closeTarget', {
                targetId: this._target._targetId,
            });
            await this._target._isClosedPromise;
        }
    }
    isClosed() {
        return this._closed;
    }
    get mouse() {
        return this._mouse;
    }
    click(selector, options = {}) {
        return this.mainFrame().click(selector, options);
    }
    focus(selector) {
        return this.mainFrame().focus(selector);
    }
    hover(selector) {
        return this.mainFrame().hover(selector);
    }
    select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
    }
    tap(selector) {
        return this.mainFrame().tap(selector);
    }
    type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
    }
    /**
     * @remarks
     *
     * This method behaves differently depending on the first parameter. If it's a
     * `string`, it will be treated as a `selector` or `xpath` (if the string
     * starts with `//`). This method then is a shortcut for
     * {@link Page.waitForSelector} or {@link Page.waitForXPath}.
     *
     * If the first argument is a function this method is a shortcut for
     * {@link Page.waitForFunction}.
     *
     * If the first argument is a `number`, it's treated as a timeout in
     * milliseconds and the method returns a promise which resolves after the
     * timeout.
     *
     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to
     * wait for.
     * @param options - optional waiting parameters.
     * @param args - arguments to pass to `pageFunction`.
     *
     * @deprecated Don't use this method directly. Instead use the more explicit
     * methods available: {@link Page.waitForSelector},
     * {@link Page.waitForXPath}, {@link Page.waitForFunction} or
     * {@link Page.waitForTimeout}.
     */
    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);
    }
    /**
     * Causes your script to wait for the given number of milliseconds.
     *
     * @remarks
     *
     * It's generally recommended to not wait for a number of seconds, but instead
     * use {@link Page.waitForSelector}, {@link Page.waitForXPath} or
     * {@link Page.waitForFunction} to wait for exactly the conditions you want.
     *
     * @example
     *
     * Wait for 1 second:
     *
     * ```
     * await page.waitForTimeout(1000);
     * ```
     *
     * @param milliseconds - the number of milliseconds to wait.
     */
    waitForTimeout(milliseconds) {
        return this.mainFrame().waitForTimeout(milliseconds);
    }
    waitForSelector(selector, options = {}) {
        return this.mainFrame().waitForSelector(selector, options);
    }
    waitForXPath(xpath, options = {}) {
        return this.mainFrame().waitForXPath(xpath, options);
    }
    waitForFunction(pageFunction, options = {}, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
}
const supportedMetrics = new Set([
    'Timestamp',
    'Documents',
    'Frames',
    'JSEventListeners',
    'Nodes',
    'LayoutCount',
    'RecalcStyleCount',
    'LayoutDuration',
    'RecalcStyleDuration',
    'ScriptDuration',
    'TaskDuration',
    'JSHeapUsedSize',
    'JSHeapTotalSize',
]);
const unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78,
};
function convertPrintParameterToInches(parameter) {
    if (typeof parameter === 'undefined')
        return undefined;
    let pixels;
    if (_helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.isNumber(parameter)) {
        // Treat numbers as pixel values to be aligned with phantom's paperSize.
        pixels = /** @type {number} */ parameter;
    }
    else if (_helper_js__WEBPACK_IMPORTED_MODULE_8__.helper.isString(parameter)) {
        const text = /** @type {string} */ parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = '';
        if (unitToPixels.hasOwnProperty(unit)) {
            valueText = text.substring(0, text.length - 2);
        }
        else {
            // In case of unknown unit try to parse the whole parameter as number of pixels.
            // This is consistent with phantom's paperSize behavior.
            unit = 'px';
            valueText = text;
        }
        const value = Number(valueText);
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_7__.assert)(!isNaN(value), 'Failed to parse parameter value: ' + text);
        pixels = value * unitToPixels[unit];
    }
    else {
        throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);
    }
    return pixels / 96;
}
//# sourceMappingURL=Page.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Puppeteer": () => (/* binding */ Puppeteer)
/* harmony export */ });
/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _DeviceDescriptors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeviceDescriptors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/DeviceDescriptors.js");
/* harmony import */ var _QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js");
/* harmony import */ var _BrowserConnector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BrowserConnector.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js");
/* harmony import */ var _NetworkConditions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NetworkConditions.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkConditions.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * The main Puppeteer class.
 *
 * IMPORTANT: if you are using Puppeteer in a Node environment, you will get an
 * instance of {@link PuppeteerNode} when you import or require `puppeteer`.
 * That class extends `Puppeteer`, so has all the methods documented below as
 * well as all that are defined on {@link PuppeteerNode}.
 * @public
 */
class Puppeteer {
    /**
     * @internal
     */
    constructor(settings) {
        this._changedProduct = false;
        this._isPuppeteerCore = settings.isPuppeteerCore;
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
        return (0,_BrowserConnector_js__WEBPACK_IMPORTED_MODULE_3__.connectToBrowser)(options);
    }
    /**
     * @remarks
     * A list of devices to be used with `page.emulate(options)`. Actual list of devices can be found in {@link https://github.com/puppeteer/puppeteer/blob/main/src/common/DeviceDescriptors.ts | src/common/DeviceDescriptors.ts}.
     *
     * @example
     *
     * ```js
     * const puppeteer = require('puppeteer');
     * const iPhone = puppeteer.devices['iPhone 6'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulate(iPhone);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     *
     */
    get devices() {
        return _DeviceDescriptors_js__WEBPACK_IMPORTED_MODULE_1__.devicesMap;
    }
    /**
     * @remarks
     *
     * Puppeteer methods might throw errors if they are unable to fulfill a request.
     * For example, `page.waitForSelector(selector[, options])` might fail if
     * the selector doesn't match any nodes during the given timeframe.
     *
     * For certain types of errors Puppeteer uses specific error classes.
     * These classes are available via `puppeteer.errors`.
     *
     * @example
     * An example of handling a timeout error:
     * ```js
     * try {
     *   await page.waitForSelector('.foo');
     * } catch (e) {
     *   if (e instanceof puppeteer.errors.TimeoutError) {
     *     // Do something if this is a timeout.
     *   }
     * }
     * ```
     */
    get errors() {
        return _Errors_js__WEBPACK_IMPORTED_MODULE_0__.puppeteerErrors;
    }
    /**
     * @remarks
     * Returns a list of network conditions to be used with `page.emulateNetworkConditions(networkConditions)`. Actual list of predefined conditions can be found in {@link https://github.com/puppeteer/puppeteer/blob/main/src/common/NetworkConditions.ts | src/common/NetworkConditions.ts}.
     *
     * @example
     *
     * ```js
     * const puppeteer = require('puppeteer');
     * const slow3G = puppeteer.networkConditions['Slow 3G'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulateNetworkConditions(slow3G);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     *
     */
    get networkConditions() {
        return _NetworkConditions_js__WEBPACK_IMPORTED_MODULE_4__.networkConditions;
    }
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}. After
     * registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is
     * only allowed to consist of lower- and upper case latin letters.
     * @example
     * ```
     * puppeteer.registerCustomQueryHandler('text', { … });
     * const aHandle = await page.$('text/…');
     * ```
     * @param name - The name that the custom query handler will be registered under.
     * @param queryHandler - The {@link CustomQueryHandler | custom query handler} to
     * register.
     */
    registerCustomQueryHandler(name, queryHandler) {
        (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.registerCustomQueryHandler)(name, queryHandler);
    }
    /**
     * @param name - The name of the query handler to unregistered.
     */
    unregisterCustomQueryHandler(name) {
        (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.unregisterCustomQueryHandler)(name);
    }
    /**
     * @returns a list with the names of all registered custom query handlers.
     */
    customQueryHandlerNames() {
        return (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.customQueryHandlerNames)();
    }
    /**
     * Clears all registered handlers.
     */
    clearCustomQueryHandlers() {
        (0,_QueryHandler_js__WEBPACK_IMPORTED_MODULE_2__.clearCustomQueryHandlers)();
    }
}
//# sourceMappingURL=Puppeteer.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerCustomQueryHandler": () => (/* binding */ registerCustomQueryHandler),
/* harmony export */   "unregisterCustomQueryHandler": () => (/* binding */ unregisterCustomQueryHandler),
/* harmony export */   "customQueryHandlerNames": () => (/* binding */ customQueryHandlerNames),
/* harmony export */   "clearCustomQueryHandlers": () => (/* binding */ clearCustomQueryHandlers),
/* harmony export */   "getQueryHandlerAndSelector": () => (/* binding */ getQueryHandlerAndSelector)
/* harmony export */ });
/* harmony import */ var _AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AriaQueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/AriaQueryHandler.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function makeQueryHandler(handler) {
    const internalHandler = {};
    if (handler.queryOne) {
        internalHandler.queryOne = async (element, selector) => {
            const jsHandle = await element.evaluateHandle(handler.queryOne, selector);
            const elementHandle = jsHandle.asElement();
            if (elementHandle)
                return elementHandle;
            await jsHandle.dispose();
            return null;
        };
        internalHandler.waitFor = (domWorld, selector, options) => domWorld.waitForSelectorInPage(handler.queryOne, selector, options);
    }
    if (handler.queryAll) {
        internalHandler.queryAll = async (element, selector) => {
            const jsHandle = await element.evaluateHandle(handler.queryAll, selector);
            const properties = await jsHandle.getProperties();
            await jsHandle.dispose();
            const result = [];
            for (const property of properties.values()) {
                const elementHandle = property.asElement();
                if (elementHandle)
                    result.push(elementHandle);
            }
            return result;
        };
        internalHandler.queryAllArray = async (element, selector) => {
            const resultHandle = await element.evaluateHandle(handler.queryAll, selector);
            const arrayHandle = await resultHandle.evaluateHandle((res) => Array.from(res));
            return arrayHandle;
        };
    }
    return internalHandler;
}
const _defaultHandler = makeQueryHandler({
    queryOne: (element, selector) => element.querySelector(selector),
    queryAll: (element, selector) => element.querySelectorAll(selector),
});
const pierceHandler = makeQueryHandler({
    queryOne: (element, selector) => {
        let found = null;
        const search = (root) => {
            const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            do {
                const currentNode = iter.currentNode;
                if (currentNode.shadowRoot) {
                    search(currentNode.shadowRoot);
                }
                if (currentNode instanceof ShadowRoot) {
                    continue;
                }
                if (!found && currentNode.matches(selector)) {
                    found = currentNode;
                }
            } while (!found && iter.nextNode());
        };
        if (element instanceof Document) {
            element = element.documentElement;
        }
        search(element);
        return found;
    },
    queryAll: (element, selector) => {
        const result = [];
        const collect = (root) => {
            const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
            do {
                const currentNode = iter.currentNode;
                if (currentNode.shadowRoot) {
                    collect(currentNode.shadowRoot);
                }
                if (currentNode instanceof ShadowRoot) {
                    continue;
                }
                if (currentNode.matches(selector)) {
                    result.push(currentNode);
                }
            } while (iter.nextNode());
        };
        if (element instanceof Document) {
            element = element.documentElement;
        }
        collect(element);
        return result;
    },
});
const _builtInHandlers = new Map([
    ['aria', _AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_0__.ariaHandler],
    ['pierce', pierceHandler],
]);
const _queryHandlers = new Map(_builtInHandlers);
/**
 * @internal
 */
function registerCustomQueryHandler(name, handler) {
    if (_queryHandlers.get(name))
        throw new Error(`A custom query handler named "${name}" already exists`);
    const isValidName = /^[a-zA-Z]+$/.test(name);
    if (!isValidName)
        throw new Error(`Custom query handler names may only contain [a-zA-Z]`);
    const internalHandler = makeQueryHandler(handler);
    _queryHandlers.set(name, internalHandler);
}
/**
 * @internal
 */
function unregisterCustomQueryHandler(name) {
    if (_queryHandlers.has(name) && !_builtInHandlers.has(name)) {
        _queryHandlers.delete(name);
    }
}
/**
 * @internal
 */
function customQueryHandlerNames() {
    return [..._queryHandlers.keys()].filter((name) => !_builtInHandlers.has(name));
}
/**
 * @internal
 */
function clearCustomQueryHandlers() {
    customQueryHandlerNames().forEach(unregisterCustomQueryHandler);
}
/**
 * @internal
 */
function getQueryHandlerAndSelector(selector) {
    const hasCustomQueryHandler = /^[a-zA-Z]+\//.test(selector);
    if (!hasCustomQueryHandler)
        return { updatedSelector: selector, queryHandler: _defaultHandler };
    const index = selector.indexOf('/');
    const name = selector.slice(0, index);
    const updatedSelector = selector.slice(index + 1);
    const queryHandler = _queryHandlers.get(name);
    if (!queryHandler)
        throw new Error(`Query set to use "${name}", but no query handler of that name was found`);
    return {
        updatedSelector,
        queryHandler,
    };
}
//# sourceMappingURL=QueryHandler.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SecurityDetails": () => (/* binding */ SecurityDetails)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The SecurityDetails class represents the security details of a
 * response that was received over a secure connection.
 *
 * @public
 */
class SecurityDetails {
    /**
     * @internal
     */
    constructor(securityPayload) {
        this._subjectName = securityPayload.subjectName;
        this._issuer = securityPayload.issuer;
        this._validFrom = securityPayload.validFrom;
        this._validTo = securityPayload.validTo;
        this._protocol = securityPayload.protocol;
        this._sanList = securityPayload.sanList;
    }
    /**
     * @returns The name of the issuer of the certificate.
     */
    issuer() {
        return this._issuer;
    }
    /**
     * @returns {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
        return this._validFrom;
    }
    /**
     * @returns {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
        return this._validTo;
    }
    /**
     * @returns The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
        return this._protocol;
    }
    /**
     * @returns The name of the subject to which the certificate was issued.
     */
    subjectName() {
        return this._subjectName;
    }
    /**
     * @returns The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
        return this._sanList;
    }
}
//# sourceMappingURL=SecurityDetails.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Target.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Target.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Target": () => (/* binding */ Target)
/* harmony export */ });
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Page.js");
/* harmony import */ var _WebWorker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/WebWorker.js");
/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @public
 */
class Target {
    /**
     * @internal
     */
    constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport) {
        this._targetInfo = targetInfo;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        /** @type {?Promise<!Puppeteer.Page>} */
        this._pagePromise = null;
        /** @type {?Promise<!WebWorker>} */
        this._workerPromise = null;
        this._initializedPromise = new Promise((fulfill) => (this._initializedCallback = fulfill)).then(async (success) => {
            if (!success)
                return false;
            const opener = this.opener();
            if (!opener || !opener._pagePromise || this.type() !== 'page')
                return true;
            const openerPage = await opener._pagePromise;
            if (!openerPage.listenerCount("popup" /* Popup */))
                return true;
            const popupPage = await this.page();
            openerPage.emit("popup" /* Popup */, popupPage);
            return true;
        });
        this._isClosedPromise = new Promise((fulfill) => (this._closedCallback = fulfill));
        this._isInitialized =
            this._targetInfo.type !== 'page' || this._targetInfo.url !== '';
        if (this._isInitialized)
            this._initializedCallback(true);
    }
    /**
     * Creates a Chrome Devtools Protocol session attached to the target.
     */
    createCDPSession() {
        return this._sessionFactory();
    }
    /**
     * If the target is not of type `"page"` or `"background_page"`, returns `null`.
     */
    async page() {
        if ((this._targetInfo.type === 'page' ||
            this._targetInfo.type === 'background_page' ||
            this._targetInfo.type === 'webview') &&
            !this._pagePromise) {
            this._pagePromise = this._sessionFactory().then((client) => _Page_js__WEBPACK_IMPORTED_MODULE_0__.Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport));
        }
        return this._pagePromise;
    }
    /**
     * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
     */
    async worker() {
        if (this._targetInfo.type !== 'service_worker' &&
            this._targetInfo.type !== 'shared_worker')
            return null;
        if (!this._workerPromise) {
            // TODO(einbinder): Make workers send their console logs.
            this._workerPromise = this._sessionFactory().then((client) => new _WebWorker_js__WEBPACK_IMPORTED_MODULE_1__.WebWorker(client, this._targetInfo.url, () => { } /* consoleAPICalled */, () => { } /* exceptionThrown */));
        }
        return this._workerPromise;
    }
    url() {
        return this._targetInfo.url;
    }
    /**
     * Identifies what kind of target this is.
     *
     * @remarks
     *
     * See {@link https://developer.chrome.com/extensions/background_pages | docs} for more info about background pages.
     */
    type() {
        const type = this._targetInfo.type;
        if (type === 'page' ||
            type === 'background_page' ||
            type === 'service_worker' ||
            type === 'shared_worker' ||
            type === 'browser' ||
            type === 'webview')
            return type;
        return 'other';
    }
    /**
     * Get the browser the target belongs to.
     */
    browser() {
        return this._browserContext.browser();
    }
    /**
     * Get the browser context the target belongs to.
     */
    browserContext() {
        return this._browserContext;
    }
    /**
     * Get the target that opened this target. Top-level targets return `null`.
     */
    opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
            return null;
        return this.browser()._targets.get(openerId);
    }
    /**
     * @internal
     */
    _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized &&
            (this._targetInfo.type !== 'page' || this._targetInfo.url !== '')) {
            this._isInitialized = true;
            this._initializedCallback(true);
            return;
        }
    }
}
//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeoutSettings": () => (/* binding */ TimeoutSettings)
/* harmony export */ });
/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_TIMEOUT = 30000;
/**
 * @internal
 */
class TimeoutSettings {
    constructor() {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
    }
    setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
    }
    navigationTimeout() {
        if (this._defaultNavigationTimeout !== null)
            return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
    }
    timeout() {
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
    }
}
//# sourceMappingURL=TimeoutSettings.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Tracing.js":
/*!*************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/Tracing.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tracing": () => (/* binding */ Tracing)
/* harmony export */ });
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The Tracing class exposes the tracing audit interface.
 * @remarks
 * You can use `tracing.start` and `tracing.stop` to create a trace file
 * which can be opened in Chrome DevTools or {@link https://chromedevtools.github.io/timeline-viewer/ | timeline viewer}.
 *
 * @example
 * ```js
 * await page.tracing.start({path: 'trace.json'});
 * await page.goto('https://www.google.com');
 * await page.tracing.stop();
 * ```
 *
 * @public
 */
class Tracing {
    /**
     * @internal
     */
    constructor(client) {
        this._recording = false;
        this._path = '';
        this._client = client;
    }
    /**
     * Starts a trace for the current page.
     * @remarks
     * Only one trace can be active at a time per browser.
     * @param options - Optional `TracingOptions`.
     */
    async start(options = {}) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!this._recording, 'Cannot start recording trace while already recording trace.');
        const defaultCategories = [
            '-*',
            'devtools.timeline',
            'v8.execute',
            'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame',
            'toplevel',
            'blink.console',
            'blink.user_timing',
            'latencyInfo',
            'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler',
            'disabled-by-default-v8.cpu_profiler.hires',
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._path = path;
        this._recording = true;
        await this._client.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(','),
        });
    }
    /**
     * Stops a trace started with the `start` method.
     * @returns Promise which resolves to buffer with trace data.
     */
    async stop() {
        let fulfill;
        let reject;
        const contentPromise = new Promise((x, y) => {
            fulfill = x;
            reject = y;
        });
        this._client.once('Tracing.tracingComplete', (event) => {
            _helper_js__WEBPACK_IMPORTED_MODULE_1__.helper.readProtocolStream(this._client, event.stream, this._path)
                .then(fulfill, reject);
        });
        await this._client.send('Tracing.end');
        this._recording = false;
        return contentPromise;
    }
}
//# sourceMappingURL=Tracing.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keyDefinitions": () => (/* binding */ keyDefinitions)
/* harmony export */ });
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const keyDefinitions = {
    '0': { keyCode: 48, key: '0', code: 'Digit0' },
    '1': { keyCode: 49, key: '1', code: 'Digit1' },
    '2': { keyCode: 50, key: '2', code: 'Digit2' },
    '3': { keyCode: 51, key: '3', code: 'Digit3' },
    '4': { keyCode: 52, key: '4', code: 'Digit4' },
    '5': { keyCode: 53, key: '5', code: 'Digit5' },
    '6': { keyCode: 54, key: '6', code: 'Digit6' },
    '7': { keyCode: 55, key: '7', code: 'Digit7' },
    '8': { keyCode: 56, key: '8', code: 'Digit8' },
    '9': { keyCode: 57, key: '9', code: 'Digit9' },
    Power: { key: 'Power', code: 'Power' },
    Eject: { key: 'Eject', code: 'Eject' },
    Abort: { keyCode: 3, code: 'Abort', key: 'Cancel' },
    Help: { keyCode: 6, code: 'Help', key: 'Help' },
    Backspace: { keyCode: 8, code: 'Backspace', key: 'Backspace' },
    Tab: { keyCode: 9, code: 'Tab', key: 'Tab' },
    Numpad5: {
        keyCode: 12,
        shiftKeyCode: 101,
        key: 'Clear',
        code: 'Numpad5',
        shiftKey: '5',
        location: 3,
    },
    NumpadEnter: {
        keyCode: 13,
        code: 'NumpadEnter',
        key: 'Enter',
        text: '\r',
        location: 3,
    },
    Enter: { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\r': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\n': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    ShiftLeft: { keyCode: 16, code: 'ShiftLeft', key: 'Shift', location: 1 },
    ShiftRight: { keyCode: 16, code: 'ShiftRight', key: 'Shift', location: 2 },
    ControlLeft: {
        keyCode: 17,
        code: 'ControlLeft',
        key: 'Control',
        location: 1,
    },
    ControlRight: {
        keyCode: 17,
        code: 'ControlRight',
        key: 'Control',
        location: 2,
    },
    AltLeft: { keyCode: 18, code: 'AltLeft', key: 'Alt', location: 1 },
    AltRight: { keyCode: 18, code: 'AltRight', key: 'Alt', location: 2 },
    Pause: { keyCode: 19, code: 'Pause', key: 'Pause' },
    CapsLock: { keyCode: 20, code: 'CapsLock', key: 'CapsLock' },
    Escape: { keyCode: 27, code: 'Escape', key: 'Escape' },
    Convert: { keyCode: 28, code: 'Convert', key: 'Convert' },
    NonConvert: { keyCode: 29, code: 'NonConvert', key: 'NonConvert' },
    Space: { keyCode: 32, code: 'Space', key: ' ' },
    Numpad9: {
        keyCode: 33,
        shiftKeyCode: 105,
        key: 'PageUp',
        code: 'Numpad9',
        shiftKey: '9',
        location: 3,
    },
    PageUp: { keyCode: 33, code: 'PageUp', key: 'PageUp' },
    Numpad3: {
        keyCode: 34,
        shiftKeyCode: 99,
        key: 'PageDown',
        code: 'Numpad3',
        shiftKey: '3',
        location: 3,
    },
    PageDown: { keyCode: 34, code: 'PageDown', key: 'PageDown' },
    End: { keyCode: 35, code: 'End', key: 'End' },
    Numpad1: {
        keyCode: 35,
        shiftKeyCode: 97,
        key: 'End',
        code: 'Numpad1',
        shiftKey: '1',
        location: 3,
    },
    Home: { keyCode: 36, code: 'Home', key: 'Home' },
    Numpad7: {
        keyCode: 36,
        shiftKeyCode: 103,
        key: 'Home',
        code: 'Numpad7',
        shiftKey: '7',
        location: 3,
    },
    ArrowLeft: { keyCode: 37, code: 'ArrowLeft', key: 'ArrowLeft' },
    Numpad4: {
        keyCode: 37,
        shiftKeyCode: 100,
        key: 'ArrowLeft',
        code: 'Numpad4',
        shiftKey: '4',
        location: 3,
    },
    Numpad8: {
        keyCode: 38,
        shiftKeyCode: 104,
        key: 'ArrowUp',
        code: 'Numpad8',
        shiftKey: '8',
        location: 3,
    },
    ArrowUp: { keyCode: 38, code: 'ArrowUp', key: 'ArrowUp' },
    ArrowRight: { keyCode: 39, code: 'ArrowRight', key: 'ArrowRight' },
    Numpad6: {
        keyCode: 39,
        shiftKeyCode: 102,
        key: 'ArrowRight',
        code: 'Numpad6',
        shiftKey: '6',
        location: 3,
    },
    Numpad2: {
        keyCode: 40,
        shiftKeyCode: 98,
        key: 'ArrowDown',
        code: 'Numpad2',
        shiftKey: '2',
        location: 3,
    },
    ArrowDown: { keyCode: 40, code: 'ArrowDown', key: 'ArrowDown' },
    Select: { keyCode: 41, code: 'Select', key: 'Select' },
    Open: { keyCode: 43, code: 'Open', key: 'Execute' },
    PrintScreen: { keyCode: 44, code: 'PrintScreen', key: 'PrintScreen' },
    Insert: { keyCode: 45, code: 'Insert', key: 'Insert' },
    Numpad0: {
        keyCode: 45,
        shiftKeyCode: 96,
        key: 'Insert',
        code: 'Numpad0',
        shiftKey: '0',
        location: 3,
    },
    Delete: { keyCode: 46, code: 'Delete', key: 'Delete' },
    NumpadDecimal: {
        keyCode: 46,
        shiftKeyCode: 110,
        code: 'NumpadDecimal',
        key: '\u0000',
        shiftKey: '.',
        location: 3,
    },
    Digit0: { keyCode: 48, code: 'Digit0', shiftKey: ')', key: '0' },
    Digit1: { keyCode: 49, code: 'Digit1', shiftKey: '!', key: '1' },
    Digit2: { keyCode: 50, code: 'Digit2', shiftKey: '@', key: '2' },
    Digit3: { keyCode: 51, code: 'Digit3', shiftKey: '#', key: '3' },
    Digit4: { keyCode: 52, code: 'Digit4', shiftKey: '$', key: '4' },
    Digit5: { keyCode: 53, code: 'Digit5', shiftKey: '%', key: '5' },
    Digit6: { keyCode: 54, code: 'Digit6', shiftKey: '^', key: '6' },
    Digit7: { keyCode: 55, code: 'Digit7', shiftKey: '&', key: '7' },
    Digit8: { keyCode: 56, code: 'Digit8', shiftKey: '*', key: '8' },
    Digit9: { keyCode: 57, code: 'Digit9', shiftKey: '(', key: '9' },
    KeyA: { keyCode: 65, code: 'KeyA', shiftKey: 'A', key: 'a' },
    KeyB: { keyCode: 66, code: 'KeyB', shiftKey: 'B', key: 'b' },
    KeyC: { keyCode: 67, code: 'KeyC', shiftKey: 'C', key: 'c' },
    KeyD: { keyCode: 68, code: 'KeyD', shiftKey: 'D', key: 'd' },
    KeyE: { keyCode: 69, code: 'KeyE', shiftKey: 'E', key: 'e' },
    KeyF: { keyCode: 70, code: 'KeyF', shiftKey: 'F', key: 'f' },
    KeyG: { keyCode: 71, code: 'KeyG', shiftKey: 'G', key: 'g' },
    KeyH: { keyCode: 72, code: 'KeyH', shiftKey: 'H', key: 'h' },
    KeyI: { keyCode: 73, code: 'KeyI', shiftKey: 'I', key: 'i' },
    KeyJ: { keyCode: 74, code: 'KeyJ', shiftKey: 'J', key: 'j' },
    KeyK: { keyCode: 75, code: 'KeyK', shiftKey: 'K', key: 'k' },
    KeyL: { keyCode: 76, code: 'KeyL', shiftKey: 'L', key: 'l' },
    KeyM: { keyCode: 77, code: 'KeyM', shiftKey: 'M', key: 'm' },
    KeyN: { keyCode: 78, code: 'KeyN', shiftKey: 'N', key: 'n' },
    KeyO: { keyCode: 79, code: 'KeyO', shiftKey: 'O', key: 'o' },
    KeyP: { keyCode: 80, code: 'KeyP', shiftKey: 'P', key: 'p' },
    KeyQ: { keyCode: 81, code: 'KeyQ', shiftKey: 'Q', key: 'q' },
    KeyR: { keyCode: 82, code: 'KeyR', shiftKey: 'R', key: 'r' },
    KeyS: { keyCode: 83, code: 'KeyS', shiftKey: 'S', key: 's' },
    KeyT: { keyCode: 84, code: 'KeyT', shiftKey: 'T', key: 't' },
    KeyU: { keyCode: 85, code: 'KeyU', shiftKey: 'U', key: 'u' },
    KeyV: { keyCode: 86, code: 'KeyV', shiftKey: 'V', key: 'v' },
    KeyW: { keyCode: 87, code: 'KeyW', shiftKey: 'W', key: 'w' },
    KeyX: { keyCode: 88, code: 'KeyX', shiftKey: 'X', key: 'x' },
    KeyY: { keyCode: 89, code: 'KeyY', shiftKey: 'Y', key: 'y' },
    KeyZ: { keyCode: 90, code: 'KeyZ', shiftKey: 'Z', key: 'z' },
    MetaLeft: { keyCode: 91, code: 'MetaLeft', key: 'Meta', location: 1 },
    MetaRight: { keyCode: 92, code: 'MetaRight', key: 'Meta', location: 2 },
    ContextMenu: { keyCode: 93, code: 'ContextMenu', key: 'ContextMenu' },
    NumpadMultiply: {
        keyCode: 106,
        code: 'NumpadMultiply',
        key: '*',
        location: 3,
    },
    NumpadAdd: { keyCode: 107, code: 'NumpadAdd', key: '+', location: 3 },
    NumpadSubtract: {
        keyCode: 109,
        code: 'NumpadSubtract',
        key: '-',
        location: 3,
    },
    NumpadDivide: { keyCode: 111, code: 'NumpadDivide', key: '/', location: 3 },
    F1: { keyCode: 112, code: 'F1', key: 'F1' },
    F2: { keyCode: 113, code: 'F2', key: 'F2' },
    F3: { keyCode: 114, code: 'F3', key: 'F3' },
    F4: { keyCode: 115, code: 'F4', key: 'F4' },
    F5: { keyCode: 116, code: 'F5', key: 'F5' },
    F6: { keyCode: 117, code: 'F6', key: 'F6' },
    F7: { keyCode: 118, code: 'F7', key: 'F7' },
    F8: { keyCode: 119, code: 'F8', key: 'F8' },
    F9: { keyCode: 120, code: 'F9', key: 'F9' },
    F10: { keyCode: 121, code: 'F10', key: 'F10' },
    F11: { keyCode: 122, code: 'F11', key: 'F11' },
    F12: { keyCode: 123, code: 'F12', key: 'F12' },
    F13: { keyCode: 124, code: 'F13', key: 'F13' },
    F14: { keyCode: 125, code: 'F14', key: 'F14' },
    F15: { keyCode: 126, code: 'F15', key: 'F15' },
    F16: { keyCode: 127, code: 'F16', key: 'F16' },
    F17: { keyCode: 128, code: 'F17', key: 'F17' },
    F18: { keyCode: 129, code: 'F18', key: 'F18' },
    F19: { keyCode: 130, code: 'F19', key: 'F19' },
    F20: { keyCode: 131, code: 'F20', key: 'F20' },
    F21: { keyCode: 132, code: 'F21', key: 'F21' },
    F22: { keyCode: 133, code: 'F22', key: 'F22' },
    F23: { keyCode: 134, code: 'F23', key: 'F23' },
    F24: { keyCode: 135, code: 'F24', key: 'F24' },
    NumLock: { keyCode: 144, code: 'NumLock', key: 'NumLock' },
    ScrollLock: { keyCode: 145, code: 'ScrollLock', key: 'ScrollLock' },
    AudioVolumeMute: {
        keyCode: 173,
        code: 'AudioVolumeMute',
        key: 'AudioVolumeMute',
    },
    AudioVolumeDown: {
        keyCode: 174,
        code: 'AudioVolumeDown',
        key: 'AudioVolumeDown',
    },
    AudioVolumeUp: { keyCode: 175, code: 'AudioVolumeUp', key: 'AudioVolumeUp' },
    MediaTrackNext: {
        keyCode: 176,
        code: 'MediaTrackNext',
        key: 'MediaTrackNext',
    },
    MediaTrackPrevious: {
        keyCode: 177,
        code: 'MediaTrackPrevious',
        key: 'MediaTrackPrevious',
    },
    MediaStop: { keyCode: 178, code: 'MediaStop', key: 'MediaStop' },
    MediaPlayPause: {
        keyCode: 179,
        code: 'MediaPlayPause',
        key: 'MediaPlayPause',
    },
    Semicolon: { keyCode: 186, code: 'Semicolon', shiftKey: ':', key: ';' },
    Equal: { keyCode: 187, code: 'Equal', shiftKey: '+', key: '=' },
    NumpadEqual: { keyCode: 187, code: 'NumpadEqual', key: '=', location: 3 },
    Comma: { keyCode: 188, code: 'Comma', shiftKey: '<', key: ',' },
    Minus: { keyCode: 189, code: 'Minus', shiftKey: '_', key: '-' },
    Period: { keyCode: 190, code: 'Period', shiftKey: '>', key: '.' },
    Slash: { keyCode: 191, code: 'Slash', shiftKey: '?', key: '/' },
    Backquote: { keyCode: 192, code: 'Backquote', shiftKey: '~', key: '`' },
    BracketLeft: { keyCode: 219, code: 'BracketLeft', shiftKey: '{', key: '[' },
    Backslash: { keyCode: 220, code: 'Backslash', shiftKey: '|', key: '\\' },
    BracketRight: { keyCode: 221, code: 'BracketRight', shiftKey: '}', key: ']' },
    Quote: { keyCode: 222, code: 'Quote', shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: 'AltGraph', key: 'AltGraph' },
    Props: { keyCode: 247, code: 'Props', key: 'CrSel' },
    Cancel: { keyCode: 3, key: 'Cancel', code: 'Abort' },
    Clear: { keyCode: 12, key: 'Clear', code: 'Numpad5', location: 3 },
    Shift: { keyCode: 16, key: 'Shift', code: 'ShiftLeft', location: 1 },
    Control: { keyCode: 17, key: 'Control', code: 'ControlLeft', location: 1 },
    Alt: { keyCode: 18, key: 'Alt', code: 'AltLeft', location: 1 },
    Accept: { keyCode: 30, key: 'Accept' },
    ModeChange: { keyCode: 31, key: 'ModeChange' },
    ' ': { keyCode: 32, key: ' ', code: 'Space' },
    Print: { keyCode: 42, key: 'Print' },
    Execute: { keyCode: 43, key: 'Execute', code: 'Open' },
    '\u0000': { keyCode: 46, key: '\u0000', code: 'NumpadDecimal', location: 3 },
    a: { keyCode: 65, key: 'a', code: 'KeyA' },
    b: { keyCode: 66, key: 'b', code: 'KeyB' },
    c: { keyCode: 67, key: 'c', code: 'KeyC' },
    d: { keyCode: 68, key: 'd', code: 'KeyD' },
    e: { keyCode: 69, key: 'e', code: 'KeyE' },
    f: { keyCode: 70, key: 'f', code: 'KeyF' },
    g: { keyCode: 71, key: 'g', code: 'KeyG' },
    h: { keyCode: 72, key: 'h', code: 'KeyH' },
    i: { keyCode: 73, key: 'i', code: 'KeyI' },
    j: { keyCode: 74, key: 'j', code: 'KeyJ' },
    k: { keyCode: 75, key: 'k', code: 'KeyK' },
    l: { keyCode: 76, key: 'l', code: 'KeyL' },
    m: { keyCode: 77, key: 'm', code: 'KeyM' },
    n: { keyCode: 78, key: 'n', code: 'KeyN' },
    o: { keyCode: 79, key: 'o', code: 'KeyO' },
    p: { keyCode: 80, key: 'p', code: 'KeyP' },
    q: { keyCode: 81, key: 'q', code: 'KeyQ' },
    r: { keyCode: 82, key: 'r', code: 'KeyR' },
    s: { keyCode: 83, key: 's', code: 'KeyS' },
    t: { keyCode: 84, key: 't', code: 'KeyT' },
    u: { keyCode: 85, key: 'u', code: 'KeyU' },
    v: { keyCode: 86, key: 'v', code: 'KeyV' },
    w: { keyCode: 87, key: 'w', code: 'KeyW' },
    x: { keyCode: 88, key: 'x', code: 'KeyX' },
    y: { keyCode: 89, key: 'y', code: 'KeyY' },
    z: { keyCode: 90, key: 'z', code: 'KeyZ' },
    Meta: { keyCode: 91, key: 'Meta', code: 'MetaLeft', location: 1 },
    '*': { keyCode: 106, key: '*', code: 'NumpadMultiply', location: 3 },
    '+': { keyCode: 107, key: '+', code: 'NumpadAdd', location: 3 },
    '-': { keyCode: 109, key: '-', code: 'NumpadSubtract', location: 3 },
    '/': { keyCode: 111, key: '/', code: 'NumpadDivide', location: 3 },
    ';': { keyCode: 186, key: ';', code: 'Semicolon' },
    '=': { keyCode: 187, key: '=', code: 'Equal' },
    ',': { keyCode: 188, key: ',', code: 'Comma' },
    '.': { keyCode: 190, key: '.', code: 'Period' },
    '`': { keyCode: 192, key: '`', code: 'Backquote' },
    '[': { keyCode: 219, key: '[', code: 'BracketLeft' },
    '\\': { keyCode: 220, key: '\\', code: 'Backslash' },
    ']': { keyCode: 221, key: ']', code: 'BracketRight' },
    "'": { keyCode: 222, key: "'", code: 'Quote' },
    Attn: { keyCode: 246, key: 'Attn' },
    CrSel: { keyCode: 247, key: 'CrSel', code: 'Props' },
    ExSel: { keyCode: 248, key: 'ExSel' },
    EraseEof: { keyCode: 249, key: 'EraseEof' },
    Play: { keyCode: 250, key: 'Play' },
    ZoomOut: { keyCode: 251, key: 'ZoomOut' },
    ')': { keyCode: 48, key: ')', code: 'Digit0' },
    '!': { keyCode: 49, key: '!', code: 'Digit1' },
    '@': { keyCode: 50, key: '@', code: 'Digit2' },
    '#': { keyCode: 51, key: '#', code: 'Digit3' },
    $: { keyCode: 52, key: '$', code: 'Digit4' },
    '%': { keyCode: 53, key: '%', code: 'Digit5' },
    '^': { keyCode: 54, key: '^', code: 'Digit6' },
    '&': { keyCode: 55, key: '&', code: 'Digit7' },
    '(': { keyCode: 57, key: '(', code: 'Digit9' },
    A: { keyCode: 65, key: 'A', code: 'KeyA' },
    B: { keyCode: 66, key: 'B', code: 'KeyB' },
    C: { keyCode: 67, key: 'C', code: 'KeyC' },
    D: { keyCode: 68, key: 'D', code: 'KeyD' },
    E: { keyCode: 69, key: 'E', code: 'KeyE' },
    F: { keyCode: 70, key: 'F', code: 'KeyF' },
    G: { keyCode: 71, key: 'G', code: 'KeyG' },
    H: { keyCode: 72, key: 'H', code: 'KeyH' },
    I: { keyCode: 73, key: 'I', code: 'KeyI' },
    J: { keyCode: 74, key: 'J', code: 'KeyJ' },
    K: { keyCode: 75, key: 'K', code: 'KeyK' },
    L: { keyCode: 76, key: 'L', code: 'KeyL' },
    M: { keyCode: 77, key: 'M', code: 'KeyM' },
    N: { keyCode: 78, key: 'N', code: 'KeyN' },
    O: { keyCode: 79, key: 'O', code: 'KeyO' },
    P: { keyCode: 80, key: 'P', code: 'KeyP' },
    Q: { keyCode: 81, key: 'Q', code: 'KeyQ' },
    R: { keyCode: 82, key: 'R', code: 'KeyR' },
    S: { keyCode: 83, key: 'S', code: 'KeyS' },
    T: { keyCode: 84, key: 'T', code: 'KeyT' },
    U: { keyCode: 85, key: 'U', code: 'KeyU' },
    V: { keyCode: 86, key: 'V', code: 'KeyV' },
    W: { keyCode: 87, key: 'W', code: 'KeyW' },
    X: { keyCode: 88, key: 'X', code: 'KeyX' },
    Y: { keyCode: 89, key: 'Y', code: 'KeyY' },
    Z: { keyCode: 90, key: 'Z', code: 'KeyZ' },
    ':': { keyCode: 186, key: ':', code: 'Semicolon' },
    '<': { keyCode: 188, key: '<', code: 'Comma' },
    _: { keyCode: 189, key: '_', code: 'Minus' },
    '>': { keyCode: 190, key: '>', code: 'Period' },
    '?': { keyCode: 191, key: '?', code: 'Slash' },
    '~': { keyCode: 192, key: '~', code: 'Backquote' },
    '{': { keyCode: 219, key: '{', code: 'BracketLeft' },
    '|': { keyCode: 220, key: '|', code: 'Backslash' },
    '}': { keyCode: 221, key: '}', code: 'BracketRight' },
    '"': { keyCode: 222, key: '"', code: 'Quote' },
    SoftLeft: { key: 'SoftLeft', code: 'SoftLeft', location: 4 },
    SoftRight: { key: 'SoftRight', code: 'SoftRight', location: 4 },
    Camera: { keyCode: 44, key: 'Camera', code: 'Camera', location: 4 },
    Call: { key: 'Call', code: 'Call', location: 4 },
    EndCall: { keyCode: 95, key: 'EndCall', code: 'EndCall', location: 4 },
    VolumeDown: {
        keyCode: 182,
        key: 'VolumeDown',
        code: 'VolumeDown',
        location: 4,
    },
    VolumeUp: { keyCode: 183, key: 'VolumeUp', code: 'VolumeUp', location: 4 },
};
//# sourceMappingURL=USKeyboardLayout.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/WebWorker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/WebWorker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebWorker": () => (/* binding */ WebWorker)
/* harmony export */ });
/* harmony import */ var _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js");
/* harmony import */ var _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExecutionContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js");
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * The WebWorker class represents a
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.
 *
 * @remarks
 * The events `workercreated` and `workerdestroyed` are emitted on the page
 * object to signal the worker lifecycle.
 *
 * @example
 * ```js
 * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));
 * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));
 *
 * console.log('Current workers:');
 * for (const worker of page.workers()) {
 *   console.log('  ' + worker.url());
 * }
 * ```
 *
 * @public
 */
class WebWorker extends _EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    /**
     *
     * @internal
     */
    constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        this._client = client;
        this._url = url;
        this._executionContextPromise = new Promise((x) => (this._executionContextCallback = x));
        let jsHandleFactory;
        this._client.once('Runtime.executionContextCreated', async (event) => {
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            jsHandleFactory = (remoteObject) => new _JSHandle_js__WEBPACK_IMPORTED_MODULE_3__.JSHandle(executionContext, client, remoteObject);
            const executionContext = new _ExecutionContext_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionContext(client, event.context, null);
            this._executionContextCallback(executionContext);
        });
        // This might fail if the target is closed before we receive all execution contexts.
        this._client.send('Runtime.enable').catch(_helper_js__WEBPACK_IMPORTED_MODULE_1__.debugError);
        this._client.on('Runtime.consoleAPICalled', (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));
        this._client.on('Runtime.exceptionThrown', (exception) => exceptionThrown(exception.exceptionDetails));
    }
    /**
     * @returns The URL of this web worker.
     */
    url() {
        return this._url;
    }
    /**
     * Returns the ExecutionContext the WebWorker runs in
     * @returns The ExecutionContext the web worker runs in.
     */
    async executionContext() {
        return this._executionContextPromise;
    }
    /**
     * If the function passed to the `worker.evaluate` returns a Promise, then
     * `worker.evaluate` would wait for the promise to resolve and return its
     * value. If the function passed to the `worker.evaluate` returns a
     * non-serializable value, then `worker.evaluate` resolves to `undefined`.
     * DevTools Protocol also supports transferring some additional values that
     * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and
     * bigint literals.
     * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.
     *
     * @param pageFunction - Function to be evaluated in the worker context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluate(pageFunction, ...args);
    }
    /**
     * The only difference between `worker.evaluate` and `worker.evaluateHandle`
     * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the
     * function passed to the `worker.evaluateHandle` returns a `Promise`, then
     * `worker.evaluateHandle` would wait for the promise to resolve and return
     * its value. Shortcut for
     * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`
     *
     * @param pageFunction - Function to be evaluated in the page context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluateHandle(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
    }
}
//# sourceMappingURL=WebWorker.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assert": () => (/* binding */ assert)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Asserts that the given value is truthy.
 * @param value
 * @param message - the error message to throw if the value is not truthy.
 */
const assert = (value, message) => {
    if (!value)
        throw new Error(message);
};
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/fetch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/fetch.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getFetch": () => (/* binding */ getFetch)
/* harmony export */ });
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Use the global version if we're in the browser, else load the node-fetch module. */
const getFetch = async () => {
    return _environment_js__WEBPACK_IMPORTED_MODULE_0__.isNode ? await __webpack_require__.e(/*! import() */ "node_modules_node-fetch_browser_js").then(__webpack_require__.t.bind(__webpack_require__, /*! node-fetch */ "./node_modules/node-fetch/browser.js", 23)) : globalThis.fetch;
};
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/common/helper.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debugError": () => (/* binding */ debugError),
/* harmony export */   "helper": () => (/* binding */ helper)
/* harmony export */ });
/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/assert.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const debugError = (0,_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:error');
function getExceptionMessage(exceptionDetails) {
    if (exceptionDetails.exception)
        return (exceptionDetails.exception.description || exceptionDetails.exception.value);
    let message = exceptionDetails.text;
    if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url +
                ':' +
                callframe.lineNumber +
                ':' +
                callframe.columnNumber;
            const functionName = callframe.functionName || '<anonymous>';
            message += `\n    at ${functionName} (${location})`;
        }
    }
    return message;
}
function valueFromRemoteObject(remoteObject) {
    (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.unserializableValue) {
        if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined')
            return BigInt(remoteObject.unserializableValue.replace('n', ''));
        switch (remoteObject.unserializableValue) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                throw new Error('Unsupported unserializable value: ' +
                    remoteObject.unserializableValue);
        }
    }
    return remoteObject.value;
}
async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId)
        return;
    await client
        .send('Runtime.releaseObject', { objectId: remoteObject.objectId })
        .catch((error) => {
        // Exceptions might happen in case of a page been navigated or closed.
        // Swallow these since they are harmless and we don't leak anything in this case.
        debugError(error);
    });
}
function addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return { emitter, eventName, handler };
}
function removeEventListeners(listeners) {
    for (const listener of listeners)
        listener.emitter.removeListener(listener.eventName, listener.handler);
    listeners.length = 0;
}
function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}
function isNumber(obj) {
    return typeof obj === 'number' || obj instanceof Number;
}
async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
    let eventTimeout, resolveCallback, rejectCallback;
    const promise = new Promise((resolve, reject) => {
        resolveCallback = resolve;
        rejectCallback = reject;
    });
    const listener = addEventListener(emitter, eventName, async (event) => {
        if (!(await predicate(event)))
            return;
        resolveCallback(event);
    });
    if (timeout) {
        eventTimeout = setTimeout(() => {
            rejectCallback(new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError('Timeout exceeded while waiting for event'));
        }, timeout);
    }
    function cleanup() {
        removeEventListeners([listener]);
        clearTimeout(eventTimeout);
    }
    const result = await Promise.race([promise, abortPromise]).then((r) => {
        cleanup();
        return r;
    }, (error) => {
        cleanup();
        throw error;
    });
    if (result instanceof Error)
        throw result;
    return result;
}
function evaluationString(fun, ...args) {
    if (isString(fun)) {
        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.assert)(args.length === 0, 'Cannot evaluate a string with arguments');
        return fun;
    }
    function serializeArgument(arg) {
        if (Object.is(arg, undefined))
            return 'undefined';
        return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(',')})`;
}
function pageBindingInitString(type, name) {
    function addPageBinding(type, bindingName) {
        /* Cast window to any here as we're about to add properties to it
         * via win[bindingName] which TypeScript doesn't like.
         */
        const win = window;
        const binding = win[bindingName];
        win[bindingName] = (...args) => {
            const me = window[bindingName];
            let callbacks = me.callbacks;
            if (!callbacks) {
                callbacks = new Map();
                me.callbacks = callbacks;
            }
            const seq = (me.lastSeq || 0) + 1;
            me.lastSeq = seq;
            const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
            binding(JSON.stringify({ type, name: bindingName, seq, args }));
            return promise;
        };
    }
    return evaluationString(addPageBinding, type, name);
}
function pageBindingDeliverResultString(name, seq, result) {
    function deliverResult(name, seq, result) {
        window[name].callbacks.get(seq).resolve(result);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverResult, name, seq, result);
}
function pageBindingDeliverErrorString(name, seq, message, stack) {
    function deliverError(name, seq, message, stack) {
        const error = new Error(message);
        error.stack = stack;
        window[name].callbacks.get(seq).reject(error);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverError, name, seq, message, stack);
}
function pageBindingDeliverErrorValueString(name, seq, value) {
    function deliverErrorValue(name, seq, value) {
        window[name].callbacks.get(seq).reject(value);
        window[name].callbacks.delete(seq);
    }
    return evaluationString(deliverErrorValue, name, seq, value);
}
function makePredicateString(predicate, predicateQueryHandler) {
    function checkWaitForOptions(node, waitForVisible, waitForHidden) {
        if (!node)
            return waitForHidden;
        if (!waitForVisible && !waitForHidden)
            return node;
        const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
        const style = window.getComputedStyle(element);
        const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();
        const success = waitForVisible === isVisible || waitForHidden === !isVisible;
        return success ? node : null;
        function hasVisibleBoundingBox() {
            const rect = element.getBoundingClientRect();
            return !!(rect.top || rect.bottom || rect.width || rect.height);
        }
    }
    const predicateQueryHandlerDef = predicateQueryHandler
        ? `const predicateQueryHandler = ${predicateQueryHandler};`
        : '';
    return `
    (() => {
      ${predicateQueryHandlerDef}
      const checkWaitForOptions = ${checkWaitForOptions};
      return (${predicate})(...args)
    })() `;
}
async function waitWithTimeout(promise, taskName, timeout) {
    let reject;
    const timeoutError = new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
    const timeoutPromise = new Promise((resolve, x) => (reject = x));
    let timeoutTimer = null;
    if (timeout)
        timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
    try {
        return await Promise.race([promise, timeoutPromise]);
    }
    finally {
        if (timeoutTimer)
            clearTimeout(timeoutTimer);
    }
}
async function readProtocolStream(client, handle, path) {
    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.isNode && path) {
        throw new Error('Cannot write to a path outside of Node.js environment.');
    }
    const fs = _environment_js__WEBPACK_IMPORTED_MODULE_3__.isNode ? await importFSModule() : null;
    let eof = false;
    let fileHandle;
    if (path && fs) {
        fileHandle = await fs.promises.open(path, 'w');
    }
    const bufs = [];
    while (!eof) {
        const response = await client.send('IO.read', { handle });
        eof = response.eof;
        const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);
        bufs.push(buf);
        if (path && fs) {
            await fs.promises.writeFile(fileHandle, buf);
        }
    }
    if (path)
        await fileHandle.close();
    await client.send('IO.close', { handle });
    let resultBuffer = null;
    try {
        resultBuffer = Buffer.concat(bufs);
    }
    finally {
        return resultBuffer;
    }
}
/**
 * Loads the Node fs promises API. Needed because on Node 10.17 and below,
 * fs.promises is experimental, and therefore not marked as enumerable. That
 * means when TypeScript compiles an `import('fs')`, its helper doesn't spot the
 * promises declaration and therefore on Node <10.17 you get an error as
 * fs.promises is undefined in compiled TypeScript land.
 *
 * See https://github.com/puppeteer/puppeteer/issues/6548 for more details.
 *
 * Once Node 10 is no longer supported (April 2021) we can remove this and use
 * `(await import('fs')).promises`.
 */
async function importFSModule() {
    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.isNode) {
        throw new Error('Cannot load the fs module API outside of Node.');
    }
    const fs = await __webpack_require__.e(/*! import() */ "_67af").then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ "?67af", 23));
    if (fs.promises) {
        return fs;
    }
    return fs.default;
}
const helper = {
    evaluationString,
    pageBindingInitString,
    pageBindingDeliverResultString,
    pageBindingDeliverErrorString,
    pageBindingDeliverErrorValueString,
    makePredicateString,
    readProtocolStream,
    waitWithTimeout,
    waitForEvent,
    isString,
    isNumber,
    importFSModule,
    addEventListener,
    removeEventListeners,
    valueFromRemoteObject,
    getExceptionMessage,
    releaseObject,
};
//# sourceMappingURL=helper.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNode": () => (/* binding */ isNode)
/* harmony export */ });
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const isNode = !!(typeof process !== 'undefined' && process.version);
//# sourceMappingURL=environment.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/initialize-web.js":
/*!*************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/initialize-web.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initializePuppeteerWeb": () => (/* binding */ initializePuppeteerWeb)
/* harmony export */ });
/* harmony import */ var _common_Puppeteer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/Puppeteer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const initializePuppeteerWeb = (packageName) => {
    const isPuppeteerCore = packageName === 'puppeteer-core';
    return new _common_Puppeteer_js__WEBPACK_IMPORTED_MODULE_0__.Puppeteer({
        isPuppeteerCore,
    });
};
//# sourceMappingURL=initialize-web.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/web.js":
/*!**************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/web.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _initialize_web_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initialize-web.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/initialize-web.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/environment.js");
/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


if (_environment_js__WEBPACK_IMPORTED_MODULE_1__.isNode) {
    throw new Error('Trying to run Puppeteer-Web in a Node environment');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_initialize_web_js__WEBPACK_IMPORTED_MODULE_0__.initializePuppeteerWeb)('puppeteer'));
//# sourceMappingURL=web.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/vendor/mitt/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/vendor/mitt/src/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mitt)
/* harmony export */ });
/**
 * Mitt: Tiny (~200b) functional event emitter / pubsub.
 * @name mitt
 * @returns {Mitt}
 */
function mitt(all) {
    all = all || new Map();
    return {
        /**
         * A Map of event names to registered handler functions.
         */
        all,
        /**
         * Register an event handler for the given type.
         * @param {string|symbol} type Type of event to listen for, or `"*"` for all events
         * @param {Function} handler Function to call in response to given event
         * @memberOf mitt
         */
        on(type, handler) {
            const handlers = all.get(type);
            const added = handlers && handlers.push(handler);
            if (!added) {
                all.set(type, [handler]);
            }
        },
        /**
         * Remove an event handler for the given type.
         * @param {string|symbol} type Type of event to unregister `handler` from, or `"*"`
         * @param {Function} handler Handler function to remove
         * @memberOf mitt
         */
        off(type, handler) {
            const handlers = all.get(type);
            if (handlers) {
                handlers.splice(handlers.indexOf(handler) >>> 0, 1);
            }
        },
        /**
         * Invoke all handlers for the given type.
         * If present, `"*"` handlers are invoked after type-matched handlers.
         *
         * Note: Manually firing "*" handlers is not supported.
         *
         * @param {string|symbol} type The event type to invoke
         * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
         * @memberOf mitt
         */
        emit(type, evt) {
            (all.get(type) || []).slice().map((handler) => { handler(evt); });
            (all.get('*') || []).slice().map((handler) => { handler(type, evt); });
        }
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./src/puppeteer.worker.ts":
/*!*********************************!*\
  !*** ./src/puppeteer.worker.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js");
var web_1 = __importDefault(__webpack_require__(/*! puppeteer-core/lib/esm/puppeteer/web */ "./node_modules/puppeteer-core/lib/esm/puppeteer/web.js"));
var types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
var protocolCommands = Object.keys(types_1.ProtocolCommands);
var browser;
var page;
var client;
var sendParentMessage = function (message) {
    self.postMessage(message);
};
var closeWorker = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (browser)
            browser.disconnect();
        return [2, self.close()];
    });
}); };
var onScreencastFrame = function (_a) {
    var data = _a.data, sessionId = _a.sessionId, metadata = _a.metadata;
    console.log('OnScreencastFrame. sessionId:', sessionId, ' metadata:', JSON.stringify(metadata));
    if (client) {
        console.log('client exists');
        client
            .send('Page.screencastFrameAck', { sessionId: sessionId })
            .then(function () { return console.log('sent ack for sessionid', sessionId); })
            .catch(function () { return console.error('Could not send screencast ack'); });
        sendParentMessage({ command: types_1.WorkerCommands.screencastFrame, data: data });
    }
};
var start = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var targetId, browserWSEndpoint, _a, quality, pages;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                targetId = data.targetId, browserWSEndpoint = data.browserWSEndpoint, _a = data.quality, quality = _a === void 0 ? 100 : _a;
                return [4, web_1.default.connect({ browserWSEndpoint: browserWSEndpoint }).catch(function (error) {
                        console.error(error);
                        return undefined;
                    })];
            case 1:
                browser = _b.sent();
                if (!browser) {
                    sendParentMessage({
                        command: types_1.WorkerCommands.error,
                        data: "\u26A0\uFE0F Couldn't establish a connection \"" + browserWSEndpoint + "\". Is your browser running?",
                    });
                    return [2, self.close()];
                }
                browser.once('disconnected', function () {
                    sendParentMessage({ command: types_1.WorkerCommands.browserClose, data: null });
                    closeWorker();
                });
                return [4, browser.pages()];
            case 2:
                pages = _b.sent();
                console.log('pages:', pages);
                page = pages.find(function (p) { return p.target()._targetId === targetId; });
                if (!page) {
                    sendParentMessage({
                        command: types_1.WorkerCommands.error,
                        data: "\u26A0\uFE0F Couldn't find target with targetId " + targetId,
                    });
                    return [2, self.close()];
                }
                return [4, page.target().createCDPSession()];
            case 3:
                client = _b.sent();
                return [4, client.send('Page.startScreencast', { format: 'jpeg', quality: quality })];
            case 4:
                _b.sent();
                client.on('Page.screencastFrame', onScreencastFrame);
                sendParentMessage({
                    command: types_1.WorkerCommands.startComplete,
                    data: {
                        targetId: page.target()._targetId,
                    },
                });
                return [2];
        }
    });
}); };
var setViewport = function (data) {
    return page && page.setViewport(data);
};
self.addEventListener('message', function (message) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, command, data, protocolCommand;
    return __generator(this, function (_b) {
        _a = message.data, command = _a.command, data = _a.data;
        if (command === types_1.HostCommands.start) {
            return [2, start(data)];
        }
        if (command === types_1.HostCommands.setViewport) {
            return [2, setViewport(data)];
        }
        if (command === types_1.HostCommands.close) {
            return [2, closeWorker()];
        }
        if (protocolCommands.includes(command)) {
            if (!client)
                return [2];
            protocolCommand = command;
            return [2, client.send(protocolCommand, data)];
        }
        console.debug("Unknown worker command:", message);
        return [2];
    });
}); }, false);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVwcGV0ZWVyLndvcmtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wdXBwZXRlZXIud29ya2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EsNkVBQTJFO0FBRTNFLDZFQUE2RDtBQUU3RCxpQ0FBa0Y7QUFFbEYsSUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLHdCQUFnQixDQUFDLENBQUM7QUFFdkQsSUFBSSxPQUF1QixDQUFDO0FBQzVCLElBQUksSUFBaUIsQ0FBQztBQUN0QixJQUFJLE1BQXlCLENBQUM7QUFFOUIsSUFBTSxpQkFBaUIsR0FBRyxVQUFDLE9BQWdCO0lBR3pDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDO0FBaUJGLElBQU0sV0FBVyxHQUFHOztRQUNsQixJQUFJLE9BQU87WUFBRSxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsV0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUM7O0tBQ3JCLENBQUM7QUFFRixJQUFNLGlCQUFpQixHQUFHLFVBQUMsRUFRMUI7UUFQQyxJQUFJLFVBQUEsRUFDSixTQUFTLGVBQUEsRUFDVCxRQUFRLGNBQUE7SUFNUixPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ2hHLElBQUksTUFBTSxFQUFFO1FBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM3QixNQUFNO2FBQ0gsSUFBSSxDQUFDLHlCQUF5QixFQUFFLEVBQUUsU0FBUyxXQUFBLEVBQUUsQ0FBQzthQUM5QyxJQUFJLENBQUMsY0FBTSxPQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsU0FBUyxDQUFD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

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerCommands = exports.HostCommands = exports.ProtocolCommands = void 0;
var ProtocolCommands;
(function (ProtocolCommands) {
    ProtocolCommands["Input.dispatchKeyEvent"] = "Input.dispatchKeyEvent";
    ProtocolCommands["Input.emulateTouchFromMouseEvent"] = "Input.emulateTouchFromMouseEvent";
    ProtocolCommands["Page.reload"] = "Page.reload";
    ProtocolCommands["Page.navigateToHistoryEntry"] = "Page.navigateToHistoryEntry";
})(ProtocolCommands = exports.ProtocolCommands || (exports.ProtocolCommands = {}));
var HostCommands;
(function (HostCommands) {
    HostCommands["start"] = "start";
    HostCommands["run"] = "run";
    HostCommands["close"] = "close";
    HostCommands["setViewport"] = "setViewport";
})(HostCommands = exports.HostCommands || (exports.HostCommands = {}));
var WorkerCommands;
(function (WorkerCommands) {
    WorkerCommands["startComplete"] = "startComplete";
    WorkerCommands["runComplete"] = "runComplete";
    WorkerCommands["screencastFrame"] = "screencastFrame";
    WorkerCommands["browserClose"] = "browserClose";
    WorkerCommands["error"] = "error";
})(WorkerCommands = exports.WorkerCommands || (exports.WorkerCommands = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsSUFBWSxnQkFLWDtBQUxELFdBQVksZ0JBQWdCO0lBQzFCLHFFQUFtRCxDQUFBO0lBQ25ELHlGQUF1RSxDQUFBO0lBQ3ZFLCtDQUE2QixDQUFBO0lBQzdCLCtFQUE2RCxDQUFBO0FBQy9ELENBQUMsRUFMVyxnQkFBZ0IsR0FBaEIsd0JBQWdCLEtBQWhCLHdCQUFnQixRQUszQjtBQUVELElBQVksWUFLWDtBQUxELFdBQVksWUFBWTtJQUN0QiwrQkFBaUIsQ0FBQTtJQUNqQiwyQkFBYSxDQUFBO0lBQ2IsK0JBQWlCLENBQUE7SUFDakIsMkNBQTZCLENBQUE7QUFDL0IsQ0FBQyxFQUxXLFlBQVksR0FBWixvQkFBWSxLQUFaLG9CQUFZLFFBS3ZCO0FBRUQsSUFBWSxjQU1YO0FBTkQsV0FBWSxjQUFjO0lBQ3hCLGlEQUFpQyxDQUFBO0lBQ2pDLDZDQUE2QixDQUFBO0lBQzdCLHFEQUFxQyxDQUFBO0lBQ3JDLCtDQUErQixDQUFBO0lBQy9CLGlDQUFpQixDQUFBO0FBQ25CLENBQUMsRUFOVyxjQUFjLEdBQWQsc0JBQWMsS0FBZCxzQkFBYyxRQU16QiJ9

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"puppeteer.worker": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkpuppeteer_extra_plugin_portal_frontend"] = self["webpackChunkpuppeteer_extra_plugin_portal_frontend"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/puppeteer.worker.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9BY2Nlc3NpYmlsaXR5LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9BcmlhUXVlcnlIYW5kbGVyLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Ccm93c2VyLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Ccm93c2VyQ29ubmVjdG9yLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Ccm93c2VyV2ViU29ja2V0VHJhbnNwb3J0LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Db25uZWN0aW9uLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Db25zb2xlTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vQ292ZXJhZ2UuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0RPTVdvcmxkLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9EZWJ1Zy5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vRGV2aWNlRGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0RpYWxvZy5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vRW11bGF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vRXJyb3JzLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0V4ZWN1dGlvbkNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0ZpbGVDaG9vc2VyLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9GcmFtZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0hUVFBSZXF1ZXN0LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9IVFRQUmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL0lucHV0LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9KU0hhbmRsZS5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vTGlmZWN5Y2xlV2F0Y2hlci5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vTmV0d29ya0NvbmRpdGlvbnMuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL05ldHdvcmtNYW5hZ2VyLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9QREZPcHRpb25zLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9QYWdlLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9QdXBwZXRlZXIuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL1F1ZXJ5SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vU2VjdXJpdHlEZXRhaWxzLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9UYXJnZXQuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL1RpbWVvdXRTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vVHJhY2luZy5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vVVNLZXlib2FyZExheW91dC5qcyIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9jb21tb24vV2ViV29ya2VyLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvY29tbW9uL2ZldGNoLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvZW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvaW5pdGlhbGl6ZS13ZWIuanMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvd2ViLmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vdmVuZG9yL21pdHQvc3JjL2luZGV4LmpzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kLy4vc3JjL3B1cHBldGVlci53b3JrZXIudHMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvLi9zcmMvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2NyZWF0ZSBmYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wdXBwZXRlZXItZXh0cmEtcGx1Z2luLXBvcnRhbC1mcm9udGVuZC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3B1cHBldGVlci1leHRyYS1wbHVnaW4tcG9ydGFsLWZyb250ZW5kL3dlYnBhY2svcnVudGltZS9pbXBvcnRTY3JpcHRzIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vcHVwcGV0ZWVyLWV4dHJhLXBsdWdpbi1wb3J0YWwtZnJvbnRlbmQvd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNZO0FBQ1M7QUFDZjtBQUNvQjtBQUNwQjtBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixrQkFBa0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUM7QUFDdkMsZUFBZSw2RUFBNkU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QixrRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGFBQWEsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0Msd0NBQXdDLFFBQVE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3Q0FBd0Msd0NBQXdDLFFBQVE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLEdBQUcsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGVBQWUsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxHQUFHLGVBQWUsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRCxlQUFlLFdBQVc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0QsZUFBZSxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0RBQW9ELGVBQWUsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVyxtQkFBbUIsYUFBYSxlQUFlLEtBQUssT0FBTyxPQUFPO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFdBQVcsbUJBQW1CLGFBQWEsZUFBZSxLQUFLLE9BQU8sT0FBTztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDOzs7Ozs7Ozs7Ozs7Ozs7O0FDbjdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDckM7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQzs7Ozs7Ozs7Ozs7Ozs7O0FDN0ZPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixPQUFPLDhDQUE4QztBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ2tEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkI7QUFDeEUsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNBO0FBQ29CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZO0FBQ1o7QUFDQSxNQUFNLDZCQUE2QjtBQUNuQyxNQUFNLDBEQUEwRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RCxZQUFZLHVEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0RBQXdELGtFQUEwQjtBQUNsRjtBQUNBLGtCQUFrQixvRUFBNEI7QUFDOUMsa0JBQWtCLDREQUFjO0FBQ2hDO0FBQ0E7QUFDQSxzR0FBc0csYUFBYTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQ7QUFDQSxvREFBb0Qsa0VBQTBCO0FBQzlFO0FBQ0EsY0FBYyxvRUFBNEI7QUFDMUMsY0FBYyw0REFBYztBQUM1QjtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCLGVBQWU7QUFDaEU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEIsdURBQXVELGtEQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVSxvQkFBb0I7QUFDdEQ7QUFDQSx3QkFBd0IsVUFBVSxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLDREQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLDREQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9HQUFvRztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwRkFBMEY7QUFDekk7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSx1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDTTtBQUNaO0FBQ1k7QUFDK0I7QUFDdEI7QUFDakI7QUFDWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQiwwREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4REFBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGVBQWUsMklBQTJJO0FBQzFKLDRCQUE0QixrRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQixNQUFNLElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxlQUFlLDZFQUE2RTtBQUM1Riw0QkFBNEIsa0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSyxrQ0FBa0MsMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUVBQXFCLENBQUM7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixrREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0NBQXNDO0FBQzFDLElBQUksNENBQTRDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFRO0FBQ3RDLG1DQUFtQyxrREFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUZBQWlGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQU07QUFDVixJQUFJLGtEQUFNO0FBQ1YsSUFBSSxrREFBTTtBQUNWO0FBQ0Esd0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDLzdCcUM7QUFDWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRDtXQUN0RCxxQ0FBcUMsaUVBQWlFO1dBQ3RHO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0YsRTs7Ozs7V0NSQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEU7Ozs7O1dDSkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBLENBQUMsSTs7Ozs7V0NQRCx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxrQzs7Ozs7V0NmQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsWUFBWTtXQUNaO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQSxrQjs7Ozs7VUNwQ0E7VUFDQTtVQUNBO1VBQ0EiLCJmaWxlIjoicHVwcGV0ZWVyLndvcmtlci5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiBlbmFibGVPdmVycmlkZSA9PT0gbnVsbCA/IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKSA6IGVuYWJsZU92ZXJyaWRlLFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgQWNjZXNzaWJpbGl0eSBjbGFzcyBwcm92aWRlcyBtZXRob2RzIGZvciBpbnNwZWN0aW5nIENocm9taXVtJ3NcbiAqIGFjY2Vzc2liaWxpdHkgdHJlZS4gVGhlIGFjY2Vzc2liaWxpdHkgdHJlZSBpcyB1c2VkIGJ5IGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gKiBzdWNoIGFzIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY3JlZW5fcmVhZGVyIHwgc2NyZWVuIHJlYWRlcnN9IG9yXG4gKiB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3dpdGNoX2FjY2VzcyB8IHN3aXRjaGVzfS5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIEFjY2Vzc2liaWxpdHkgaXMgYSB2ZXJ5IHBsYXRmb3JtLXNwZWNpZmljIHRoaW5nLiBPbiBkaWZmZXJlbnQgcGxhdGZvcm1zLFxuICogdGhlcmUgYXJlIGRpZmZlcmVudCBzY3JlZW4gcmVhZGVycyB0aGF0IG1pZ2h0IGhhdmUgd2lsZGx5IGRpZmZlcmVudCBvdXRwdXQuXG4gKlxuICogQmxpbmsgLSBDaHJvbWUncyByZW5kZXJpbmcgZW5naW5lIC0gaGFzIGEgY29uY2VwdCBvZiBcImFjY2Vzc2liaWxpdHkgdHJlZVwiLFxuICogd2hpY2ggaXMgdGhlbiB0cmFuc2xhdGVkIGludG8gZGlmZmVyZW50IHBsYXRmb3JtLXNwZWNpZmljIEFQSXMuIEFjY2Vzc2liaWxpdHlcbiAqIG5hbWVzcGFjZSBnaXZlcyB1c2VycyBhY2Nlc3MgdG8gdGhlIEJsaW5rIEFjY2Vzc2liaWxpdHkgVHJlZS5cbiAqXG4gKiBNb3N0IG9mIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWUgZ2V0cyBmaWx0ZXJlZCBvdXQgd2hlbiBjb252ZXJ0aW5nIGZyb20gQmxpbmtcbiAqIEFYIFRyZWUgdG8gUGxhdGZvcm0tc3BlY2lmaWMgQVgtVHJlZSBvciBieSBhc3Npc3RpdmUgdGVjaG5vbG9naWVzIHRoZW1zZWx2ZXMuXG4gKiBCeSBkZWZhdWx0LCBQdXBwZXRlZXIgdHJpZXMgdG8gYXBwcm94aW1hdGUgdGhpcyBmaWx0ZXJpbmcsIGV4cG9zaW5nIG9ubHlcbiAqIHRoZSBcImludGVyZXN0aW5nXCIgbm9kZXMgb2YgdGhlIHRyZWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQWNjZXNzaWJpbGl0eSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGFjY2Vzc2liaWxpdHkgdHJlZS5cbiAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHJvb3QgYWNjZXNzaWJsZSBub2RlIG9mIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoZSBDaHJvbWl1bSBhY2Nlc3NpYmlsaXR5IHRyZWUgY29udGFpbnMgbm9kZXMgdGhhdCBnbyB1bnVzZWQgb25cbiAgICAgKiBtb3N0IHBsYXRmb3JtcyBhbmQgYnkgbW9zdCBzY3JlZW4gcmVhZGVycy4gUHVwcGV0ZWVyIHdpbGwgZGlzY2FyZCB0aGVtIGFzXG4gICAgICogd2VsbCBmb3IgYW4gZWFzaWVyIHRvIHByb2Nlc3MgdHJlZSwgdW5sZXNzIGBpbnRlcmVzdGluZ09ubHlgIGlzIHNldCB0b1xuICAgICAqIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEFuIGV4YW1wbGUgb2YgZHVtcGluZyB0aGUgZW50aXJlIGFjY2Vzc2liaWxpdHkgdHJlZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgcGFnZS5hY2Nlc3NpYmlsaXR5LnNuYXBzaG90KCk7XG4gICAgICogY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBBbiBleGFtcGxlIG9mIGxvZ2dpbmcgdGhlIGZvY3VzZWQgbm9kZSdzIG5hbWU6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHBhZ2UuYWNjZXNzaWJpbGl0eS5zbmFwc2hvdCgpO1xuICAgICAqIGNvbnN0IG5vZGUgPSBmaW5kRm9jdXNlZE5vZGUoc25hcHNob3QpO1xuICAgICAqIGNvbnNvbGUubG9nKG5vZGUgJiYgbm9kZS5uYW1lKTtcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGZpbmRGb2N1c2VkTm9kZShub2RlKSB7XG4gICAgICogICBpZiAobm9kZS5mb2N1c2VkKVxuICAgICAqICAgICByZXR1cm4gbm9kZTtcbiAgICAgKiAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbiB8fCBbXSkge1xuICAgICAqICAgICBjb25zdCBmb3VuZE5vZGUgPSBmaW5kRm9jdXNlZE5vZGUoY2hpbGQpO1xuICAgICAqICAgICByZXR1cm4gZm91bmROb2RlO1xuICAgICAqICAgfVxuICAgICAqICAgcmV0dXJuIG51bGw7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gQVhOb2RlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNuYXBzaG90LlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgc25hcHNob3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaW50ZXJlc3RpbmdPbmx5ID0gdHJ1ZSwgcm9vdCA9IG51bGwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdBY2Nlc3NpYmlsaXR5LmdldEZ1bGxBWFRyZWUnKTtcbiAgICAgICAgbGV0IGJhY2tlbmROb2RlSWQgPSBudWxsO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRE9NLmRlc2NyaWJlTm9kZScsIHtcbiAgICAgICAgICAgICAgICBvYmplY3RJZDogcm9vdC5fcmVtb3RlT2JqZWN0Lm9iamVjdElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYWNrZW5kTm9kZUlkID0gbm9kZS5iYWNrZW5kTm9kZUlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRSb290ID0gQVhOb2RlLmNyZWF0ZVRyZWUobm9kZXMpO1xuICAgICAgICBsZXQgbmVlZGxlID0gZGVmYXVsdFJvb3Q7XG4gICAgICAgIGlmIChiYWNrZW5kTm9kZUlkKSB7XG4gICAgICAgICAgICBuZWVkbGUgPSBkZWZhdWx0Um9vdC5maW5kKChub2RlKSA9PiBub2RlLnBheWxvYWQuYmFja2VuZERPTU5vZGVJZCA9PT0gYmFja2VuZE5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoIW5lZWRsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyZXN0aW5nT25seSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVRyZWUobmVlZGxlKVswXTtcbiAgICAgICAgY29uc3QgaW50ZXJlc3RpbmdOb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0SW50ZXJlc3RpbmdOb2RlcyhpbnRlcmVzdGluZ05vZGVzLCBkZWZhdWx0Um9vdCwgZmFsc2UpO1xuICAgICAgICBpZiAoIWludGVyZXN0aW5nTm9kZXMuaGFzKG5lZWRsZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplVHJlZShuZWVkbGUsIGludGVyZXN0aW5nTm9kZXMpWzBdO1xuICAgIH1cbiAgICBzZXJpYWxpemVUcmVlKG5vZGUsIGludGVyZXN0aW5nTm9kZXMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCguLi50aGlzLnNlcmlhbGl6ZVRyZWUoY2hpbGQsIGludGVyZXN0aW5nTm9kZXMpKTtcbiAgICAgICAgaWYgKGludGVyZXN0aW5nTm9kZXMgJiYgIWludGVyZXN0aW5nTm9kZXMuaGFzKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuc2VyaWFsaXplKCk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZWROb2RlXTtcbiAgICB9XG4gICAgY29sbGVjdEludGVyZXN0aW5nTm9kZXMoY29sbGVjdGlvbiwgbm9kZSwgaW5zaWRlQ29udHJvbCkge1xuICAgICAgICBpZiAobm9kZS5pc0ludGVyZXN0aW5nKGluc2lkZUNvbnRyb2wpKVxuICAgICAgICAgICAgY29sbGVjdGlvbi5hZGQobm9kZSk7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZk5vZGUoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5zaWRlQ29udHJvbCA9IGluc2lkZUNvbnRyb2wgfHwgbm9kZS5pc0NvbnRyb2woKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0SW50ZXJlc3RpbmdOb2Rlcyhjb2xsZWN0aW9uLCBjaGlsZCwgaW5zaWRlQ29udHJvbCk7XG4gICAgfVxufVxuY2xhc3MgQVhOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5fcmljaGx5RWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZm9jdXNhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLl9uYW1lID0gdGhpcy5wYXlsb2FkLm5hbWUgPyB0aGlzLnBheWxvYWQubmFtZS52YWx1ZSA6ICcnO1xuICAgICAgICB0aGlzLl9yb2xlID0gdGhpcy5wYXlsb2FkLnJvbGUgPyB0aGlzLnBheWxvYWQucm9sZS52YWx1ZSA6ICdVbmtub3duJztcbiAgICAgICAgdGhpcy5faWdub3JlZCA9IHRoaXMucGF5bG9hZC5pZ25vcmVkO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHRoaXMucGF5bG9hZC5wcm9wZXJ0aWVzIHx8IFtdKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkubmFtZSA9PT0gJ2VkaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JpY2hseUVkaXRhYmxlID0gcHJvcGVydHkudmFsdWUudmFsdWUgPT09ICdyaWNodGV4dCc7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWRpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Lm5hbWUgPT09ICdmb2N1c2FibGUnKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzYWJsZSA9IHByb3BlcnR5LnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5Lm5hbWUgPT09ICdoaWRkZW4nKVxuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGRlbiA9IHByb3BlcnR5LnZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1BsYWluVGV4dEZpZWxkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmljaGx5RWRpdGFibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0YWJsZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9sZSA9PT0gJ3RleHRib3gnIHx8IHRoaXMuX3JvbGUgPT09ICdzZWFyY2hib3gnO1xuICAgIH1cbiAgICBfaXNUZXh0T25seU9iamVjdCgpIHtcbiAgICAgICAgY29uc3Qgcm9sZSA9IHRoaXMuX3JvbGU7XG4gICAgICAgIHJldHVybiByb2xlID09PSAnTGluZUJyZWFrJyB8fCByb2xlID09PSAndGV4dCcgfHwgcm9sZSA9PT0gJ0lubGluZVRleHRCb3gnO1xuICAgIH1cbiAgICBfaGFzRm9jdXNhYmxlQ2hpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRIYXNGb2N1c2FibGVDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRIYXNGb2N1c2FibGVDaGlsZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLl9mb2N1c2FibGUgfHwgY2hpbGQuX2hhc0ZvY3VzYWJsZUNoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkSGFzRm9jdXNhYmxlQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEhhc0ZvY3VzYWJsZUNoaWxkO1xuICAgIH1cbiAgICBmaW5kKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlKHRoaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuZmluZChwcmVkaWNhdGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc0xlYWZOb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFRoZXNlIHR5cGVzIG9mIG9iamVjdHMgbWF5IGhhdmUgY2hpbGRyZW4gdGhhdCB3ZSB1c2UgYXMgaW50ZXJuYWxcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgYnV0IHdlIHdhbnQgdG8gZXhwb3NlIHRoZW0gYXMgbGVhdmVzIHRvIHBsYXRmb3JtXG4gICAgICAgIC8vIGFjY2Vzc2liaWxpdHkgQVBJcyBiZWNhdXNlIHNjcmVlbiByZWFkZXJzIG1pZ2h0IGJlIGNvbmZ1c2VkIGlmIHRoZXkgZmluZFxuICAgICAgICAvLyBhbnkgY2hpbGRyZW4uXG4gICAgICAgIGlmICh0aGlzLl9pc1BsYWluVGV4dEZpZWxkKCkgfHwgdGhpcy5faXNUZXh0T25seU9iamVjdCgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFJvbGVzIHdob3NlIGNoaWxkcmVuIGFyZSBvbmx5IHByZXNlbnRhdGlvbmFsIGFjY29yZGluZyB0byB0aGUgQVJJQSBhbmRcbiAgICAgICAgLy8gSFRNTDUgU3BlY3Mgc2hvdWxkIGJlIGhpZGRlbiBmcm9tIHNjcmVlbiByZWFkZXJzLlxuICAgICAgICAvLyAoTm90ZSB0aGF0IHdoaWxzdCBBUklBIGJ1dHRvbnMgY2FuIGhhdmUgb25seSBwcmVzZW50YXRpb25hbCBjaGlsZHJlbiwgSFRNTDVcbiAgICAgICAgLy8gYnV0dG9ucyBhcmUgYWxsb3dlZCB0byBoYXZlIGNvbnRlbnQuKVxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1jb3Zlcic6XG4gICAgICAgICAgICBjYXNlICdncmFwaGljcy1zeW1ib2wnOlxuICAgICAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIGNhc2UgJ01ldGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3Njcm9sbGJhcic6XG4gICAgICAgICAgICBjYXNlICdzbGlkZXInOlxuICAgICAgICAgICAgY2FzZSAnc2VwYXJhdG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzYmFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGVyZSBhbmQgYmVsb3c6IEFuZHJvaWQgaGV1cmlzdGljc1xuICAgICAgICBpZiAodGhpcy5faGFzRm9jdXNhYmxlQ2hpbGQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzYWJsZSAmJiB0aGlzLl9uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9yb2xlID09PSAnaGVhZGluZycgJiYgdGhpcy5fbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQ29udHJvbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9yb2xlKSB7XG4gICAgICAgICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgY2FzZSAnQ29sb3JXZWxsJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAgICAgIGNhc2UgJ0Rpc2Nsb3N1cmVUcmlhbmdsZSc6XG4gICAgICAgICAgICBjYXNlICdsaXN0Ym94JzpcbiAgICAgICAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgICAgICAgY2FzZSAnbWVudWJhcic6XG4gICAgICAgICAgICBjYXNlICdtZW51aXRlbSc6XG4gICAgICAgICAgICBjYXNlICdtZW51aXRlbWNoZWNrYm94JzpcbiAgICAgICAgICAgIGNhc2UgJ21lbnVpdGVtcmFkaW8nOlxuICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsYmFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlYXJjaGJveCc6XG4gICAgICAgICAgICBjYXNlICdzbGlkZXInOlxuICAgICAgICAgICAgY2FzZSAnc3BpbmJ1dHRvbic6XG4gICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICAgICAgY2FzZSAndGFiJzpcbiAgICAgICAgICAgIGNhc2UgJ3RleHRib3gnOlxuICAgICAgICAgICAgY2FzZSAndHJlZSc6XG4gICAgICAgICAgICBjYXNlICd0cmVlaXRlbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0ludGVyZXN0aW5nKGluc2lkZUNvbnRyb2wpIHtcbiAgICAgICAgY29uc3Qgcm9sZSA9IHRoaXMuX3JvbGU7XG4gICAgICAgIGlmIChyb2xlID09PSAnSWdub3JlZCcgfHwgdGhpcy5faGlkZGVuIHx8IHRoaXMuX2lnbm9yZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c2FibGUgfHwgdGhpcy5fcmljaGx5RWRpdGFibGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgZm9jdXNhYmxlIGJ1dCBoYXMgYSBjb250cm9sIHJvbGUsIHRoZW4gaXQncyBpbnRlcmVzdGluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNDb250cm9sKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQSBub24gZm9jdXNhYmxlIGNoaWxkIG9mIGEgY29udHJvbCBpcyBub3QgaW50ZXJlc3RpbmdcbiAgICAgICAgaWYgKGluc2lkZUNvbnRyb2wpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGVhZk5vZGUoKSAmJiAhIXRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnBheWxvYWQucHJvcGVydGllcyB8fCBbXSlcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc2V0KHByb3BlcnR5Lm5hbWUudG9Mb3dlckNhc2UoKSwgcHJvcGVydHkudmFsdWUudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5wYXlsb2FkLm5hbWUpXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNldCgnbmFtZScsIHRoaXMucGF5bG9hZC5uYW1lLnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMucGF5bG9hZC52YWx1ZSlcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc2V0KCd2YWx1ZScsIHRoaXMucGF5bG9hZC52YWx1ZS52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnBheWxvYWQuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNldCgnZGVzY3JpcHRpb24nLCB0aGlzLnBheWxvYWQuZGVzY3JpcHRpb24udmFsdWUpO1xuICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgcm9sZTogdGhpcy5fcm9sZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXNlclN0cmluZ1Byb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAndmFsdWUnLFxuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdrZXlzaG9ydGN1dHMnLFxuICAgICAgICAgICAgJ3JvbGVkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAndmFsdWV0ZXh0JyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZ2V0VXNlclN0cmluZ1Byb3BlcnR5VmFsdWUgPSAoa2V5KSA9PiBwcm9wZXJ0aWVzLmdldChrZXkpO1xuICAgICAgICBmb3IgKGNvbnN0IHVzZXJTdHJpbmdQcm9wZXJ0eSBvZiB1c2VyU3RyaW5nUHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzLmhhcyh1c2VyU3RyaW5nUHJvcGVydHkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbm9kZVt1c2VyU3RyaW5nUHJvcGVydHldID0gZ2V0VXNlclN0cmluZ1Byb3BlcnR5VmFsdWUodXNlclN0cmluZ1Byb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib29sZWFuUHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAnZXhwYW5kZWQnLFxuICAgICAgICAgICAgJ2ZvY3VzZWQnLFxuICAgICAgICAgICAgJ21vZGFsJyxcbiAgICAgICAgICAgICdtdWx0aWxpbmUnLFxuICAgICAgICAgICAgJ211bHRpc2VsZWN0YWJsZScsXG4gICAgICAgICAgICAncmVhZG9ubHknLFxuICAgICAgICAgICAgJ3JlcXVpcmVkJyxcbiAgICAgICAgICAgICdzZWxlY3RlZCcsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGdldEJvb2xlYW5Qcm9wZXJ0eVZhbHVlID0gKGtleSkgPT4gcHJvcGVydGllcy5nZXQoa2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBib29sZWFuUHJvcGVydHkgb2YgYm9vbGVhblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIC8vIFJvb3RXZWJBcmVhJ3MgdHJlYXQgZm9jdXMgZGlmZmVyZW50bHkgdGhhbiBvdGhlciBub2Rlcy4gVGhleSByZXBvcnQgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlaXIgZnJhbWUgIGhhcyBmb2N1cywgbm90IHdoZXRoZXIgZm9jdXMgaXMgc3BlY2lmaWNhbGx5IG9uIHRoZSByb290XG4gICAgICAgICAgICAvLyBub2RlLlxuICAgICAgICAgICAgaWYgKGJvb2xlYW5Qcm9wZXJ0eSA9PT0gJ2ZvY3VzZWQnICYmIHRoaXMuX3JvbGUgPT09ICdSb290V2ViQXJlYScpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJvb2xlYW5Qcm9wZXJ0eVZhbHVlKGJvb2xlYW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbm9kZVtib29sZWFuUHJvcGVydHldID0gZ2V0Qm9vbGVhblByb3BlcnR5VmFsdWUoYm9vbGVhblByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmlzdGF0ZVByb3BlcnRpZXMgPSBbJ2NoZWNrZWQnLCAncHJlc3NlZCddO1xuICAgICAgICBmb3IgKGNvbnN0IHRyaXN0YXRlUHJvcGVydHkgb2YgdHJpc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXMuaGFzKHRyaXN0YXRlUHJvcGVydHkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wZXJ0aWVzLmdldCh0cmlzdGF0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgIG5vZGVbdHJpc3RhdGVQcm9wZXJ0eV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlID09PSAnbWl4ZWQnID8gJ21peGVkJyA6IHZhbHVlID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtZXJpY2FsUHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICdsZXZlbCcsXG4gICAgICAgICAgICAndmFsdWVtYXgnLFxuICAgICAgICAgICAgJ3ZhbHVlbWluJyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZ2V0TnVtZXJpY2FsUHJvcGVydHlWYWx1ZSA9IChrZXkpID0+IHByb3BlcnRpZXMuZ2V0KGtleSk7XG4gICAgICAgIGZvciAoY29uc3QgbnVtZXJpY2FsUHJvcGVydHkgb2YgbnVtZXJpY2FsUHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzLmhhcyhudW1lcmljYWxQcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBub2RlW251bWVyaWNhbFByb3BlcnR5XSA9IGdldE51bWVyaWNhbFByb3BlcnR5VmFsdWUobnVtZXJpY2FsUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuUHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICdhdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgJ2hhc3BvcHVwJyxcbiAgICAgICAgICAgICdpbnZhbGlkJyxcbiAgICAgICAgICAgICdvcmllbnRhdGlvbicsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGdldFRva2VuUHJvcGVydHlWYWx1ZSA9IChrZXkpID0+IHByb3BlcnRpZXMuZ2V0KGtleSk7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW5Qcm9wZXJ0eSBvZiB0b2tlblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VG9rZW5Qcm9wZXJ0eVZhbHVlKHRva2VuUHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGVbdG9rZW5Qcm9wZXJ0eV0gPSBnZXRUb2tlblByb3BlcnR5VmFsdWUodG9rZW5Qcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVUcmVlKHBheWxvYWRzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVCeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcGF5bG9hZHMpXG4gICAgICAgICAgICBub2RlQnlJZC5zZXQocGF5bG9hZC5ub2RlSWQsIG5ldyBBWE5vZGUocGF5bG9hZCkpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUJ5SWQudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBub2RlLnBheWxvYWQuY2hpbGRJZHMgfHwgW10pXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5vZGVCeUlkLmdldChjaGlsZElkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVCeUlkLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NpYmlsaXR5LmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5QVhUcmVlKGNsaWVudCwgZWxlbWVudCwgYWNjZXNzaWJsZU5hbWUsIHJvbGUpIHtcbiAgICBjb25zdCB7IG5vZGVzIH0gPSBhd2FpdCBjbGllbnQuc2VuZCgnQWNjZXNzaWJpbGl0eS5xdWVyeUFYVHJlZScsIHtcbiAgICAgICAgb2JqZWN0SWQ6IGVsZW1lbnQuX3JlbW90ZU9iamVjdC5vYmplY3RJZCxcbiAgICAgICAgYWNjZXNzaWJsZU5hbWUsXG4gICAgICAgIHJvbGUsXG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyZWROb2RlcyA9IG5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5yb2xlLnZhbHVlICE9PSAnU3RhdGljVGV4dCcpO1xuICAgIHJldHVybiBmaWx0ZXJlZE5vZGVzO1xufVxuZnVuY3Rpb24gcGFyc2VBcmlhU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBjb25zdCBub3JtYWxpemUgPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoLyArL2csICcgJykudHJpbSgpO1xuICAgIGNvbnN0IGtub3duQXR0cmlidXRlcyA9IG5ldyBTZXQoWyduYW1lJywgJ3JvbGUnXSk7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlUmVnZXhwID0gL1xcW1xccyooPzxhdHRyaWJ1dGU+XFx3KylcXHMqPVxccypcIig/PHZhbHVlPlxcXFwufFteXCJcXFxcXSopXCJcXHMqXFxdL2c7XG4gICAgY29uc3QgZGVmYXVsdE5hbWUgPSBzZWxlY3Rvci5yZXBsYWNlKGF0dHJpYnV0ZVJlZ2V4cCwgKF8sIGF0dHJpYnV0ZSwgdmFsdWUpID0+IHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlLnRyaW0oKTtcbiAgICAgICAgaWYgKCFrbm93bkF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXJpYSBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZX1cIiBpbiBzZWxlY3RvcmApO1xuICAgICAgICBxdWVyeU9wdGlvbnNbYXR0cmlidXRlXSA9IG5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICBpZiAoZGVmYXVsdE5hbWUgJiYgIXF1ZXJ5T3B0aW9ucy5uYW1lKVxuICAgICAgICBxdWVyeU9wdGlvbnMubmFtZSA9IG5vcm1hbGl6ZShkZWZhdWx0TmFtZSk7XG4gICAgcmV0dXJuIHF1ZXJ5T3B0aW9ucztcbn1cbmNvbnN0IHF1ZXJ5T25lID0gYXN5bmMgKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgZXhlQ3R4ID0gZWxlbWVudC5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgY29uc3QgeyBuYW1lLCByb2xlIH0gPSBwYXJzZUFyaWFTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnlBWFRyZWUoZXhlQ3R4Ll9jbGllbnQsIGVsZW1lbnQsIG5hbWUsIHJvbGUpO1xuICAgIGlmIChyZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4ZUN0eC5fYWRvcHRCYWNrZW5kTm9kZUlkKHJlc1swXS5iYWNrZW5kRE9NTm9kZUlkKTtcbn07XG5jb25zdCB3YWl0Rm9yID0gYXN5bmMgKGRvbVdvcmxkLCBzZWxlY3Rvciwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICAgIG5hbWU6ICdhcmlhUXVlcnlTZWxlY3RvcicsXG4gICAgICAgIHBwdHJGdW5jdGlvbjogYXN5bmMgKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IGRvbVdvcmxkLl9kb2N1bWVudCgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGF3YWl0IHF1ZXJ5T25lKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBkb21Xb3JsZC53YWl0Rm9yU2VsZWN0b3JJblBhZ2UoKF8sIHNlbGVjdG9yKSA9PiBnbG9iYWxUaGlzLmFyaWFRdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSwgc2VsZWN0b3IsIG9wdGlvbnMsIGJpbmRpbmcpO1xufTtcbmNvbnN0IHF1ZXJ5QWxsID0gYXN5bmMgKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgZXhlQ3R4ID0gZWxlbWVudC5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgY29uc3QgeyBuYW1lLCByb2xlIH0gPSBwYXJzZUFyaWFTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnlBWFRyZWUoZXhlQ3R4Ll9jbGllbnQsIGVsZW1lbnQsIG5hbWUsIHJvbGUpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChyZXMubWFwKChheE5vZGUpID0+IGV4ZUN0eC5fYWRvcHRCYWNrZW5kTm9kZUlkKGF4Tm9kZS5iYWNrZW5kRE9NTm9kZUlkKSkpO1xufTtcbmNvbnN0IHF1ZXJ5QWxsQXJyYXkgPSBhc3luYyAoZWxlbWVudCwgc2VsZWN0b3IpID0+IHtcbiAgICBjb25zdCBlbGVtZW50SGFuZGxlcyA9IGF3YWl0IHF1ZXJ5QWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICBjb25zdCBleGVDdHggPSBlbGVtZW50LmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICBjb25zdCBqc0hhbmRsZSA9IGV4ZUN0eC5ldmFsdWF0ZUhhbmRsZSgoLi4uZWxlbWVudHMpID0+IGVsZW1lbnRzLCAuLi5lbGVtZW50SGFuZGxlcyk7XG4gICAgcmV0dXJuIGpzSGFuZGxlO1xufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBhcmlhSGFuZGxlciA9IHtcbiAgICBxdWVyeU9uZSxcbiAgICB3YWl0Rm9yLFxuICAgIHF1ZXJ5QWxsLFxuICAgIHF1ZXJ5QWxsQXJyYXksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJpYVF1ZXJ5SGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBUYXJnZXQgfSBmcm9tICcuL1RhcmdldC5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uRW1pdHRlZEV2ZW50cyB9IGZyb20gJy4vQ29ubmVjdGlvbi5qcyc7XG5jb25zdCBXRUJfUEVSTUlTU0lPTl9UT19QUk9UT0NPTF9QRVJNSVNTSU9OID0gbmV3IE1hcChbXG4gICAgWydnZW9sb2NhdGlvbicsICdnZW9sb2NhdGlvbiddLFxuICAgIFsnbWlkaScsICdtaWRpJ10sXG4gICAgWydub3RpZmljYXRpb25zJywgJ25vdGlmaWNhdGlvbnMnXSxcbiAgICAvLyBUT0RPOiBwdXNoIGlzbid0IGEgdmFsaWQgdHlwZT9cbiAgICAvLyBbJ3B1c2gnLCAncHVzaCddLFxuICAgIFsnY2FtZXJhJywgJ3ZpZGVvQ2FwdHVyZSddLFxuICAgIFsnbWljcm9waG9uZScsICdhdWRpb0NhcHR1cmUnXSxcbiAgICBbJ2JhY2tncm91bmQtc3luYycsICdiYWNrZ3JvdW5kU3luYyddLFxuICAgIFsnYW1iaWVudC1saWdodC1zZW5zb3InLCAnc2Vuc29ycyddLFxuICAgIFsnYWNjZWxlcm9tZXRlcicsICdzZW5zb3JzJ10sXG4gICAgWydneXJvc2NvcGUnLCAnc2Vuc29ycyddLFxuICAgIFsnbWFnbmV0b21ldGVyJywgJ3NlbnNvcnMnXSxcbiAgICBbJ2FjY2Vzc2liaWxpdHktZXZlbnRzJywgJ2FjY2Vzc2liaWxpdHlFdmVudHMnXSxcbiAgICBbJ2NsaXBib2FyZC1yZWFkJywgJ2NsaXBib2FyZFJlYWRXcml0ZSddLFxuICAgIFsnY2xpcGJvYXJkLXdyaXRlJywgJ2NsaXBib2FyZFJlYWRXcml0ZSddLFxuICAgIFsncGF5bWVudC1oYW5kbGVyJywgJ3BheW1lbnRIYW5kbGVyJ10sXG4gICAgWydpZGxlLWRldGVjdGlvbicsICdpZGxlRGV0ZWN0aW9uJ10sXG4gICAgLy8gY2hyb21lLXNwZWNpZmljIHBlcm1pc3Npb25zIHdlIGhhdmUuXG4gICAgWydtaWRpLXN5c2V4JywgJ21pZGlTeXNleCddLFxuXSk7XG4vKipcbiAqIEEgQnJvd3NlciBpcyBjcmVhdGVkIHdoZW4gUHVwcGV0ZWVyIGNvbm5lY3RzIHRvIGEgQ2hyb21pdW0gaW5zdGFuY2UsIGVpdGhlciB0aHJvdWdoXG4gKiB7QGxpbmsgUHVwcGV0ZWVyTm9kZS5sYXVuY2h9IG9yIHtAbGluayBQdXBwZXRlZXIuY29ubmVjdH0uXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBUaGUgQnJvd3NlciBjbGFzcyBleHRlbmRzIGZyb20gUHVwcGV0ZWVyJ3Mge0BsaW5rIEV2ZW50RW1pdHRlcn0gY2xhc3MgYW5kIHdpbGxcbiAqIGVtaXQgdmFyaW91cyBldmVudHMgd2hpY2ggYXJlIGRvY3VtZW50ZWQgaW4gdGhlIHtAbGluayBCcm93c2VyRW1pdHRlZEV2ZW50c30gZW51bS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEFuIGV4YW1wbGUgb2YgdXNpbmcgYSB7QGxpbmsgQnJvd3Nlcn0gdG8gY3JlYXRlIGEge0BsaW5rIFBhZ2V9OlxuICogYGBganNcbiAqIGNvbnN0IHB1cHBldGVlciA9IHJlcXVpcmUoJ3B1cHBldGVlcicpO1xuICpcbiAqIChhc3luYyAoKSA9PiB7XG4gKiAgIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKCk7XG4gKiAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAqICAgYXdhaXQgcGFnZS5nb3RvKCdodHRwczovL2V4YW1wbGUuY29tJyk7XG4gKiAgIGF3YWl0IGJyb3dzZXIuY2xvc2UoKTtcbiAqIH0pKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEFuIGV4YW1wbGUgb2YgZGlzY29ubmVjdGluZyBmcm9tIGFuZCByZWNvbm5lY3RpbmcgdG8gYSB7QGxpbmsgQnJvd3Nlcn06XG4gKiBgYGBqc1xuICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gKlxuICogKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHB1cHBldGVlci5sYXVuY2goKTtcbiAqICAgLy8gU3RvcmUgdGhlIGVuZHBvaW50IHRvIGJlIGFibGUgdG8gcmVjb25uZWN0IHRvIENocm9taXVtXG4gKiAgIGNvbnN0IGJyb3dzZXJXU0VuZHBvaW50ID0gYnJvd3Nlci53c0VuZHBvaW50KCk7XG4gKiAgIC8vIERpc2Nvbm5lY3QgcHVwcGV0ZWVyIGZyb20gQ2hyb21pdW1cbiAqICAgYnJvd3Nlci5kaXNjb25uZWN0KCk7XG4gKlxuICogICAvLyBVc2UgdGhlIGVuZHBvaW50IHRvIHJlZXN0YWJsaXNoIGEgY29ubmVjdGlvblxuICogICBjb25zdCBicm93c2VyMiA9IGF3YWl0IHB1cHBldGVlci5jb25uZWN0KHticm93c2VyV1NFbmRwb2ludH0pO1xuICogICAvLyBDbG9zZSBDaHJvbWl1bVxuICogICBhd2FpdCBicm93c2VyMi5jbG9zZSgpO1xuICogfSkoKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEJyb3dzZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGNvbnRleHRJZHMsIGlnbm9yZUhUVFBTRXJyb3JzLCBkZWZhdWx0Vmlld3BvcnQsIHByb2Nlc3MsIGNsb3NlQ2FsbGJhY2ssIHRhcmdldEZpbHRlckNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2lnbm9yZUhUVFBTRXJyb3JzID0gaWdub3JlSFRUUFNFcnJvcnM7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWaWV3cG9ydCA9IGRlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9jbG9zZUNhbGxiYWNrID0gY2xvc2VDYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuX3RhcmdldEZpbHRlckNhbGxiYWNrID0gdGFyZ2V0RmlsdGVyQ2FsbGJhY2sgfHwgKCgpID0+IHRydWUpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29udGV4dCA9IG5ldyBCcm93c2VyQ29udGV4dCh0aGlzLl9jb25uZWN0aW9uLCB0aGlzLCBudWxsKTtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgY29udGV4dElkIG9mIGNvbnRleHRJZHMpXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cy5zZXQoY29udGV4dElkLCBuZXcgQnJvd3NlckNvbnRleHQodGhpcy5fY29ubmVjdGlvbiwgdGhpcywgY29udGV4dElkKSk7XG4gICAgICAgIHRoaXMuX3RhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oQ29ubmVjdGlvbkVtaXR0ZWRFdmVudHMuRGlzY29ubmVjdGVkLCAoKSA9PiB0aGlzLmVtaXQoXCJkaXNjb25uZWN0ZWRcIiAvKiBEaXNjb25uZWN0ZWQgKi8pKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5vbignVGFyZ2V0LnRhcmdldENyZWF0ZWQnLCB0aGlzLl90YXJnZXRDcmVhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdUYXJnZXQudGFyZ2V0RGVzdHJveWVkJywgdGhpcy5fdGFyZ2V0RGVzdHJveWVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdUYXJnZXQudGFyZ2V0SW5mb0NoYW5nZWQnLCB0aGlzLl90YXJnZXRJbmZvQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShjb25uZWN0aW9uLCBjb250ZXh0SWRzLCBpZ25vcmVIVFRQU0Vycm9ycywgZGVmYXVsdFZpZXdwb3J0LCBwcm9jZXNzLCBjbG9zZUNhbGxiYWNrLCB0YXJnZXRGaWx0ZXJDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBicm93c2VyID0gbmV3IEJyb3dzZXIoY29ubmVjdGlvbiwgY29udGV4dElkcywgaWdub3JlSFRUUFNFcnJvcnMsIGRlZmF1bHRWaWV3cG9ydCwgcHJvY2VzcywgY2xvc2VDYWxsYmFjaywgdGFyZ2V0RmlsdGVyQ2FsbGJhY2spO1xuICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmQoJ1RhcmdldC5zZXREaXNjb3ZlclRhcmdldHMnLCB7IGRpc2NvdmVyOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gYnJvd3NlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNwYXduZWQgYnJvd3NlciBwcm9jZXNzLiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgYnJvd3NlciBpbnN0YW5jZSB3YXMgY3JlYXRlZCB3aXRoXG4gICAgICoge0BsaW5rIFB1cHBldGVlci5jb25uZWN0fS5cbiAgICAgKi9cbiAgICBwcm9jZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbmNvZ25pdG8gYnJvd3NlciBjb250ZXh0LiBUaGlzIHdvbid0IHNoYXJlIGNvb2tpZXMvY2FjaGUgd2l0aCBvdGhlclxuICAgICAqIGJyb3dzZXIgY29udGV4dHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogKGFzeW5jICgpID0+IHtcbiAgICAgKiAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHB1cHBldGVlci5sYXVuY2goKTtcbiAgICAgKiAgIC8vIENyZWF0ZSBhIG5ldyBpbmNvZ25pdG8gYnJvd3NlciBjb250ZXh0LlxuICAgICAqICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGJyb3dzZXIuY3JlYXRlSW5jb2duaXRvQnJvd3NlckNvbnRleHQoKTtcbiAgICAgKiAgIC8vIENyZWF0ZSBhIG5ldyBwYWdlIGluIGEgcHJpc3RpbmUgY29udGV4dC5cbiAgICAgKiAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBjb250ZXh0Lm5ld1BhZ2UoKTtcbiAgICAgKiAgIC8vIERvIHN0dWZmXG4gICAgICogICBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vZXhhbXBsZS5jb20nKTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUluY29nbml0b0Jyb3dzZXJDb250ZXh0KCkge1xuICAgICAgICBjb25zdCB7IGJyb3dzZXJDb250ZXh0SWQgfSA9IGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCgnVGFyZ2V0LmNyZWF0ZUJyb3dzZXJDb250ZXh0Jyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQnJvd3NlckNvbnRleHQodGhpcy5fY29ubmVjdGlvbiwgdGhpcywgYnJvd3NlckNvbnRleHRJZCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnNldChicm93c2VyQ29udGV4dElkLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9wZW4gYnJvd3NlciBjb250ZXh0cy4gSW4gYSBuZXdseSBjcmVhdGVkIGJyb3dzZXIsIHRoaXMgd2lsbFxuICAgICAqIHJldHVybiBhIHNpbmdsZSBpbnN0YW5jZSBvZiB7QGxpbmsgQnJvd3NlckNvbnRleHR9LlxuICAgICAqL1xuICAgIGJyb3dzZXJDb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9kZWZhdWx0Q29udGV4dCwgLi4uQXJyYXkuZnJvbSh0aGlzLl9jb250ZXh0cy52YWx1ZXMoKSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJyb3dzZXIgY29udGV4dC4gVGhlIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IGNhbm5vdCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgZGVmYXVsdEJyb3dzZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdENvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIFVzZWQgYnkgQnJvd3NlckNvbnRleHQgZGlyZWN0bHkgc28gY2Fubm90IGJlIG1hcmtlZCBwcml2YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIF9kaXNwb3NlQ29udGV4dChjb250ZXh0SWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdGlvbi5zZW5kKCdUYXJnZXQuZGlzcG9zZUJyb3dzZXJDb250ZXh0Jywge1xuICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogY29udGV4dElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLmRlbGV0ZShjb250ZXh0SWQpO1xuICAgIH1cbiAgICBhc3luYyBfdGFyZ2V0Q3JlYXRlZChldmVudCkge1xuICAgICAgICBjb25zdCB0YXJnZXRJbmZvID0gZXZlbnQudGFyZ2V0SW5mbztcbiAgICAgICAgY29uc3QgeyBicm93c2VyQ29udGV4dElkIH0gPSB0YXJnZXRJbmZvO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYnJvd3NlckNvbnRleHRJZCAmJiB0aGlzLl9jb250ZXh0cy5oYXMoYnJvd3NlckNvbnRleHRJZClcbiAgICAgICAgICAgID8gdGhpcy5fY29udGV4dHMuZ2V0KGJyb3dzZXJDb250ZXh0SWQpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZmF1bHRDb250ZXh0O1xuICAgICAgICBjb25zdCBzaG91bGRBdHRhY2hUb1RhcmdldCA9IHRoaXMuX3RhcmdldEZpbHRlckNhbGxiYWNrKHRhcmdldEluZm8pO1xuICAgICAgICBpZiAoIXNob3VsZEF0dGFjaFRvVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbmV3IFRhcmdldCh0YXJnZXRJbmZvLCBjb250ZXh0LCAoKSA9PiB0aGlzLl9jb25uZWN0aW9uLmNyZWF0ZVNlc3Npb24odGFyZ2V0SW5mbyksIHRoaXMuX2lnbm9yZUhUVFBTRXJyb3JzLCB0aGlzLl9kZWZhdWx0Vmlld3BvcnQpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuX3RhcmdldHMuaGFzKGV2ZW50LnRhcmdldEluZm8udGFyZ2V0SWQpLCAnVGFyZ2V0IHNob3VsZCBub3QgZXhpc3QgYmVmb3JlIHRhcmdldENyZWF0ZWQnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0cy5zZXQoZXZlbnQudGFyZ2V0SW5mby50YXJnZXRJZCwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGF3YWl0IHRhcmdldC5faW5pdGlhbGl6ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0YXJnZXRjcmVhdGVkXCIgLyogVGFyZ2V0Q3JlYXRlZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBUYXJnZXRDcmVhdGVkICovLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF90YXJnZXREZXN0cm95ZWQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0cy5nZXQoZXZlbnQudGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXQuX2luaXRpYWxpemVkQ2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB0aGlzLl90YXJnZXRzLmRlbGV0ZShldmVudC50YXJnZXRJZCk7XG4gICAgICAgIHRhcmdldC5fY2xvc2VkQ2FsbGJhY2soKTtcbiAgICAgICAgaWYgKGF3YWl0IHRhcmdldC5faW5pdGlhbGl6ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0YXJnZXRkZXN0cm95ZWRcIiAvKiBUYXJnZXREZXN0cm95ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgICAgICAuYnJvd3NlckNvbnRleHQoKVxuICAgICAgICAgICAgICAgIC5lbWl0KFwidGFyZ2V0ZGVzdHJveWVkXCIgLyogVGFyZ2V0RGVzdHJveWVkICovLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF90YXJnZXRJbmZvQ2hhbmdlZChldmVudCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXRzLmdldChldmVudC50YXJnZXRJbmZvLnRhcmdldElkKTtcbiAgICAgICAgYXNzZXJ0KHRhcmdldCwgJ3RhcmdldCBzaG91bGQgZXhpc3QgYmVmb3JlIHRhcmdldEluZm9DaGFuZ2VkJyk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVVJMID0gdGFyZ2V0LnVybCgpO1xuICAgICAgICBjb25zdCB3YXNJbml0aWFsaXplZCA9IHRhcmdldC5faXNJbml0aWFsaXplZDtcbiAgICAgICAgdGFyZ2V0Ll90YXJnZXRJbmZvQ2hhbmdlZChldmVudC50YXJnZXRJbmZvKTtcbiAgICAgICAgaWYgKHdhc0luaXRpYWxpemVkICYmIHByZXZpb3VzVVJMICE9PSB0YXJnZXQudXJsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRhcmdldGNoYW5nZWRcIiAvKiBUYXJnZXRDaGFuZ2VkICovLCB0YXJnZXQpO1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLmJyb3dzZXJDb250ZXh0KClcbiAgICAgICAgICAgICAgICAuZW1pdChcInRhcmdldGNoYW5nZWRcIiAvKiBUYXJnZXRDaGFuZ2VkICovLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyIHdlYnNvY2tldCBlbmRwb2ludCB3aGljaCBjYW4gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB0b1xuICAgICAqIHtAbGluayBQdXBwZXRlZXIuY29ubmVjdH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQnJvd3NlciB3ZWJzb2NrZXQgdXJsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgYHdzOi8vJHtob3N0fToke3BvcnR9L2RldnRvb2xzL2Jyb3dzZXIvPGlkPmAuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGZpbmQgdGhlIGB3ZWJTb2NrZXREZWJ1Z2dlclVybGAgZnJvbSBgaHR0cDovLyR7aG9zdH06JHtwb3J0fS9qc29uL3ZlcnNpb25gLlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdGhlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sIHwgZGV2dG9vbHMgcHJvdG9jb2x9IGFuZFxuICAgICAqIHRoZSB7QGxpbmtcbiAgICAgKiBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC8jaG93LWRvLWktYWNjZXNzLXRoZS1icm93c2VyLXRhcmdldFxuICAgICAqIHwgYnJvd3NlciBlbmRwb2ludH0uXG4gICAgICovXG4gICAgd3NFbmRwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24udXJsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYSBuZXcge0BsaW5rIFBhZ2V9IG9iamVjdC4gVGhlIFBhZ2UgaXMgY3JlYXRlZCBpblxuICAgICAqIGEgZGVmYXVsdCBicm93c2VyIGNvbnRleHQuXG4gICAgICovXG4gICAgYXN5bmMgbmV3UGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb250ZXh0Lm5ld1BhZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogVXNlZCBieSBCcm93c2VyQ29udGV4dCBkaXJlY3RseSBzbyBjYW5ub3QgYmUgbWFya2VkIHByaXZhdGUuXG4gICAgICovXG4gICAgYXN5bmMgX2NyZWF0ZVBhZ2VJbkNvbnRleHQoY29udGV4dElkKSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0SWQgfSA9IGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCgnVGFyZ2V0LmNyZWF0ZVRhcmdldCcsIHtcbiAgICAgICAgICAgIHVybDogJ2Fib3V0OmJsYW5rJyxcbiAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0SWQ6IGNvbnRleHRJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCB0aGlzLl90YXJnZXRzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGFzc2VydChhd2FpdCB0YXJnZXQuX2luaXRpYWxpemVkUHJvbWlzZSwgJ0ZhaWxlZCB0byBjcmVhdGUgdGFyZ2V0IGZvciBwYWdlJyk7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0YXJnZXQucGFnZSgpO1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsIGFjdGl2ZSB0YXJnZXRzIGluc2lkZSB0aGUgQnJvd3Nlci4gSW4gY2FzZSBvZiBtdWx0aXBsZSBicm93c2VyIGNvbnRleHRzLCByZXR1cm5zXG4gICAgICogYW4gYXJyYXkgd2l0aCBhbGwgdGhlIHRhcmdldHMgaW4gYWxsIGJyb3dzZXIgY29udGV4dHMuXG4gICAgICovXG4gICAgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdGFyZ2V0cy52YWx1ZXMoKSkuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC5faXNJbml0aWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0cygpLmZpbmQoKHRhcmdldCkgPT4gdGFyZ2V0LnR5cGUoKSA9PT0gJ2Jyb3dzZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIGEgdGFyZ2V0IGluIGFsbCBicm93c2VyIGNvbnRleHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdG8gYmUgcnVuIGZvciBldmVyeSB0YXJnZXQuXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHRhcmdldCBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIEFuIGV4YW1wbGUgb2YgZmluZGluZyBhIHRhcmdldCBmb3IgYSBwYWdlIG9wZW5lZCB2aWEgYHdpbmRvdy5vcGVuYDpcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IHBhZ2UuZXZhbHVhdGUoKCkgPT4gd2luZG93Lm9wZW4oJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLycpKTtcbiAgICAgKiBjb25zdCBuZXdXaW5kb3dUYXJnZXQgPSBhd2FpdCBicm93c2VyLndhaXRGb3JUYXJnZXQodGFyZ2V0ID0+IHRhcmdldC51cmwoKSA9PT0gJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JUYXJnZXQocHJlZGljYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0ID0gMzAwMDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFyZ2V0ID0gdGhpcy50YXJnZXRzKCkuZmluZChwcmVkaWNhdGUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdUYXJnZXQ7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBjb25zdCB0YXJnZXRQcm9taXNlID0gbmV3IFByb21pc2UoKHgpID0+IChyZXNvbHZlID0geCkpO1xuICAgICAgICB0aGlzLm9uKFwidGFyZ2V0Y3JlYXRlZFwiIC8qIFRhcmdldENyZWF0ZWQgKi8sIGNoZWNrKTtcbiAgICAgICAgdGhpcy5vbihcInRhcmdldGNoYW5nZWRcIiAvKiBUYXJnZXRDaGFuZ2VkICovLCBjaGVjayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRhcmdldFByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGVscGVyLndhaXRXaXRoVGltZW91dCh0YXJnZXRQcm9taXNlLCAndGFyZ2V0JywgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwidGFyZ2V0Y3JlYXRlZFwiIC8qIFRhcmdldENyZWF0ZWQgKi8sIGNoZWNrKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJ0YXJnZXRjaGFuZ2VkXCIgLyogVGFyZ2V0Q2hhbmdlZCAqLywgY2hlY2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb3BlbiBwYWdlcyBpbnNpZGUgdGhlIEJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogSW4gY2FzZSBvZiBtdWx0aXBsZSBicm93c2VyIGNvbnRleHRzLCByZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHRoZSBwYWdlcyBpbiBhbGxcbiAgICAgKiBicm93c2VyIGNvbnRleHRzLiBOb24tdmlzaWJsZSBwYWdlcywgc3VjaCBhcyBgXCJiYWNrZ3JvdW5kX3BhZ2VcImAsIHdpbGwgbm90IGJlIGxpc3RlZFxuICAgICAqIGhlcmUuIFlvdSBjYW4gZmluZCB0aGVtIHVzaW5nIHtAbGluayBUYXJnZXQucGFnZX0uXG4gICAgICovXG4gICAgYXN5bmMgcGFnZXMoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHRQYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYnJvd3NlckNvbnRleHRzKCkubWFwKChjb250ZXh0KSA9PiBjb250ZXh0LnBhZ2VzKCkpKTtcbiAgICAgICAgLy8gRmxhdHRlbiBhcnJheS5cbiAgICAgICAgcmV0dXJuIGNvbnRleHRQYWdlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdCh4KSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBGb3IgaGVhZGxlc3MgQ2hyb21pdW0sIHRoaXMgaXMgc2ltaWxhciB0byBgSGVhZGxlc3NDaHJvbWUvNjEuMC4zMTUzLjBgLiBGb3JcbiAgICAgKiBub24taGVhZGxlc3MsIHRoaXMgaXMgc2ltaWxhciB0byBgQ2hyb21lLzYxLjAuMzE1My4wYC5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgYnJvd3Nlci52ZXJzaW9uKCkgbWlnaHQgY2hhbmdlIHdpdGggZnV0dXJlIHJlbGVhc2VzIG9mIENocm9taXVtLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCB0aGlzLl9nZXRWZXJzaW9uKCk7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uLnByb2R1Y3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyJ3Mgb3JpZ2luYWwgdXNlciBhZ2VudC4gUGFnZXMgY2FuIG92ZXJyaWRlIHRoZSBicm93c2VyIHVzZXIgYWdlbnQgd2l0aFxuICAgICAqIHtAbGluayBQYWdlLnNldFVzZXJBZ2VudH0uXG4gICAgICovXG4gICAgYXN5bmMgdXNlckFnZW50KCkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5fZ2V0VmVyc2lvbigpO1xuICAgICAgICByZXR1cm4gdmVyc2lvbi51c2VyQWdlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBDaHJvbWl1bSBhbmQgYWxsIG9mIGl0cyBwYWdlcyAoaWYgYW55IHdlcmUgb3BlbmVkKS4gVGhlIHtAbGluayBCcm93c2VyfSBvYmplY3RcbiAgICAgKiBpdHNlbGYgaXMgY29uc2lkZXJlZCB0byBiZSBkaXNwb3NlZCBhbmQgY2Fubm90IGJlIHVzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xvc2VDYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgUHVwcGV0ZWVyIGZyb20gdGhlIGJyb3dzZXIsIGJ1dCBsZWF2ZXMgdGhlIENocm9taXVtIHByb2Nlc3MgcnVubmluZy5cbiAgICAgKiBBZnRlciBjYWxsaW5nIGBkaXNjb25uZWN0YCwgdGhlIHtAbGluayBCcm93c2VyfSBvYmplY3QgaXMgY29uc2lkZXJlZCBkaXNwb3NlZCBhbmRcbiAgICAgKiBjYW5ub3QgYmUgdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgYnJvd3NlciBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY29ubmVjdGlvbi5fY2xvc2VkO1xuICAgIH1cbiAgICBfZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCgnQnJvd3Nlci5nZXRWZXJzaW9uJyk7XG4gICAgfVxufVxuLyoqXG4gKiBCcm93c2VyQ29udGV4dHMgcHJvdmlkZSBhIHdheSB0byBvcGVyYXRlIG11bHRpcGxlIGluZGVwZW5kZW50IGJyb3dzZXJcbiAqIHNlc3Npb25zLiBXaGVuIGEgYnJvd3NlciBpcyBsYXVuY2hlZCwgaXQgaGFzIGEgc2luZ2xlIEJyb3dzZXJDb250ZXh0IHVzZWQgYnlcbiAqIGRlZmF1bHQuIFRoZSBtZXRob2Qge0BsaW5rIEJyb3dzZXIubmV3UGFnZSB8IEJyb3dzZXIubmV3UGFnZX0gY3JlYXRlcyBhIHBhZ2VcbiAqIGluIHRoZSBkZWZhdWx0IGJyb3dzZXIgY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFRoZSBCcm93c2VyIGNsYXNzIGV4dGVuZHMgZnJvbSBQdXBwZXRlZXIncyB7QGxpbmsgRXZlbnRFbWl0dGVyfSBjbGFzcyBhbmRcbiAqIHdpbGwgZW1pdCB2YXJpb3VzIGV2ZW50cyB3aGljaCBhcmUgZG9jdW1lbnRlZCBpbiB0aGVcbiAqIHtAbGluayBCcm93c2VyQ29udGV4dEVtaXR0ZWRFdmVudHN9IGVudW0uXG4gKlxuICogSWYgYSBwYWdlIG9wZW5zIGFub3RoZXIgcGFnZSwgZS5nLiB3aXRoIGEgYHdpbmRvdy5vcGVuYCBjYWxsLCB0aGUgcG9wdXAgd2lsbFxuICogYmVsb25nIHRvIHRoZSBwYXJlbnQgcGFnZSdzIGJyb3dzZXIgY29udGV4dC5cbiAqXG4gKiBQdXBwZXRlZXIgYWxsb3dzIGNyZWF0aW9uIG9mIFwiaW5jb2duaXRvXCIgYnJvd3NlciBjb250ZXh0cyB3aXRoXG4gKiB7QGxpbmsgQnJvd3Nlci5jcmVhdGVJbmNvZ25pdG9Ccm93c2VyQ29udGV4dCB8IEJyb3dzZXIuY3JlYXRlSW5jb2duaXRvQnJvd3NlckNvbnRleHR9XG4gKiBtZXRob2QuIFwiSW5jb2duaXRvXCIgYnJvd3NlciBjb250ZXh0cyBkb24ndCB3cml0ZSBhbnkgYnJvd3NpbmcgZGF0YSB0byBkaXNrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gQ3JlYXRlIGEgbmV3IGluY29nbml0byBicm93c2VyIGNvbnRleHRcbiAqIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBicm93c2VyLmNyZWF0ZUluY29nbml0b0Jyb3dzZXJDb250ZXh0KCk7XG4gKiAvLyBDcmVhdGUgYSBuZXcgcGFnZSBpbnNpZGUgY29udGV4dC5cbiAqIGNvbnN0IHBhZ2UgPSBhd2FpdCBjb250ZXh0Lm5ld1BhZ2UoKTtcbiAqIC8vIC4uLiBkbyBzdHVmZiB3aXRoIHBhZ2UgLi4uXG4gKiBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vZXhhbXBsZS5jb20nKTtcbiAqIC8vIERpc3Bvc2UgY29udGV4dCBvbmNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC5cbiAqIGF3YWl0IGNvbnRleHQuY2xvc2UoKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlckNvbnRleHQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGJyb3dzZXIsIGNvbnRleHRJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5fYnJvd3NlciA9IGJyb3dzZXI7XG4gICAgICAgIHRoaXMuX2lkID0gY29udGV4dElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgYWN0aXZlIHRhcmdldHMgaW5zaWRlIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAgICovXG4gICAgdGFyZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb3dzZXJcbiAgICAgICAgICAgIC50YXJnZXRzKClcbiAgICAgICAgICAgIC5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmJyb3dzZXJDb250ZXh0KCkgPT09IHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNlYXJjaGVzIGZvciBhIHRhcmdldCBpbiB0aGlzIHNwZWNpZmljIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQW4gZXhhbXBsZSBvZiBmaW5kaW5nIGEgdGFyZ2V0IGZvciBhIHBhZ2Ugb3BlbmVkIHZpYSBgd2luZG93Lm9wZW5gOlxuICAgICAqIGBgYGpzXG4gICAgICogYXdhaXQgcGFnZS5ldmFsdWF0ZSgoKSA9PiB3aW5kb3cub3BlbignaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vJykpO1xuICAgICAqIGNvbnN0IG5ld1dpbmRvd1RhcmdldCA9IGF3YWl0IGJyb3dzZXJDb250ZXh0LndhaXRGb3JUYXJnZXQodGFyZ2V0ID0+IHRhcmdldC51cmwoKSA9PT0gJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLycpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIEEgZnVuY3Rpb24gdG8gYmUgcnVuIGZvciBldmVyeSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBvZiBvcHRpb25zLiBBY2NlcHRzIGEgdGltb3V0LFxuICAgICAqIHdoaWNoIGlzIHRoZSBtYXhpbXVtIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogUGFzcyBgMGAgdG8gZGlzYWJsZSB0aGUgdGltZW91dC4gRGVmYXVsdHMgdG8gMzAgc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBmaXJzdCB0YXJnZXQgZm91bmRcbiAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHdhaXRGb3JUYXJnZXQocHJlZGljYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb3dzZXIud2FpdEZvclRhcmdldCgodGFyZ2V0KSA9PiB0YXJnZXQuYnJvd3NlckNvbnRleHQoKSA9PT0gdGhpcyAmJiBwcmVkaWNhdGUodGFyZ2V0KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGFsbCBwYWdlcyBpbnNpZGUgdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYWxsIG9wZW4gcGFnZXMuXG4gICAgICogTm9uIHZpc2libGUgcGFnZXMsIHN1Y2ggYXMgYFwiYmFja2dyb3VuZF9wYWdlXCJgLCB3aWxsIG5vdCBiZSBsaXN0ZWQgaGVyZS5cbiAgICAgKiBZb3UgY2FuIGZpbmQgdGhlbSB1c2luZyB7QGxpbmsgVGFyZ2V0LnBhZ2UgfCB0aGUgdGFyZ2V0IHBhZ2V9LlxuICAgICAqL1xuICAgIGFzeW5jIHBhZ2VzKCkge1xuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMudGFyZ2V0cygpXG4gICAgICAgICAgICAuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC50eXBlKCkgPT09ICdwYWdlJylcbiAgICAgICAgICAgIC5tYXAoKHRhcmdldCkgPT4gdGFyZ2V0LnBhZ2UoKSkpO1xuICAgICAgICByZXR1cm4gcGFnZXMuZmlsdGVyKChwYWdlKSA9PiAhIXBhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgQnJvd3NlckNvbnRleHQgaXMgaW5jb2duaXRvLlxuICAgICAqIFRoZSBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBpcyB0aGUgb25seSBub24taW5jb2duaXRvIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IGNhbm5vdCBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgaXNJbmNvZ25pdG8oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgY29udGV4dCA9IGJyb3dzZXIuZGVmYXVsdEJyb3dzZXJDb250ZXh0KCk7XG4gICAgICogYXdhaXQgY29udGV4dC5vdmVycmlkZVBlcm1pc3Npb25zKCdodHRwczovL2h0bWw1ZGVtb3MuY29tJywgWydnZW9sb2NhdGlvbiddKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGdyYW50IHBlcm1pc3Npb25zIHRvLCBlLmcuIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9ucyAtIEFuIGFycmF5IG9mIHBlcm1pc3Npb25zIHRvIGdyYW50LlxuICAgICAqIEFsbCBwZXJtaXNzaW9ucyB0aGF0IGFyZSBub3QgbGlzdGVkIGhlcmUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRlbmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBvdmVycmlkZVBlcm1pc3Npb25zKG9yaWdpbiwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xQZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zLm1hcCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xQZXJtaXNzaW9uID0gV0VCX1BFUk1JU1NJT05fVE9fUFJPVE9DT0xfUEVSTUlTU0lPTi5nZXQocGVybWlzc2lvbik7XG4gICAgICAgICAgICBpZiAoIXByb3RvY29sUGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGVybWlzc2lvbjogJyArIHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sUGVybWlzc2lvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCgnQnJvd3Nlci5ncmFudFBlcm1pc3Npb25zJywge1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdGhpcy5faWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGVybWlzc2lvbnM6IHByb3RvY29sUGVybWlzc2lvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHBlcm1pc3Npb24gb3ZlcnJpZGVzIGZvciB0aGUgYnJvd3NlciBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGNvbnRleHQgPSBicm93c2VyLmRlZmF1bHRCcm93c2VyQ29udGV4dCgpO1xuICAgICAqIGNvbnRleHQub3ZlcnJpZGVQZXJtaXNzaW9ucygnaHR0cHM6Ly9leGFtcGxlLmNvbScsIFsnY2xpcGJvYXJkLXJlYWQnXSk7XG4gICAgICogLy8gZG8gc3R1ZmYgLi5cbiAgICAgKiBjb250ZXh0LmNsZWFyUGVybWlzc2lvbk92ZXJyaWRlcygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyUGVybWlzc2lvbk92ZXJyaWRlcygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdGlvbi5zZW5kKCdCcm93c2VyLnJlc2V0UGVybWlzc2lvbnMnLCB7XG4gICAgICAgICAgICBicm93c2VyQ29udGV4dElkOiB0aGlzLl9pZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhZ2UgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICBuZXdQYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnJvd3Nlci5fY3JlYXRlUGFnZUluQ29udGV4dCh0aGlzLl9pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyIHRoaXMgYnJvd3NlciBjb250ZXh0IGJlbG9uZ3MgdG8uXG4gICAgICovXG4gICAgYnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb3dzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgYnJvd3NlciBjb250ZXh0LiBBbGwgdGhlIHRhcmdldHMgdGhhdCBiZWxvbmcgdG8gdGhlIGJyb3dzZXIgY29udGV4dFxuICAgICAqIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBPbmx5IGluY29nbml0byBicm93c2VyIGNvbnRleHRzIGNhbiBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLl9pZCwgJ05vbi1pbmNvZ25pdG8gcHJvZmlsZXMgY2Fubm90IGJlIGNsb3NlZCEnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fYnJvd3Nlci5fZGlzcG9zZUNvbnRleHQodGhpcy5faWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXIuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQnJvd3NlciB9IGZyb20gJy4vQnJvd3Nlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnLi9Db25uZWN0aW9uLmpzJztcbmltcG9ydCB7IGdldEZldGNoIH0gZnJvbSAnLi9mZXRjaC5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9lbnZpcm9ubWVudC5qcyc7XG5jb25zdCBnZXRXZWJTb2NrZXRUcmFuc3BvcnRDbGFzcyA9IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gaXNOb2RlXG4gICAgICAgID8gKGF3YWl0IGltcG9ydCgnLi4vbm9kZS9Ob2RlV2ViU29ja2V0VHJhbnNwb3J0LmpzJykpLk5vZGVXZWJTb2NrZXRUcmFuc3BvcnRcbiAgICAgICAgOiAoYXdhaXQgaW1wb3J0KCcuL0Jyb3dzZXJXZWJTb2NrZXRUcmFuc3BvcnQuanMnKSlcbiAgICAgICAgICAgIC5Ccm93c2VyV2ViU29ja2V0VHJhbnNwb3J0O1xufTtcbi8qKlxuICogVXNlcnMgc2hvdWxkIG5ldmVyIGNhbGwgdGhpcyBkaXJlY3RseTsgaXQncyBjYWxsZWQgd2hlbiBjYWxsaW5nXG4gKiBgcHVwcGV0ZWVyLmNvbm5lY3RgLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBjb25uZWN0VG9Ccm93c2VyID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGJyb3dzZXJXU0VuZHBvaW50LCBicm93c2VyVVJMLCBpZ25vcmVIVFRQU0Vycm9ycyA9IGZhbHNlLCBkZWZhdWx0Vmlld3BvcnQgPSB7IHdpZHRoOiA4MDAsIGhlaWdodDogNjAwIH0sIHRyYW5zcG9ydCwgc2xvd01vID0gMCwgdGFyZ2V0RmlsdGVyLCB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoTnVtYmVyKCEhYnJvd3NlcldTRW5kcG9pbnQpICsgTnVtYmVyKCEhYnJvd3NlclVSTCkgKyBOdW1iZXIoISF0cmFuc3BvcnQpID09PVxuICAgICAgICAxLCAnRXhhY3RseSBvbmUgb2YgYnJvd3NlcldTRW5kcG9pbnQsIGJyb3dzZXJVUkwgb3IgdHJhbnNwb3J0IG11c3QgYmUgcGFzc2VkIHRvIHB1cHBldGVlci5jb25uZWN0Jyk7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSBudWxsO1xuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKCcnLCB0cmFuc3BvcnQsIHNsb3dNbyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXJXU0VuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IFdlYlNvY2tldENsYXNzID0gYXdhaXQgZ2V0V2ViU29ja2V0VHJhbnNwb3J0Q2xhc3MoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblRyYW5zcG9ydCA9IGF3YWl0IFdlYlNvY2tldENsYXNzLmNyZWF0ZShicm93c2VyV1NFbmRwb2ludCk7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihicm93c2VyV1NFbmRwb2ludCwgY29ubmVjdGlvblRyYW5zcG9ydCwgc2xvd01vKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3NlclVSTCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uVVJMID0gYXdhaXQgZ2V0V1NFbmRwb2ludChicm93c2VyVVJMKTtcbiAgICAgICAgY29uc3QgV2ViU29ja2V0Q2xhc3MgPSBhd2FpdCBnZXRXZWJTb2NrZXRUcmFuc3BvcnRDbGFzcygpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uVHJhbnNwb3J0ID0gYXdhaXQgV2ViU29ja2V0Q2xhc3MuY3JlYXRlKGNvbm5lY3Rpb25VUkwpO1xuICAgICAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oY29ubmVjdGlvblVSTCwgY29ubmVjdGlvblRyYW5zcG9ydCwgc2xvd01vKTtcbiAgICB9XG4gICAgY29uc3QgeyBicm93c2VyQ29udGV4dElkcyB9ID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kKCdUYXJnZXQuZ2V0QnJvd3NlckNvbnRleHRzJyk7XG4gICAgcmV0dXJuIEJyb3dzZXIuY3JlYXRlKGNvbm5lY3Rpb24sIGJyb3dzZXJDb250ZXh0SWRzLCBpZ25vcmVIVFRQU0Vycm9ycywgZGVmYXVsdFZpZXdwb3J0LCBudWxsLCAoKSA9PiBjb25uZWN0aW9uLnNlbmQoJ0Jyb3dzZXIuY2xvc2UnKS5jYXRjaChkZWJ1Z0Vycm9yKSwgdGFyZ2V0RmlsdGVyKTtcbn07XG5hc3luYyBmdW5jdGlvbiBnZXRXU0VuZHBvaW50KGJyb3dzZXJVUkwpIHtcbiAgICBjb25zdCBlbmRwb2ludFVSTCA9IG5ldyBVUkwoJy9qc29uL3ZlcnNpb24nLCBicm93c2VyVVJMKTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGdldEZldGNoKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goZW5kcG9pbnRVUkwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXN1bHQuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGEud2ViU29ja2V0RGVidWdnZXJVcmw7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5tZXNzYWdlID1cbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggYnJvd3NlciB3ZWJTb2NrZXQgVVJMIGZyb20gJHtlbmRwb2ludFVSTH06IGAgK1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJDb25uZWN0b3IuanMubWFwIiwiZXhwb3J0IGNsYXNzIEJyb3dzZXJXZWJTb2NrZXRUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHdzKSB7XG4gICAgICAgIHRoaXMuX3dzID0gd3M7XG4gICAgICAgIHRoaXMuX3dzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZS5jYWxsKG51bGwsIGV2ZW50LmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fd3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbmNsb3NlKVxuICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZS5jYWxsKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2lsZW50bHkgaWdub3JlIGFsbCBlcnJvcnMgLSB3ZSBkb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB0aGVtLlxuICAgICAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHJlc29sdmUobmV3IEJyb3dzZXJXZWJTb2NrZXRUcmFuc3BvcnQod3MpKSk7XG4gICAgICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fd3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX3dzLmNsb3NlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlcldlYlNvY2tldFRyYW5zcG9ydC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vRGVidWcuanMnO1xuY29uc3QgZGVidWdQcm90b2NvbFNlbmQgPSBkZWJ1ZygncHVwcGV0ZWVyOnByb3RvY29sOlNFTkQg4pa6Jyk7XG5jb25zdCBkZWJ1Z1Byb3RvY29sUmVjZWl2ZSA9IGRlYnVnKCdwdXBwZXRlZXI6cHJvdG9jb2w6UkVDViDil4AnKTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJztcbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIHRoYXQgdGhlIENvbm5lY3Rpb24gY2xhc3MgZW1pdHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uRW1pdHRlZEV2ZW50cyA9IHtcbiAgICBEaXNjb25uZWN0ZWQ6IFN5bWJvbCgnQ29ubmVjdGlvbi5EaXNjb25uZWN0ZWQnKSxcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCB0cmFuc3BvcnQsIGRlbGF5ID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9sYXN0SWQgPSAwO1xuICAgICAgICB0aGlzLl9zZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgICAgICB0aGlzLl9kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5vbm1lc3NhZ2UgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Lm9uY2xvc2UgPSB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLl9jb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gVGhlIHNlc3Npb24gaWRcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBDRFAgc2Vzc2lvbiBpZiBpdCBleGlzdHNcbiAgICAgKi9cbiAgICBzZXNzaW9uKHNlc3Npb25JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH1cbiAgICBzZW5kKG1ldGhvZCwgLi4ucGFyYW1BcmdzKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgZXZlciAxIHBhcmFtIGFyZyBwYXNzZWQsIGJ1dCB0aGUgUHJvdG9jb2wgZGVmaW5lcyBpdCBhcyBhblxuICAgICAgICAvLyBhcnJheSBvZiAwIG9yIDEgaXRlbXMgU2VlIHRoaXMgY29tbWVudDpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0Nocm9tZURldlRvb2xzL2RldnRvb2xzLXByb3RvY29sL3B1bGwvMTEzI2lzc3VlY29tbWVudC00MTI2MDMyODVcbiAgICAgICAgLy8gd2hpY2ggZXhwbGFpbnMgd2h5IHRoZSBwcm90b2NvbCBkZWZpbmVzIHRoZSBwYXJhbXMgdGhpcyB3YXkgZm9yIGJldHRlclxuICAgICAgICAvLyB0eXBlLWluZmVyZW5jZS5cbiAgICAgICAgLy8gU28gbm93IHdlIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgcGFyYW1zIG9yIG5vdCBhbmQgZGVhbCB3aXRoIHRoZW0gYWNjb3JkaW5nbHkuXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtQXJncy5sZW5ndGggPyBwYXJhbUFyZ3NbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fcmF3U2VuZCh7IG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QsIGVycm9yOiBuZXcgRXJyb3IoKSwgbWV0aG9kIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Jhd1NlbmQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBpZCA9ICsrdGhpcy5fbGFzdElkO1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZE1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlLCB7IGlkIH0pKTtcbiAgICAgICAgZGVidWdQcm90b2NvbFNlbmQoc3RyaW5naWZpZWRNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoc3RyaW5naWZpZWRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBhc3luYyBfb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlbGF5KVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKGYpID0+IHNldFRpbWVvdXQoZiwgdGhpcy5fZGVsYXkpKTtcbiAgICAgICAgZGVidWdQcm90b2NvbFJlY2VpdmUobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIGlmIChvYmplY3QubWV0aG9kID09PSAnVGFyZ2V0LmF0dGFjaGVkVG9UYXJnZXQnKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBvYmplY3QucGFyYW1zLnNlc3Npb25JZDtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBuZXcgQ0RQU2Vzc2lvbih0aGlzLCBvYmplY3QucGFyYW1zLnRhcmdldEluZm8udHlwZSwgc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25zLnNldChzZXNzaW9uSWQsIHNlc3Npb24pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZXNzaW9uYXR0YWNoZWQnLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFNlc3Npb24gPSB0aGlzLl9zZXNzaW9ucy5nZXQob2JqZWN0LnNlc3Npb25JZCk7XG4gICAgICAgICAgICBpZiAocGFyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHBhcmVudFNlc3Npb24uZW1pdCgnc2Vzc2lvbmF0dGFjaGVkJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqZWN0Lm1ldGhvZCA9PT0gJ1RhcmdldC5kZXRhY2hlZEZyb21UYXJnZXQnKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5fc2Vzc2lvbnMuZ2V0KG9iamVjdC5wYXJhbXMuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5fb25DbG9zZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9ucy5kZWxldGUob2JqZWN0LnBhcmFtcy5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc2Vzc2lvbmRldGFjaGVkJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb25zLmdldChvYmplY3Quc2Vzc2lvbklkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTZXNzaW9uLmVtaXQoJ3Nlc3Npb25kZXRhY2hlZCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnNlc3Npb25JZCkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb25zLmdldChvYmplY3Quc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgICAgIHNlc3Npb24uX29uTWVzc2FnZShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iamVjdC5pZCkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KG9iamVjdC5pZCk7XG4gICAgICAgICAgICAvLyBDYWxsYmFja3MgY291bGQgYmUgYWxsIHJlamVjdGVkIGlmIHNvbWVvbmUgaGFzIGNhbGxlZCBgLmRpc3Bvc2UoKWAuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGVsZXRlKG9iamVjdC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sucmVqZWN0KGNyZWF0ZVByb3RvY29sRXJyb3IoY2FsbGJhY2suZXJyb3IsIGNhbGxiYWNrLm1ldGhvZCwgb2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKG9iamVjdC5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KG9iamVjdC5tZXRob2QsIG9iamVjdC5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuX2NhbGxiYWNrcy52YWx1ZXMoKSlcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChyZXdyaXRlRXJyb3IoY2FsbGJhY2suZXJyb3IsIGBQcm90b2NvbCBlcnJvciAoJHtjYWxsYmFjay5tZXRob2R9KTogVGFyZ2V0IGNsb3NlZC5gKSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2YgdGhpcy5fc2Vzc2lvbnMudmFsdWVzKCkpXG4gICAgICAgICAgICBzZXNzaW9uLl9vbkNsb3NlZCgpO1xuICAgICAgICB0aGlzLl9zZXNzaW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLmVtaXQoQ29ubmVjdGlvbkVtaXR0ZWRFdmVudHMuRGlzY29ubmVjdGVkKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fb25DbG9zZSgpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRhcmdldEluZm8gLSBUaGUgdGFyZ2V0IGluZm9cbiAgICAgKiBAcmV0dXJucyBUaGUgQ0RQIHNlc3Npb24gdGhhdCBpcyBjcmVhdGVkXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2Vzc2lvbih0YXJnZXRJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkIH0gPSBhd2FpdCB0aGlzLnNlbmQoJ1RhcmdldC5hdHRhY2hUb1RhcmdldCcsIHtcbiAgICAgICAgICAgIHRhcmdldElkOiB0YXJnZXRJbmZvLnRhcmdldElkLFxuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGV2ZW50cyB0aGF0IHRoZSBDRFBTZXNzaW9uIGNsYXNzIGVtaXRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgQ0RQU2Vzc2lvbkVtaXR0ZWRFdmVudHMgPSB7XG4gICAgRGlzY29ubmVjdGVkOiBTeW1ib2woJ0NEUFNlc3Npb24uRGlzY29ubmVjdGVkJyksXG59O1xuLyoqXG4gKiBUaGUgYENEUFNlc3Npb25gIGluc3RhbmNlcyBhcmUgdXNlZCB0byB0YWxrIHJhdyBDaHJvbWUgRGV2dG9vbHMgUHJvdG9jb2wuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBQcm90b2NvbCBtZXRob2RzIGNhbiBiZSBjYWxsZWQgd2l0aCB7QGxpbmsgQ0RQU2Vzc2lvbi5zZW5kfSBtZXRob2QgYW5kIHByb3RvY29sXG4gKiBldmVudHMgY2FuIGJlIHN1YnNjcmliZWQgdG8gd2l0aCBgQ0RQU2Vzc2lvbi5vbmAgbWV0aG9kLlxuICpcbiAqIFVzZWZ1bCBsaW5rczoge0BsaW5rIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sLyB8IERldlRvb2xzIFByb3RvY29sIFZpZXdlcn1cbiAqIGFuZCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FzbHVzaG5pa292L2dldHRpbmctc3RhcnRlZC13aXRoLWNkcC9ibG9iL21hc3Rlci9SRUFETUUubWQgfCBHZXR0aW5nIFN0YXJ0ZWQgd2l0aCBEZXZUb29scyBQcm90b2NvbH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBjbGllbnQgPSBhd2FpdCBwYWdlLnRhcmdldCgpLmNyZWF0ZUNEUFNlc3Npb24oKTtcbiAqIGF3YWl0IGNsaWVudC5zZW5kKCdBbmltYXRpb24uZW5hYmxlJyk7XG4gKiBjbGllbnQub24oJ0FuaW1hdGlvbi5hbmltYXRpb25DcmVhdGVkJywgKCkgPT4gY29uc29sZS5sb2coJ0FuaW1hdGlvbiBjcmVhdGVkIScpKTtcbiAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmQoJ0FuaW1hdGlvbi5nZXRQbGF5YmFja1JhdGUnKTtcbiAqIGNvbnNvbGUubG9nKCdwbGF5YmFjayByYXRlIGlzICcgKyByZXNwb25zZS5wbGF5YmFja1JhdGUpO1xuICogYXdhaXQgY2xpZW50LnNlbmQoJ0FuaW1hdGlvbi5zZXRQbGF5YmFja1JhdGUnLCB7XG4gKiAgIHBsYXliYWNrUmF0ZTogcmVzcG9uc2UucGxheWJhY2tSYXRlIC8gMlxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDRFBTZXNzaW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCB0YXJnZXRUeXBlLCBzZXNzaW9uSWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0VHlwZSA9IHRhcmdldFR5cGU7XG4gICAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB9XG4gICAgY29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCAuLi5wYXJhbUFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgUHJvdG9jb2wgZXJyb3IgKCR7bWV0aG9kfSk6IFNlc3Npb24gY2xvc2VkLiBNb3N0IGxpa2VseSB0aGUgJHt0aGlzLl90YXJnZXRUeXBlfSBoYXMgYmVlbiBjbG9zZWQuYCkpO1xuICAgICAgICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gQ29ubmVjdGlvbiNzZW5kIGV4cGxhaW5pbmcgd2h5IHdlIGRvIHRoaXMuXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtQXJncy5sZW5ndGggPyBwYXJhbUFyZ3NbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fY29ubmVjdGlvbi5fcmF3U2VuZCh7XG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuX3Nlc3Npb25JZCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCwgZXJyb3I6IG5ldyBFcnJvcigpLCBtZXRob2QgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25NZXNzYWdlKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LmlkICYmIHRoaXMuX2NhbGxiYWNrcy5oYXMob2JqZWN0LmlkKSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KG9iamVjdC5pZCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGVsZXRlKG9iamVjdC5pZCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChjcmVhdGVQcm90b2NvbEVycm9yKGNhbGxiYWNrLmVycm9yLCBjYWxsYmFjay5tZXRob2QsIG9iamVjdCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUob2JqZWN0LnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQoIW9iamVjdC5pZCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQob2JqZWN0Lm1ldGhvZCwgb2JqZWN0LnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIGNkcFNlc3Npb24gZnJvbSB0aGUgdGFyZ2V0LiBPbmNlIGRldGFjaGVkLCB0aGUgY2RwU2Vzc2lvbiBvYmplY3RcbiAgICAgKiB3b24ndCBlbWl0IGFueSBldmVudHMgYW5kIGNhbid0IGJlIHVzZWQgdG8gc2VuZCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXRhY2goKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Vzc2lvbiBhbHJlYWR5IGRldGFjaGVkLiBNb3N0IGxpa2VseSB0aGUgJHt0aGlzLl90YXJnZXRUeXBlfSBoYXMgYmVlbiBjbG9zZWQuYCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb24uc2VuZCgnVGFyZ2V0LmRldGFjaEZyb21UYXJnZXQnLCB7XG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuX3Nlc3Npb25JZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbkNsb3NlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLl9jYWxsYmFja3MudmFsdWVzKCkpXG4gICAgICAgICAgICBjYWxsYmFjay5yZWplY3QocmV3cml0ZUVycm9yKGNhbGxiYWNrLmVycm9yLCBgUHJvdG9jb2wgZXJyb3IgKCR7Y2FsbGJhY2subWV0aG9kfSk6IFRhcmdldCBjbG9zZWQuYCkpO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChDRFBTZXNzaW9uRW1pdHRlZEV2ZW50cy5EaXNjb25uZWN0ZWQpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHshRXJyb3J9IGVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge3tlcnJvcjoge21lc3NhZ2U6IHN0cmluZywgZGF0YTogYW55fX19IG9iamVjdFxuICogQHJldHVybnMgeyFFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xFcnJvcihlcnJvciwgbWV0aG9kLCBvYmplY3QpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBQcm90b2NvbCBlcnJvciAoJHttZXRob2R9KTogJHtvYmplY3QuZXJyb3IubWVzc2FnZX1gO1xuICAgIGlmICgnZGF0YScgaW4gb2JqZWN0LmVycm9yKVxuICAgICAgICBtZXNzYWdlICs9IGAgJHtvYmplY3QuZXJyb3IuZGF0YX1gO1xuICAgIHJldHVybiByZXdyaXRlRXJyb3IoZXJyb3IsIG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7IUVycm9yfVxuICovXG5mdW5jdGlvbiByZXdyaXRlRXJyb3IoZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29uc29sZU1lc3NhZ2Ugb2JqZWN0cyBhcmUgZGlzcGF0Y2hlZCBieSBwYWdlIHZpYSB0aGUgJ2NvbnNvbGUnIGV2ZW50LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ29uc29sZU1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB0ZXh0LCBhcmdzLCBzdGFja1RyYWNlTG9jYXRpb25zKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5fYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuX3N0YWNrVHJhY2VMb2NhdGlvbnMgPSBzdGFja1RyYWNlTG9jYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgY29uc29sZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgdGV4dCBvZiB0aGUgY29uc29sZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjb25zb2xlLlxuICAgICAqL1xuICAgIGFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYXRpb24gb2YgdGhlIGNvbnNvbGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrVHJhY2VMb2NhdGlvbnMubGVuZ3RoID8gdGhpcy5fc3RhY2tUcmFjZUxvY2F0aW9uc1swXSA6IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgYXJyYXkgb2YgbG9jYXRpb25zIG9uIHRoZSBzdGFjayBvZiB0aGUgY29uc29sZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIHN0YWNrVHJhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja1RyYWNlTG9jYXRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnNvbGVNZXNzYWdlLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhlbHBlciwgZGVidWdFcnJvciB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IEVWQUxVQVRJT05fU0NSSVBUX1VSTCB9IGZyb20gJy4vRXhlY3V0aW9uQ29udGV4dC5qcyc7XG4vKipcbiAqIFRoZSBDb3ZlcmFnZSBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGdhdGhlcnMgaW5mb3JtYXRpb24gYWJvdXQgcGFydHMgb2ZcbiAqIEphdmFTY3JpcHQgYW5kIENTUyB0aGF0IHdlcmUgdXNlZCBieSB0aGUgcGFnZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8gb3V0cHV0IGNvdmVyYWdlIGluIGEgZm9ybSBjb25zdW1hYmxlIGJ5IHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaXN0YW5idWxqcyB8IElzdGFuYnVsfSxcbiAqIHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2lzdGFuYnVsanMvcHVwcGV0ZWVyLXRvLWlzdGFuYnVsIHwgcHVwcGV0ZWVyLXRvLWlzdGFuYnVsfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogQW4gZXhhbXBsZSBvZiB1c2luZyBKYXZhU2NyaXB0IGFuZCBDU1MgY292ZXJhZ2UgdG8gZ2V0IHBlcmNlbnRhZ2Ugb2YgaW5pdGlhbGx5XG4gKiBleGVjdXRlZCBjb2RlOlxuICogYGBganNcbiAqIC8vIEVuYWJsZSBib3RoIEphdmFTY3JpcHQgYW5kIENTUyBjb3ZlcmFnZVxuICogYXdhaXQgUHJvbWlzZS5hbGwoW1xuICogICBwYWdlLmNvdmVyYWdlLnN0YXJ0SlNDb3ZlcmFnZSgpLFxuICogICBwYWdlLmNvdmVyYWdlLnN0YXJ0Q1NTQ292ZXJhZ2UoKVxuICogXSk7XG4gKiAvLyBOYXZpZ2F0ZSB0byBwYWdlXG4gKiBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vZXhhbXBsZS5jb20nKTtcbiAqIC8vIERpc2FibGUgYm90aCBKYXZhU2NyaXB0IGFuZCBDU1MgY292ZXJhZ2VcbiAqIGNvbnN0IFtqc0NvdmVyYWdlLCBjc3NDb3ZlcmFnZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gKiAgIHBhZ2UuY292ZXJhZ2Uuc3RvcEpTQ292ZXJhZ2UoKSxcbiAqICAgcGFnZS5jb3ZlcmFnZS5zdG9wQ1NTQ292ZXJhZ2UoKSxcbiAqIF0pO1xuICogbGV0IHRvdGFsQnl0ZXMgPSAwO1xuICogbGV0IHVzZWRCeXRlcyA9IDA7XG4gKiBjb25zdCBjb3ZlcmFnZSA9IFsuLi5qc0NvdmVyYWdlLCAuLi5jc3NDb3ZlcmFnZV07XG4gKiBmb3IgKGNvbnN0IGVudHJ5IG9mIGNvdmVyYWdlKSB7XG4gKiAgIHRvdGFsQnl0ZXMgKz0gZW50cnkudGV4dC5sZW5ndGg7XG4gKiAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgZW50cnkucmFuZ2VzKVxuICogICAgIHVzZWRCeXRlcyArPSByYW5nZS5lbmQgLSByYW5nZS5zdGFydCAtIDE7XG4gKiB9XG4gKiBjb25zb2xlLmxvZyhgQnl0ZXMgdXNlZDogJHt1c2VkQnl0ZXMgLyB0b3RhbEJ5dGVzICogMTAwfSVgKTtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ292ZXJhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9qc0NvdmVyYWdlID0gbmV3IEpTQ292ZXJhZ2UoY2xpZW50KTtcbiAgICAgICAgdGhpcy5fY3NzQ292ZXJhZ2UgPSBuZXcgQ1NTQ292ZXJhZ2UoY2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBTZXQgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMgZm9yIGNvdmVyYWdlIGRlZmF1bHRzIHRvIGB7XG4gICAgICogcmVzZXRPbk5hdmlnYXRpb24gOiB0cnVlLCByZXBvcnRBbm9ueW1vdXNTY3JpcHRzIDogZmFsc2UgfWBcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBjb3ZlcmFnZSBpcyBzdGFydGVkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBbm9ueW1vdXMgc2NyaXB0cyBhcmUgb25lcyB0aGF0IGRvbid0IGhhdmUgYW4gYXNzb2NpYXRlZCB1cmwuIFRoZXNlIGFyZVxuICAgICAqIHNjcmlwdHMgdGhhdCBhcmUgZHluYW1pY2FsbHkgY3JlYXRlZCBvbiB0aGUgcGFnZSB1c2luZyBgZXZhbGAgb3JcbiAgICAgKiBgbmV3IEZ1bmN0aW9uYC4gSWYgYHJlcG9ydEFub255bW91c1NjcmlwdHNgIGlzIHNldCB0byBgdHJ1ZWAsIGFub255bW91c1xuICAgICAqIHNjcmlwdHMgd2lsbCBoYXZlIGBfX3B1cHBldGVlcl9ldmFsdWF0aW9uX3NjcmlwdF9fYCBhcyB0aGVpciBVUkwuXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRKU0NvdmVyYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fanNDb3ZlcmFnZS5zdGFydChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBhcnJheSBvZiBjb3ZlcmFnZSByZXBvcnRzIGZvclxuICAgICAqIGFsbCBzY3JpcHRzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBKYXZhU2NyaXB0IENvdmVyYWdlIGRvZXNuJ3QgaW5jbHVkZSBhbm9ueW1vdXMgc2NyaXB0cyBieSBkZWZhdWx0LlxuICAgICAqIEhvd2V2ZXIsIHNjcmlwdHMgd2l0aCBzb3VyY2VVUkxzIGFyZSByZXBvcnRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wSlNDb3ZlcmFnZSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2pzQ292ZXJhZ2Uuc3RvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNldCBvZiBjb25maWd1cmFibGUgb3B0aW9ucyBmb3IgY292ZXJhZ2UsIGRlZmF1bHRzIHRvIGB7XG4gICAgICogcmVzZXRPbk5hdmlnYXRpb24gOiB0cnVlIH1gXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gY292ZXJhZ2UgaXMgc3RhcnRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFydENTU0NvdmVyYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3NzQ292ZXJhZ2Uuc3RhcnQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYXJyYXkgb2YgY292ZXJhZ2UgcmVwb3J0c1xuICAgICAqIGZvciBhbGwgc3R5bGVzaGVldHMuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDU1MgQ292ZXJhZ2UgZG9lc24ndCBpbmNsdWRlIGR5bmFtaWNhbGx5IGluamVjdGVkIHN0eWxlIHRhZ3NcbiAgICAgKiB3aXRob3V0IHNvdXJjZVVSTHMuXG4gICAgICovXG4gICAgYXN5bmMgc3RvcENTU0NvdmVyYWdlKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY3NzQ292ZXJhZ2Uuc3RvcCgpO1xuICAgIH1cbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSlNDb3ZlcmFnZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2NyaXB0VVJMcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0U291cmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzZXRPbk5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVwb3J0QW5vbnltb3VzU2NyaXB0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2VuYWJsZWQsICdKU0NvdmVyYWdlIGlzIGFscmVhZHkgZW5hYmxlZCcpO1xuICAgICAgICBjb25zdCB7IHJlc2V0T25OYXZpZ2F0aW9uID0gdHJ1ZSwgcmVwb3J0QW5vbnltb3VzU2NyaXB0cyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9yZXNldE9uTmF2aWdhdGlvbiA9IHJlc2V0T25OYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLl9yZXBvcnRBbm9ueW1vdXNTY3JpcHRzID0gcmVwb3J0QW5vbnltb3VzU2NyaXB0cztcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjcmlwdFVSTHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0U291cmNlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIGhlbHBlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2NsaWVudCwgJ0RlYnVnZ2VyLnNjcmlwdFBhcnNlZCcsIHRoaXMuX29uU2NyaXB0UGFyc2VkLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgaGVscGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fY2xpZW50LCAnUnVudGltZS5leGVjdXRpb25Db250ZXh0c0NsZWFyZWQnLCB0aGlzLl9vbkV4ZWN1dGlvbkNvbnRleHRzQ2xlYXJlZC5iaW5kKHRoaXMpKSxcbiAgICAgICAgXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ1Byb2ZpbGVyLmVuYWJsZScpLFxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ1Byb2ZpbGVyLnN0YXJ0UHJlY2lzZUNvdmVyYWdlJywge1xuICAgICAgICAgICAgICAgIGNhbGxDb3VudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGV0YWlsZWQ6IHRydWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kKCdEZWJ1Z2dlci5lbmFibGUnKSxcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kKCdEZWJ1Z2dlci5zZXRTa2lwQWxsUGF1c2VzJywgeyBza2lwOiB0cnVlIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRXhlY3V0aW9uQ29udGV4dHNDbGVhcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc2V0T25OYXZpZ2F0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zY3JpcHRVUkxzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3NjcmlwdFNvdXJjZXMuY2xlYXIoKTtcbiAgICB9XG4gICAgYXN5bmMgX29uU2NyaXB0UGFyc2VkKGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSBwdXBwZXRlZXItaW5qZWN0ZWQgc2NyaXB0c1xuICAgICAgICBpZiAoZXZlbnQudXJsID09PSBFVkFMVUFUSU9OX1NDUklQVF9VUkwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIElnbm9yZSBvdGhlciBhbm9ueW1vdXMgc2NyaXB0cyB1bmxlc3MgdGhlIHJlcG9ydEFub255bW91c1NjcmlwdHMgb3B0aW9uIGlzIHRydWUuXG4gICAgICAgIGlmICghZXZlbnQudXJsICYmICF0aGlzLl9yZXBvcnRBbm9ueW1vdXNTY3JpcHRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRGVidWdnZXIuZ2V0U2NyaXB0U291cmNlJywge1xuICAgICAgICAgICAgICAgIHNjcmlwdElkOiBldmVudC5zY3JpcHRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2NyaXB0VVJMcy5zZXQoZXZlbnQuc2NyaXB0SWQsIGV2ZW50LnVybCk7XG4gICAgICAgICAgICB0aGlzLl9zY3JpcHRTb3VyY2VzLnNldChldmVudC5zY3JpcHRJZCwgcmVzcG9uc2Uuc2NyaXB0U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgaGFwcGVuIGlmIHRoZSBwYWdlIGhhcyBhbHJlYWR5IG5hdmlnYXRlZCBhd2F5LlxuICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuX2VuYWJsZWQsICdKU0NvdmVyYWdlIGlzIG5vdCBlbmFibGVkJyk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ1Byb2ZpbGVyLnRha2VQcmVjaXNlQ292ZXJhZ2UnKSxcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kKCdQcm9maWxlci5zdG9wUHJlY2lzZUNvdmVyYWdlJyksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUHJvZmlsZXIuZGlzYWJsZScpLFxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0RlYnVnZ2VyLmRpc2FibGUnKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGhlbHBlci5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLl9ldmVudExpc3RlbmVycyk7XG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG4gICAgICAgIGNvbnN0IHByb2ZpbGVSZXNwb25zZSA9IHJlc3VsdFswXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBwcm9maWxlUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5fc2NyaXB0VVJMcy5nZXQoZW50cnkuc2NyaXB0SWQpO1xuICAgICAgICAgICAgaWYgKCF1cmwgJiYgdGhpcy5fcmVwb3J0QW5vbnltb3VzU2NyaXB0cylcbiAgICAgICAgICAgICAgICB1cmwgPSAnZGVidWdnZXI6Ly9WTScgKyBlbnRyeS5zY3JpcHRJZDtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9zY3JpcHRTb3VyY2VzLmdldChlbnRyeS5zY3JpcHRJZCk7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHVybCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZmxhdHRlblJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmdW5jIG9mIGVudHJ5LmZ1bmN0aW9ucylcbiAgICAgICAgICAgICAgICBmbGF0dGVuUmFuZ2VzLnB1c2goLi4uZnVuYy5yYW5nZXMpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gY29udmVydFRvRGlzam9pbnRSYW5nZXMoZmxhdHRlblJhbmdlcyk7XG4gICAgICAgICAgICBjb3ZlcmFnZS5wdXNoKHsgdXJsLCByYW5nZXMsIHRleHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdmVyYWdlO1xuICAgIH1cbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgQ1NTQ292ZXJhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0eWxlc2hlZXRVUkxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdHlsZXNoZWV0U291cmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzZXRPbk5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVwb3J0QW5vbnltb3VzU2NyaXB0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2VuYWJsZWQsICdDU1NDb3ZlcmFnZSBpcyBhbHJlYWR5IGVuYWJsZWQnKTtcbiAgICAgICAgY29uc3QgeyByZXNldE9uTmF2aWdhdGlvbiA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3Jlc2V0T25OYXZpZ2F0aW9uID0gcmVzZXRPbk5hdmlnYXRpb247XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdHlsZXNoZWV0VVJMcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9zdHlsZXNoZWV0U291cmNlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIGhlbHBlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2NsaWVudCwgJ0NTUy5zdHlsZVNoZWV0QWRkZWQnLCB0aGlzLl9vblN0eWxlU2hlZXQuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBoZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9jbGllbnQsICdSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHRzQ2xlYXJlZCcsIHRoaXMuX29uRXhlY3V0aW9uQ29udGV4dHNDbGVhcmVkLmJpbmQodGhpcykpLFxuICAgICAgICBdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnRE9NLmVuYWJsZScpLFxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0NTUy5lbmFibGUnKSxcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kKCdDU1Muc3RhcnRSdWxlVXNhZ2VUcmFja2luZycpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRXhlY3V0aW9uQ29udGV4dHNDbGVhcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc2V0T25OYXZpZ2F0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zdHlsZXNoZWV0VVJMcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9zdHlsZXNoZWV0U291cmNlcy5jbGVhcigpO1xuICAgIH1cbiAgICBhc3luYyBfb25TdHlsZVNoZWV0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGV2ZW50LmhlYWRlcjtcbiAgICAgICAgLy8gSWdub3JlIGFub255bW91cyBzY3JpcHRzXG4gICAgICAgIGlmICghaGVhZGVyLnNvdXJjZVVSTClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0NTUy5nZXRTdHlsZVNoZWV0VGV4dCcsIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0SWQ6IGhlYWRlci5zdHlsZVNoZWV0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlc2hlZXRVUkxzLnNldChoZWFkZXIuc3R5bGVTaGVldElkLCBoZWFkZXIuc291cmNlVVJMKTtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlc2hlZXRTb3VyY2VzLnNldChoZWFkZXIuc3R5bGVTaGVldElkLCByZXNwb25zZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgaGFwcGVuIGlmIHRoZSBwYWdlIGhhcyBhbHJlYWR5IG5hdmlnYXRlZCBhd2F5LlxuICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuX2VuYWJsZWQsICdDU1NDb3ZlcmFnZSBpcyBub3QgZW5hYmxlZCcpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJ1bGVUcmFja2luZ1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0NTUy5zdG9wUnVsZVVzYWdlVHJhY2tpbmcnKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0NTUy5kaXNhYmxlJyksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnRE9NLmRpc2FibGUnKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGhlbHBlci5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLl9ldmVudExpc3RlbmVycyk7XG4gICAgICAgIC8vIGFnZ3JlZ2F0ZSBieSBzdHlsZVNoZWV0SWRcbiAgICAgICAgY29uc3Qgc3R5bGVTaGVldElkVG9Db3ZlcmFnZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBydWxlVHJhY2tpbmdSZXNwb25zZS5ydWxlVXNhZ2UpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBzdHlsZVNoZWV0SWRUb0NvdmVyYWdlLmdldChlbnRyeS5zdHlsZVNoZWV0SWQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0SWRUb0NvdmVyYWdlLnNldChlbnRyeS5zdHlsZVNoZWV0SWQsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IGVudHJ5LnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZE9mZnNldDogZW50cnkuZW5kT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNvdW50OiBlbnRyeS51c2VkID8gMSA6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3ZlcmFnZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlU2hlZXRJZCBvZiB0aGlzLl9zdHlsZXNoZWV0VVJMcy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3N0eWxlc2hlZXRVUkxzLmdldChzdHlsZVNoZWV0SWQpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX3N0eWxlc2hlZXRTb3VyY2VzLmdldChzdHlsZVNoZWV0SWQpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gY29udmVydFRvRGlzam9pbnRSYW5nZXMoc3R5bGVTaGVldElkVG9Db3ZlcmFnZS5nZXQoc3R5bGVTaGVldElkKSB8fCBbXSk7XG4gICAgICAgICAgICBjb3ZlcmFnZS5wdXNoKHsgdXJsLCByYW5nZXMsIHRleHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdmVyYWdlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0Rpc2pvaW50UmFuZ2VzKG5lc3RlZFJhbmdlcykge1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgbmVzdGVkUmFuZ2VzKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHsgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCwgdHlwZTogMCwgcmFuZ2UgfSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHsgb2Zmc2V0OiByYW5nZS5lbmRPZmZzZXQsIHR5cGU6IDEsIHJhbmdlIH0pO1xuICAgIH1cbiAgICAvLyBTb3J0IHBvaW50cyB0byBmb3JtIGEgdmFsaWQgcGFyZW50aGVzaXMgc2VxdWVuY2UuXG4gICAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgLy8gU29ydCB3aXRoIGluY3JlYXNpbmcgb2Zmc2V0cy5cbiAgICAgICAgaWYgKGEub2Zmc2V0ICE9PSBiLm9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgICAvLyBBbGwgXCJlbmRcIiBwb2ludHMgc2hvdWxkIGdvIGJlZm9yZSBcInN0YXJ0XCIgcG9pbnRzLlxuICAgICAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gYi50eXBlIC0gYS50eXBlO1xuICAgICAgICBjb25zdCBhTGVuZ3RoID0gYS5yYW5nZS5lbmRPZmZzZXQgLSBhLnJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjb25zdCBiTGVuZ3RoID0gYi5yYW5nZS5lbmRPZmZzZXQgLSBiLnJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAvLyBGb3IgdHdvIFwic3RhcnRcIiBwb2ludHMsIHRoZSBvbmUgd2l0aCBsb25nZXIgcmFuZ2UgZ29lcyBmaXJzdC5cbiAgICAgICAgaWYgKGEudHlwZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBiTGVuZ3RoIC0gYUxlbmd0aDtcbiAgICAgICAgLy8gRm9yIHR3byBcImVuZFwiIHBvaW50cywgdGhlIG9uZSB3aXRoIHNob3J0ZXIgcmFuZ2UgZ29lcyBmaXJzdC5cbiAgICAgICAgcmV0dXJuIGFMZW5ndGggLSBiTGVuZ3RoO1xuICAgIH0pO1xuICAgIGNvbnN0IGhpdENvdW50U3RhY2sgPSBbXTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgIC8vIFJ1biBzY2FubmluZyBsaW5lIHRvIGludGVyc2VjdCBhbGwgcmFuZ2VzLlxuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgIGlmIChoaXRDb3VudFN0YWNrLmxlbmd0aCAmJlxuICAgICAgICAgICAgbGFzdE9mZnNldCA8IHBvaW50Lm9mZnNldCAmJlxuICAgICAgICAgICAgaGl0Q291bnRTdGFja1toaXRDb3VudFN0YWNrLmxlbmd0aCAtIDFdID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChsYXN0UmVzdWx0ICYmIGxhc3RSZXN1bHQuZW5kID09PSBsYXN0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIGxhc3RSZXN1bHQuZW5kID0gcG9pbnQub2Zmc2V0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7IHN0YXJ0OiBsYXN0T2Zmc2V0LCBlbmQ6IHBvaW50Lm9mZnNldCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICAgICAgICBpZiAocG9pbnQudHlwZSA9PT0gMClcbiAgICAgICAgICAgIGhpdENvdW50U3RhY2sucHVzaChwb2ludC5yYW5nZS5jb3VudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGhpdENvdW50U3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIEZpbHRlciBvdXQgZW1wdHkgcmFuZ2VzLlxuICAgIHJldHVybiByZXN1bHRzLmZpbHRlcigocmFuZ2UpID0+IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0ID4gMSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db3ZlcmFnZS5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIsIGRlYnVnRXJyb3IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBMaWZlY3ljbGVXYXRjaGVyLCB9IGZyb20gJy4vTGlmZWN5Y2xlV2F0Y2hlci5qcyc7XG5pbXBvcnQgeyBUaW1lb3V0RXJyb3IgfSBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXRRdWVyeUhhbmRsZXJBbmRTZWxlY3RvciB9IGZyb20gJy4vUXVlcnlIYW5kbGVyLmpzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL2Vudmlyb25tZW50LmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBET01Xb3JsZCB7XG4gICAgY29uc3RydWN0b3IoZnJhbWVNYW5hZ2VyLCBmcmFtZSwgdGltZW91dFNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRleHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29udGV4dFJlc29sdmVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dhaXRUYXNrcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBDb250YWlucyBtYXBwaW5nIGZyb20gZnVuY3Rpb25zIHRoYXQgc2hvdWxkIGJlIGJvdW5kIHRvIFB1cHBldGVlciBmdW5jdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib3VuZEZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gU2V0IG9mIGJpbmRpbmdzIHRoYXQgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgdGhpcy5fY3R4QmluZGluZ3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIElmIG11bHRpcGxlIHdhaXRGb3IgYXJlIHNldCB1cCBhc3luY2hyb25vdXNseSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGVcbiAgICAgICAgLy8gZmlyc3Qgb25lIHRvIHNldCB1cCB0aGUgYmluZGluZyBpbiB0aGUgcGFnZSBiZWZvcmUgcnVubmluZyB0aGUgb3RoZXJzLlxuICAgICAgICB0aGlzLl9zZXR0aW5nVXBCaW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnJhbWVNYW5hZ2VyID0gZnJhbWVNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLl90aW1lb3V0U2V0dGluZ3MgPSB0aW1lb3V0U2V0dGluZ3M7XG4gICAgICAgIHRoaXMuX3NldENvbnRleHQobnVsbCk7XG4gICAgICAgIGZyYW1lTWFuYWdlci5fY2xpZW50Lm9uKCdSdW50aW1lLmJpbmRpbmdDYWxsZWQnLCAoZXZlbnQpID0+IHRoaXMuX29uQmluZGluZ0NhbGxlZChldmVudCkpO1xuICAgIH1cbiAgICBmcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xuICAgIH1cbiAgICBhc3luYyBfc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jdHhCaW5kaW5ncy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dFJlc29sdmVDYWxsYmFjay5jYWxsKG51bGwsIGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dFJlc29sdmVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdhaXRUYXNrIG9mIHRoaXMuX3dhaXRUYXNrcylcbiAgICAgICAgICAgICAgICB3YWl0VGFzay5yZXJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRQcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0UmVzb2x2ZUNhbGxiYWNrID0gZnVsZmlsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9oYXNDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NvbnRleHRSZXNvbHZlQ2FsbGJhY2s7XG4gICAgfVxuICAgIF9kZXRhY2goKSB7XG4gICAgICAgIHRoaXMuX2RldGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB3YWl0VGFzayBvZiB0aGlzLl93YWl0VGFza3MpXG4gICAgICAgICAgICB3YWl0VGFzay50ZXJtaW5hdGUobmV3IEVycm9yKCd3YWl0Rm9yRnVuY3Rpb24gZmFpbGVkOiBmcmFtZSBnb3QgZGV0YWNoZWQuJykpO1xuICAgIH1cbiAgICBleGVjdXRpb25Db250ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGV0YWNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4ZWN1dGlvbiBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gZGV0YWNoZWQgZnJhbWUgXCIke3RoaXMuX2ZyYW1lLnVybCgpfVwiIChhcmUgeW91IHRyeWluZyB0byBldmFsdWF0ZT8pYCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgJChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZG9jdW1lbnQuJChzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgX2RvY3VtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fZG9jdW1lbnRQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50UHJvbWlzZTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRQcm9taXNlID0gdGhpcy5leGVjdXRpb25Db250ZXh0KCkudGhlbihhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKCdkb2N1bWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFzRWxlbWVudCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgJHgoZXhwcmVzc2lvbikge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZG9jdW1lbnQuJHgoZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgJGV2YWwoc2VsZWN0b3IsIHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC4kZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgJCRldmFsKHNlbGVjdG9yLCBwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCB0aGlzLl9kb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGRvY3VtZW50LiQkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyAkJChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMuX2RvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZG9jdW1lbnQuJCQoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXRWYWwgPSAnJztcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N0eXBlKVxuICAgICAgICAgICAgICAgIHJldFZhbCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZG9jdW1lbnQuZG9jdHlwZSk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldFZhbCArPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldENvbnRlbnQoaHRtbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgd2FpdFVudGlsID0gWydsb2FkJ10sIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0U2V0dGluZ3MubmF2aWdhdGlvblRpbWVvdXQoKSwgfSA9IG9wdGlvbnM7XG4gICAgICAgIC8vIFdlIHJlbHkgdXBvbiB0aGUgZmFjdCB0aGF0IGRvY3VtZW50Lm9wZW4oKSB3aWxsIHJlc2V0IGZyYW1lIGxpZmVjeWNsZSB3aXRoIFwiaW5pdFwiXG4gICAgICAgIC8vIGxpZmVjeWNsZSBldmVudC4gQHNlZSBodHRwczovL2NycmV2LmNvbS82MDg2NThcbiAgICAgICAgYXdhaXQgdGhpcy5ldmFsdWF0ZSgoaHRtbCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoaHRtbCk7XG4gICAgICAgICAgICBkb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICB9LCBodG1sKTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBMaWZlY3ljbGVXYXRjaGVyKHRoaXMuX2ZyYW1lTWFuYWdlciwgdGhpcy5fZnJhbWUsIHdhaXRVbnRpbCwgdGltZW91dCk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHdhdGNoZXIudGltZW91dE9yVGVybWluYXRpb25Qcm9taXNlKCksXG4gICAgICAgICAgICB3YXRjaGVyLmxpZmVjeWNsZVByb21pc2UoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHdhdGNoZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNjcmlwdCB0YWcgaW50byB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIFVSTCwgZmlsZXBhdGggb3Igc3RyaW5nIG9mIGNvbnRlbnRzLiBOb3RlIHRoYXQgd2hlbiBydW5uaW5nIFB1cHBldGVlclxuICAgICAqIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudCB5b3UgY2Fubm90IHBhc3MgYSBmaWxlcGF0aCBhbmQgc2hvdWxkIHVzZSBlaXRoZXJcbiAgICAgKiBgdXJsYCBvciBgY29udGVudGAuXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2NyaXB0VGFnKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB1cmwgPSBudWxsLCBwYXRoID0gbnVsbCwgY29udGVudCA9IG51bGwsIHR5cGUgPSAnJyB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKGFkZFNjcmlwdFVybCwgdXJsLCB0eXBlKSkuYXNFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvYWRpbmcgc2NyaXB0IGZyb20gJHt1cmx9IGZhaWxlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhc3MgYSBmaWxlcGF0aCB0byBhZGRTY3JpcHRUYWcgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcyA9IGF3YWl0IGhlbHBlci5pbXBvcnRGU01vZHVsZSgpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUocGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnRlbnRzICs9ICcvLyMgc291cmNlVVJMPScgKyBwYXRoLnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGNvbnRleHQuZXZhbHVhdGVIYW5kbGUoYWRkU2NyaXB0Q29udGVudCwgY29udGVudHMsIHR5cGUpKS5hc0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKGFkZFNjcmlwdENvbnRlbnQsIGNvbnRlbnQsIHR5cGUpKS5hc0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBgdXJsYCwgYHBhdGhgIG9yIGBjb250ZW50YCBwcm9wZXJ0eScpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBhZGRTY3JpcHRVcmwodXJsLCB0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlcztcbiAgICAgICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IHJlajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkU2NyaXB0Q29udGVudChjb250ZW50LCB0eXBlID0gJ3RleHQvamF2YXNjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgc2NyaXB0LnRleHQgPSBjb250ZW50O1xuICAgICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gKGUpID0+IChlcnJvciA9IGUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgdGFnIGludG8gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHBhc3MgYSBVUkwsIGZpbGVwYXRoIG9yIHN0cmluZyBvZiBjb250ZW50cy4gTm90ZSB0aGF0IHdoZW4gcnVubmluZyBQdXBwZXRlZXJcbiAgICAgKiBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQgeW91IGNhbm5vdCBwYXNzIGEgZmlsZXBhdGggYW5kIHNob3VsZCB1c2UgZWl0aGVyXG4gICAgICogYHVybGAgb3IgYGNvbnRlbnRgLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgYWRkU3R5bGVUYWcob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHVybCA9IG51bGwsIHBhdGggPSBudWxsLCBjb250ZW50ID0gbnVsbCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKGFkZFN0eWxlVXJsLCB1cmwpKS5hc0VsZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9hZGluZyBzdHlsZSBmcm9tICR7dXJsfSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXNzIGEgZmlsZXBhdGggdG8gYWRkU3R5bGVUYWcgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcyA9IGF3YWl0IGhlbHBlci5pbXBvcnRGU01vZHVsZSgpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUocGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnRlbnRzICs9ICcvKiMgc291cmNlVVJMPScgKyBwYXRoLnJlcGxhY2UoL1xcbi9nLCAnJykgKyAnKi8nO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKGFkZFN0eWxlQ29udGVudCwgY29udGVudHMpKS5hc0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKGFkZFN0eWxlQ29udGVudCwgY29udGVudCkpLmFzRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBhIGB1cmxgLCBgcGF0aGAgb3IgYGNvbnRlbnRgIHByb3BlcnR5Jyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGFkZFN0eWxlVXJsKHVybCkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmsub25sb2FkID0gcmVzO1xuICAgICAgICAgICAgICAgIGxpbmsub25lcnJvciA9IHJlajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBhZGRTdHlsZUNvbnRlbnQoY29udGVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgc3R5bGUub25sb2FkID0gcmVzO1xuICAgICAgICAgICAgICAgIHN0eWxlLm9uZXJyb3IgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGljayhzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLiQoc2VsZWN0b3IpO1xuICAgICAgICBhc3NlcnQoaGFuZGxlLCAnTm8gbm9kZSBmb3VuZCBmb3Igc2VsZWN0b3I6ICcgKyBzZWxlY3Rvcik7XG4gICAgICAgIGF3YWl0IGhhbmRsZS5jbGljayhvcHRpb25zKTtcbiAgICAgICAgYXdhaXQgaGFuZGxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgZm9jdXMoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgICAgYXNzZXJ0KGhhbmRsZSwgJ05vIG5vZGUgZm91bmQgZm9yIHNlbGVjdG9yOiAnICsgc2VsZWN0b3IpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuZm9jdXMoKTtcbiAgICAgICAgYXdhaXQgaGFuZGxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgaG92ZXIoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgICAgYXNzZXJ0KGhhbmRsZSwgJ05vIG5vZGUgZm91bmQgZm9yIHNlbGVjdG9yOiAnICsgc2VsZWN0b3IpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuaG92ZXIoKTtcbiAgICAgICAgYXdhaXQgaGFuZGxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VsZWN0KHNlbGVjdG9yLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgICAgYXNzZXJ0KGhhbmRsZSwgJ05vIG5vZGUgZm91bmQgZm9yIHNlbGVjdG9yOiAnICsgc2VsZWN0b3IpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGUuc2VsZWN0KC4uLnZhbHVlcyk7XG4gICAgICAgIGF3YWl0IGhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHRhcChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLiQoc2VsZWN0b3IpO1xuICAgICAgICBhd2FpdCBoYW5kbGUudGFwKCk7XG4gICAgICAgIGF3YWl0IGhhbmRsZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGFzeW5jIHR5cGUoc2VsZWN0b3IsIHRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgICAgYXNzZXJ0KGhhbmRsZSwgJ05vIG5vZGUgZm91bmQgZm9yIHNlbGVjdG9yOiAnICsgc2VsZWN0b3IpO1xuICAgICAgICBhd2FpdCBoYW5kbGUudHlwZSh0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgYXdhaXQgaGFuZGxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclNlbGVjdG9yKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlZFNlbGVjdG9yLCBxdWVyeUhhbmRsZXIgfSA9IGdldFF1ZXJ5SGFuZGxlckFuZFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlci53YWl0Rm9yKHRoaXMsIHVwZGF0ZWRTZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIGFkZEJpbmRpbmdUb0NvbnRleHQoY29udGV4dCwgbmFtZSkge1xuICAgICAgICAvLyBQcmV2aW91cyBvcGVyYXRpb24gYWRkZWQgdGhlIGJpbmRpbmcgc28gd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICh0aGlzLl9jdHhCaW5kaW5ncy5oYXMoRE9NV29ybGQuYmluZGluZ0lkZW50aWZpZXIobmFtZSwgY29udGV4dC5fY29udGV4dElkKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBvdGhlciBvcGVyYXRpb24gdG8gZmluaXNoXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5nVXBCaW5kaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR0aW5nVXBCaW5kaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQmluZGluZ1RvQ29udGV4dChjb250ZXh0LCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5kID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBoZWxwZXIucGFnZUJpbmRpbmdJbml0U3RyaW5nKCdpbnRlcm5hbCcsIG5hbWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbiB0aGVvcnksIGl0IHdvdWxkIGJlIGVub3VnaCB0byBjYWxsIHRoaXMganVzdCBvbmNlXG4gICAgICAgICAgICAgICAgYXdhaXQgY29udGV4dC5fY2xpZW50LnNlbmQoJ1J1bnRpbWUuYWRkQmluZGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBwcm90b2NvbCBkZWZpbml0aW9uIGlzIG5vdCB1cCB0byBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0TmFtZTogY29udGV4dC5fY29udGV4dE5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29udGV4dC5ldmFsdWF0ZShleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGhhdmUgdHJpZWQgdG8gZXZhbHVhdGUgaW4gYSBjb250ZXh0IHdoaWNoIHdhcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gZGVzdHJveWVkLiBUaGlzIGhhcHBlbnMsIGZvciBleGFtcGxlLCBpZiB0aGUgcGFnZSBpcyBuYXZpZ2F0ZWQgd2hpbGVcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgdHJ5aW5nIHRvIGFkZCB0aGUgYmluZGluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eERlc3Ryb3llZCA9IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0V4ZWN1dGlvbiBjb250ZXh0IHdhcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHhOb3RGb3VuZCA9IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0Nhbm5vdCBmaW5kIGNvbnRleHQgd2l0aCBzcGVjaWZpZWQgaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4RGVzdHJveWVkIHx8IGN0eE5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3R4QmluZGluZ3MuYWRkKERPTVdvcmxkLmJpbmRpbmdJZGVudGlmaWVyKG5hbWUsIGNvbnRleHQuX2NvbnRleHRJZCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXR0aW5nVXBCaW5kaW5nID0gYmluZChuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2V0dGluZ1VwQmluZGluZztcbiAgICAgICAgdGhpcy5fc2V0dGluZ1VwQmluZGluZyA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIF9vbkJpbmRpbmdDYWxsZWQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICAgIGlmICghdGhpcy5faGFzQ29udGV4dCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBUaGUgYmluZGluZyB3YXMgZWl0aGVyIGNhbGxlZCBieSBzb21ldGhpbmcgaW4gdGhlIHBhZ2Ugb3IgaXQgd2FzXG4gICAgICAgICAgICAvLyBjYWxsZWQgYmVmb3JlIG91ciB3cmFwcGVyIHdhcyBpbml0aWFsaXplZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGUsIG5hbWUsIHNlcSwgYXJncyB9ID0gcGF5bG9hZDtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdpbnRlcm5hbCcgfHxcbiAgICAgICAgICAgICF0aGlzLl9jdHhCaW5kaW5ncy5oYXMoRE9NV29ybGQuYmluZGluZ0lkZW50aWZpZXIobmFtZSwgY29udGV4dC5fY29udGV4dElkKSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjb250ZXh0Ll9jb250ZXh0SWQgIT09IGV2ZW50LmV4ZWN1dGlvbkNvbnRleHRJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2JvdW5kRnVuY3Rpb25zLmdldChuYW1lKSguLi5hcmdzKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbnRleHQuZXZhbHVhdGUoZGVsaXZlclJlc3VsdCwgbmFtZSwgc2VxLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVGhlIFdhaXRUYXNrIG1heSBhbHJlYWR5IGhhdmUgYmVlbiByZXNvbHZlZCBieSB0aW1pbmcgb3V0LCBvciB0aGVcbiAgICAgICAgICAgIC8vIGV4ZWN0aW9uIGNvbnRleHQgbWF5IGhhdmUgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAgICAvLyBJbiBib3RoIGNhZXMsIHRoZSBwcm9taXNlcyBhYm92ZSBhcmUgcmVqZWN0ZWQgd2l0aCBhIHByb3RvY29sIGVycm9yLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNhZmVseSBpZ25vcmVzIHRoZXNlLCBhcyB0aGUgV2FpdFRhc2sgaXMgcmUtaW5zdGFsbGVkIGluXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCBleGVjdXRpb24gY29udGV4dCBpZiBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnUHJvdG9jb2wgZXJyb3InKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxpdmVyUmVzdWx0KG5hbWUsIHNlcSwgcmVzdWx0KSB7XG4gICAgICAgICAgICBnbG9iYWxUaGlzW25hbWVdLmNhbGxiYWNrcy5nZXQoc2VxKS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICBnbG9iYWxUaGlzW25hbWVdLmNhbGxiYWNrcy5kZWxldGUoc2VxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yU2VsZWN0b3JJblBhZ2UocXVlcnlPbmUsIHNlbGVjdG9yLCBvcHRpb25zLCBiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJsZTogd2FpdEZvclZpc2libGUgPSBmYWxzZSwgaGlkZGVuOiB3YWl0Rm9ySGlkZGVuID0gZmFsc2UsIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0U2V0dGluZ3MudGltZW91dCgpLCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcG9sbGluZyA9IHdhaXRGb3JWaXNpYmxlIHx8IHdhaXRGb3JIaWRkZW4gPyAncmFmJyA6ICdtdXRhdGlvbic7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gYHNlbGVjdG9yIFxcYCR7c2VsZWN0b3J9XFxgJHt3YWl0Rm9ySGlkZGVuID8gJyB0byBiZSBoaWRkZW4nIDogJyd9YDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJlZGljYXRlKHNlbGVjdG9yLCB3YWl0Rm9yVmlzaWJsZSwgd2FpdEZvckhpZGRlbikge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHByZWRpY2F0ZVF1ZXJ5SGFuZGxlclxuICAgICAgICAgICAgICAgID8gKGF3YWl0IHByZWRpY2F0ZVF1ZXJ5SGFuZGxlcihkb2N1bWVudCwgc2VsZWN0b3IpKVxuICAgICAgICAgICAgICAgIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tXYWl0Rm9yT3B0aW9ucyhub2RlLCB3YWl0Rm9yVmlzaWJsZSwgd2FpdEZvckhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FpdFRhc2tPcHRpb25zID0ge1xuICAgICAgICAgICAgZG9tV29ybGQ6IHRoaXMsXG4gICAgICAgICAgICBwcmVkaWNhdGVCb2R5OiBoZWxwZXIubWFrZVByZWRpY2F0ZVN0cmluZyhwcmVkaWNhdGUsIHF1ZXJ5T25lKSxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgcG9sbGluZyxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBhcmdzOiBbc2VsZWN0b3IsIHdhaXRGb3JWaXNpYmxlLCB3YWl0Rm9ySGlkZGVuXSxcbiAgICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRUYXNrID0gbmV3IFdhaXRUYXNrKHdhaXRUYXNrT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGpzSGFuZGxlID0gYXdhaXQgd2FpdFRhc2sucHJvbWlzZTtcbiAgICAgICAgY29uc3QgZWxlbWVudEhhbmRsZSA9IGpzSGFuZGxlLmFzRWxlbWVudCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnRIYW5kbGUpIHtcbiAgICAgICAgICAgIGF3YWl0IGpzSGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50SGFuZGxlO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yWFBhdGgoeHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlOiB3YWl0Rm9yVmlzaWJsZSA9IGZhbHNlLCBoaWRkZW46IHdhaXRGb3JIaWRkZW4gPSBmYWxzZSwgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCksIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBwb2xsaW5nID0gd2FpdEZvclZpc2libGUgfHwgd2FpdEZvckhpZGRlbiA/ICdyYWYnIDogJ211dGF0aW9uJztcbiAgICAgICAgY29uc3QgdGl0bGUgPSBgWFBhdGggXFxgJHt4cGF0aH1cXGAke3dhaXRGb3JIaWRkZW4gPyAnIHRvIGJlIGhpZGRlbicgOiAnJ31gO1xuICAgICAgICBmdW5jdGlvbiBwcmVkaWNhdGUoeHBhdGgsIHdhaXRGb3JWaXNpYmxlLCB3YWl0Rm9ySGlkZGVuKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuZXZhbHVhdGUoeHBhdGgsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRSwgbnVsbCkuc2luZ2xlTm9kZVZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrV2FpdEZvck9wdGlvbnMobm9kZSwgd2FpdEZvclZpc2libGUsIHdhaXRGb3JIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhaXRUYXNrT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRvbVdvcmxkOiB0aGlzLFxuICAgICAgICAgICAgcHJlZGljYXRlQm9keTogaGVscGVyLm1ha2VQcmVkaWNhdGVTdHJpbmcocHJlZGljYXRlKSxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgcG9sbGluZyxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBhcmdzOiBbeHBhdGgsIHdhaXRGb3JWaXNpYmxlLCB3YWl0Rm9ySGlkZGVuXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2FpdFRhc2sgPSBuZXcgV2FpdFRhc2sod2FpdFRhc2tPcHRpb25zKTtcbiAgICAgICAgY29uc3QganNIYW5kbGUgPSBhd2FpdCB3YWl0VGFzay5wcm9taXNlO1xuICAgICAgICBjb25zdCBlbGVtZW50SGFuZGxlID0ganNIYW5kbGUuYXNFbGVtZW50KCk7XG4gICAgICAgIGlmICghZWxlbWVudEhhbmRsZSkge1xuICAgICAgICAgICAgYXdhaXQganNIYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRIYW5kbGU7XG4gICAgfVxuICAgIHdhaXRGb3JGdW5jdGlvbihwYWdlRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCB7IHBvbGxpbmcgPSAncmFmJywgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCkgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHdhaXRUYXNrT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRvbVdvcmxkOiB0aGlzLFxuICAgICAgICAgICAgcHJlZGljYXRlQm9keTogcGFnZUZ1bmN0aW9uLFxuICAgICAgICAgICAgdGl0bGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBwb2xsaW5nLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRUYXNrID0gbmV3IFdhaXRUYXNrKHdhaXRUYXNrT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB3YWl0VGFzay5wcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGUoKCkgPT4gZG9jdW1lbnQudGl0bGUpO1xuICAgIH1cbn1cbkRPTVdvcmxkLmJpbmRpbmdJZGVudGlmaWVyID0gKG5hbWUsIGNvbnRleHRJZCkgPT4gYCR7bmFtZX1fJHtjb250ZXh0SWR9YDtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWl0VGFzayB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9ydW5Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGhlbHBlci5pc1N0cmluZyhvcHRpb25zLnBvbGxpbmcpKVxuICAgICAgICAgICAgYXNzZXJ0KG9wdGlvbnMucG9sbGluZyA9PT0gJ3JhZicgfHwgb3B0aW9ucy5wb2xsaW5nID09PSAnbXV0YXRpb24nLCAnVW5rbm93biBwb2xsaW5nIG9wdGlvbjogJyArIG9wdGlvbnMucG9sbGluZyk7XG4gICAgICAgIGVsc2UgaWYgKGhlbHBlci5pc051bWJlcihvcHRpb25zLnBvbGxpbmcpKVxuICAgICAgICAgICAgYXNzZXJ0KG9wdGlvbnMucG9sbGluZyA+IDAsICdDYW5ub3QgcG9sbCB3aXRoIG5vbi1wb3NpdGl2ZSBpbnRlcnZhbDogJyArIG9wdGlvbnMucG9sbGluZyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2xsaW5nIG9wdGlvbnM6ICcgKyBvcHRpb25zLnBvbGxpbmcpO1xuICAgICAgICBmdW5jdGlvbiBnZXRQcmVkaWNhdGVCb2R5KHByZWRpY2F0ZUJvZHkpIHtcbiAgICAgICAgICAgIGlmIChoZWxwZXIuaXNTdHJpbmcocHJlZGljYXRlQm9keSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gKCR7cHJlZGljYXRlQm9keX0pO2A7XG4gICAgICAgICAgICByZXR1cm4gYHJldHVybiAoJHtwcmVkaWNhdGVCb2R5fSkoLi4uYXJncyk7YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kb21Xb3JsZCA9IG9wdGlvbnMuZG9tV29ybGQ7XG4gICAgICAgIHRoaXMuX3BvbGxpbmcgPSBvcHRpb25zLnBvbGxpbmc7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3ByZWRpY2F0ZUJvZHkgPSBnZXRQcmVkaWNhdGVCb2R5KG9wdGlvbnMucHJlZGljYXRlQm9keSk7XG4gICAgICAgIHRoaXMuX2FyZ3MgPSBvcHRpb25zLmFyZ3M7XG4gICAgICAgIHRoaXMuX2JpbmRpbmcgPSBvcHRpb25zLmJpbmRpbmc7XG4gICAgICAgIHRoaXMuX3J1bkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fZG9tV29ybGQuX3dhaXRUYXNrcy5hZGQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9iaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9kb21Xb3JsZC5fYm91bmRGdW5jdGlvbnMuc2V0KHRoaXMuX2JpbmRpbmcubmFtZSwgdGhpcy5fYmluZGluZy5wcHRyRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2luY2UgcGFnZSBuYXZpZ2F0aW9uIHJlcXVpcmVzIHVzIHRvIHJlLWluc3RhbGwgdGhlIHBhZ2VTY3JpcHQsIHdlIHNob3VsZCB0cmFja1xuICAgICAgICAvLyB0aW1lb3V0IG9uIG91ciBlbmQuXG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBUaW1lb3V0RXJyb3IoYHdhaXRpbmcgZm9yICR7b3B0aW9ucy50aXRsZX0gZmFpbGVkOiB0aW1lb3V0ICR7b3B0aW9ucy50aW1lb3V0fW1zIGV4Y2VlZGVkYCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudGVybWluYXRlKHRpbWVvdXRFcnJvciksIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXJ1bigpO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVydW4oKSB7XG4gICAgICAgIGNvbnN0IHJ1bkNvdW50ID0gKyt0aGlzLl9ydW5Db3VudDtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5fZG9tV29ybGQuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5fdGVybWluYXRlZCB8fCBydW5Db3VudCAhPT0gdGhpcy5fcnVuQ291bnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9iaW5kaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kb21Xb3JsZC5hZGRCaW5kaW5nVG9Db250ZXh0KGNvbnRleHQsIHRoaXMuX2JpbmRpbmcubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZWQgfHwgcnVuQ291bnQgIT09IHRoaXMuX3J1bkNvdW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VzcyA9IGF3YWl0IGNvbnRleHQuZXZhbHVhdGVIYW5kbGUod2FpdEZvclByZWRpY2F0ZVBhZ2VGdW5jdGlvbiwgdGhpcy5fcHJlZGljYXRlQm9keSwgdGhpcy5fcG9sbGluZywgdGhpcy5fdGltZW91dCwgLi4udGhpcy5fYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgZXJyb3IgPSBlcnJvcl87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Rlcm1pbmF0ZWQgfHwgcnVuQ291bnQgIT09IHRoaXMuX3J1bkNvdW50KSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICBhd2FpdCBzdWNjZXNzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgdGltZW91dHMgaW4gcGFnZVNjcmlwdCAtIHdlIHRyYWNrIHRpbWVvdXRzIG91cnNlbHZlcy5cbiAgICAgICAgLy8gSWYgdGhlIGZyYW1lJ3MgZXhlY3V0aW9uIGNvbnRleHQgaGFzIGFscmVhZHkgY2hhbmdlZCwgYGZyYW1lLmV2YWx1YXRlYCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yIC0gaWdub3JlIHRoaXMgcHJlZGljYXRlIHJ1biBhbHRvZ2V0aGVyLlxuICAgICAgICBpZiAoIWVycm9yICYmXG4gICAgICAgICAgICAoYXdhaXQgdGhpcy5fZG9tV29ybGQuZXZhbHVhdGUoKHMpID0+ICFzLCBzdWNjZXNzKS5jYXRjaCgoKSA9PiB0cnVlKSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHN1Y2Nlc3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1R5cGVFcnJvcjogYmluZGluZyBpcyBub3QgYSBmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gZnJhbWUgaXMgZGV0YWNoZWQgdGhlIHRhc2sgc2hvdWxkIGhhdmUgYmVlbiB0ZXJtaW5hdGVkIGJ5IHRoZSBET01Xb3JsZC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGZhaWwgaWYgd2Ugd2VyZSBhZGRpbmcgdGhpcyB0YXNrIHdoaWxlIHRoZSBmcmFtZSB3YXMgZGV0YWNoZWQsXG4gICAgICAgICAgICAvLyBzbyB3ZSB0ZXJtaW5hdGUgaGVyZSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0V4ZWN1dGlvbiBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gZGV0YWNoZWQgZnJhbWUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlKG5ldyBFcnJvcignd2FpdEZvckZ1bmN0aW9uIGZhaWxlZDogZnJhbWUgZ290IGRldGFjaGVkLicpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGlzIG5hdmlnYXRlZCwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHRyeSBhZ2FpbiBpbiB0aGUgbmV3IGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0V4ZWN1dGlvbiBjb250ZXh0IHdhcyBkZXN0cm95ZWQnKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCBoYXZlIHRyaWVkIHRvIGV2YWx1YXRlIGluIGEgY29udGV4dCB3aGljaCB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgLy8gZGVzdHJveWVkLlxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0Nhbm5vdCBmaW5kIGNvbnRleHQgd2l0aCBzcGVjaWZpZWQgaWQnKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZShzdWNjZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgfVxuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy5fZG9tV29ybGQuX3dhaXRUYXNrcy5kZWxldGUodGhpcyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclByZWRpY2F0ZVBhZ2VGdW5jdGlvbihwcmVkaWNhdGVCb2R5LCBwb2xsaW5nLCB0aW1lb3V0LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgcHJlZGljYXRlID0gbmV3IEZ1bmN0aW9uKCcuLi5hcmdzJywgcHJlZGljYXRlQm9keSk7XG4gICAgbGV0IHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgaWYgKHRpbWVvdXQpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gKHRpbWVkT3V0ID0gdHJ1ZSksIHRpbWVvdXQpO1xuICAgIGlmIChwb2xsaW5nID09PSAncmFmJylcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBvbGxSYWYoKTtcbiAgICBpZiAocG9sbGluZyA9PT0gJ211dGF0aW9uJylcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBvbGxNdXRhdGlvbigpO1xuICAgIGlmICh0eXBlb2YgcG9sbGluZyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBhd2FpdCBwb2xsSW50ZXJ2YWwocG9sbGluZyk7XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyFQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHBvbGxNdXRhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHByZWRpY2F0ZSguLi5hcmdzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN1Y2Nlc3MpO1xuICAgICAgICBsZXQgZnVsZmlsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHgpID0+IChmdWxmaWxsID0geCkpO1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgcHJlZGljYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZnVsZmlsbChzdWNjZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcG9sbFJhZigpIHtcbiAgICAgICAgbGV0IGZ1bGZpbGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKCh4KSA9PiAoZnVsZmlsbCA9IHgpKTtcbiAgICAgICAgYXdhaXQgb25SYWYoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gb25SYWYoKSB7XG4gICAgICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHByZWRpY2F0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc3VjY2Vzcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uUmFmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwb2xsSW50ZXJ2YWwocG9sbEludGVydmFsKSB7XG4gICAgICAgIGxldCBmdWxmaWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZSgoeCkgPT4gKGZ1bGZpbGwgPSB4KSk7XG4gICAgICAgIGF3YWl0IG9uVGltZW91dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAodGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHByZWRpY2F0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc3VjY2Vzcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChvblRpbWVvdXQsIHBvbGxJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ET01Xb3JsZC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9lbnZpcm9ubWVudC5qcyc7XG4vKipcbiAqIEEgZGVidWcgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBhbnkgZW52aXJvbm1lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBJZiB1c2VkIGluIE5vZGUsIGl0IGZhbGxzIGJhY2sgdG8gdGhlXG4gKiB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVidWcgfCBkZWJ1ZyBtb2R1bGV9LiBJbiB0aGUgYnJvd3NlciBpdFxuICogdXNlcyBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBwYXJhbSBwcmVmaXggLSB0aGlzIHdpbGwgYmUgcHJlZml4ZWQgdG8gZWFjaCBsb2cuXG4gKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBsb2cgdG8gdGhhdCBkZWJ1ZyBjaGFubmVsLlxuICpcbiAqIEluIE5vZGUsIHVzZSB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBjb250cm9sIGxvZ2dpbmc6XG4gKlxuICogYGBgXG4gKiBERUJVRz0qIC8vIGxvZ3MgYWxsIGNoYW5uZWxzXG4gKiBERUJVRz1mb28gLy8gbG9ncyB0aGUgYGZvb2AgY2hhbm5lbFxuICogREVCVUc9Zm9vKiAvLyBsb2dzIGFueSBjaGFubmVscyBzdGFydGluZyB3aXRoIGBmb29gXG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgYnJvd3Nlciwgc2V0IGB3aW5kb3cuX19QVVBQRVRFRVJfREVCVUdgIHRvIGEgc3RyaW5nOlxuICpcbiAqIGBgYFxuICogd2luZG93Ll9fUFVQUEVURUVSX0RFQlVHPScqJzsgLy8gbG9ncyBhbGwgY2hhbm5lbHNcbiAqIHdpbmRvdy5fX1BVUFBFVEVFUl9ERUJVRz0nZm9vJzsgLy8gbG9ncyB0aGUgYGZvb2AgY2hhbm5lbFxuICogd2luZG93Ll9fUFVQUEVURUVSX0RFQlVHPSdmb28qJzsgLy8gbG9ncyBhbnkgY2hhbm5lbHMgc3RhcnRpbmcgd2l0aCBgZm9vYFxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbG9nID0gZGVidWcoJ1BhZ2UnKTtcbiAqXG4gKiBsb2coJ25ldyBwYWdlIGNyZWF0ZWQnKVxuICogLy8gbG9ncyBcIlBhZ2U6IG5ldyBwYWdlIGNyZWF0ZWRcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IChwcmVmaXgpID0+IHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgIHJldHVybiByZXF1aXJlKCdkZWJ1ZycpKHByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiAoLi4ubG9nQXJncykgPT4ge1xuICAgICAgICBjb25zdCBkZWJ1Z0xldmVsID0gZ2xvYmFsVGhpcy5fX1BVUFBFVEVFUl9ERUJVRztcbiAgICAgICAgaWYgKCFkZWJ1Z0xldmVsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVyeXRoaW5nU2hvdWxkQmVMb2dnZWQgPSBkZWJ1Z0xldmVsID09PSAnKic7XG4gICAgICAgIGNvbnN0IHByZWZpeE1hdGNoZXNEZWJ1Z0xldmVsID0gZXZlcnl0aGluZ1Nob3VsZEJlTG9nZ2VkIHx8XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSBkZWJ1ZyBsZXZlbCBpcyBgZm9vKmAsIHRoYXQgbWVhbnMgd2UgbWF0Y2ggYW55IHByZWZpeCB0aGF0XG4gICAgICAgICAgICAgKiBzdGFydHMgd2l0aCBgZm9vYC4gSWYgdGhlIGxldmVsIGlzIGBmb29gLCB3ZSBtYXRjaCBvbmx5IHRoZSBwcmVmaXhcbiAgICAgICAgICAgICAqIGBmb29gLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoZGVidWdMZXZlbC5lbmRzV2l0aCgnKicpXG4gICAgICAgICAgICAgICAgPyBwcmVmaXguc3RhcnRzV2l0aChkZWJ1Z0xldmVsKVxuICAgICAgICAgICAgICAgIDogcHJlZml4ID09PSBkZWJ1Z0xldmVsKTtcbiAgICAgICAgaWYgKCFwcmVmaXhNYXRjaGVzRGVidWdMZXZlbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coYCR7cHJlZml4fTpgLCAuLi5sb2dBcmdzKTtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlYnVnLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGRldmljZXMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnQmxhY2tiZXJyeSBQbGF5Qm9vaycsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChQbGF5Qm9vazsgVTsgUklNIFRhYmxldCBPUyAyLjEuMDsgZW4tVVMpIEFwcGxlV2ViS2l0LzUzNi4yKyAoS0hUTUwgbGlrZSBHZWNrbykgVmVyc2lvbi83LjIuMS4wIFNhZmFyaS81MzYuMisnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDYwMCxcbiAgICAgICAgICAgIGhlaWdodDogMTAyNCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0JsYWNrYmVycnkgUGxheUJvb2sgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKFBsYXlCb29rOyBVOyBSSU0gVGFibGV0IE9TIDIuMS4wOyBlbi1VUykgQXBwbGVXZWJLaXQvNTM2LjIrIChLSFRNTCBsaWtlIEdlY2tvKSBWZXJzaW9uLzcuMi4xLjAgU2FmYXJpLzUzNi4yKycsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMTAyNCxcbiAgICAgICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdCbGFja0JlcnJ5IFozMCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChCQjEwOyBUb3VjaCkgQXBwbGVXZWJLaXQvNTM3LjEwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTAuMC45LjIzNzIgTW9iaWxlIFNhZmFyaS81MzcuMTArJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDY0MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0JsYWNrQmVycnkgWjMwIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChCQjEwOyBUb3VjaCkgQXBwbGVXZWJLaXQvNTM3LjEwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTAuMC45LjIzNzIgTW9iaWxlIFNhZmFyaS81MzcuMTArJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDM2MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnR2FsYXh5IE5vdGUgMycsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgQW5kcm9pZCA0LjM7IGVuLXVzOyBTTS1OOTAwVCBCdWlsZC9KU1MxNUopIEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDY0MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0dhbGF4eSBOb3RlIDMgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBVOyBBbmRyb2lkIDQuMzsgZW4tdXM7IFNNLU45MDBUIEJ1aWxkL0pTUzE1SikgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzAnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogMzYwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdHYWxheHkgTm90ZSBJSScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgQW5kcm9pZCA0LjE7IGVuLXVzOyBHVC1ONzEwMCBCdWlsZC9KUk8wM0MpIEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDY0MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0dhbGF4eSBOb3RlIElJIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgQW5kcm9pZCA0LjE7IGVuLXVzOyBHVC1ONzEwMCBCdWlsZC9KUk8wM0MpIEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDM2MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnR2FsYXh5IFMgSUlJJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBVOyBBbmRyb2lkIDQuMDsgZW4tdXM7IEdULUk5MzAwIEJ1aWxkL0lNTTc2RCkgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzAnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDM2MCxcbiAgICAgICAgICAgIGhlaWdodDogNjQwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnR2FsYXh5IFMgSUlJIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgQW5kcm9pZCA0LjA7IGVuLXVzOyBHVC1JOTMwMCBCdWlsZC9JTU03NkQpIEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDM2MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnR2FsYXh5IFM1JyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgU00tRzkwMFAgQnVpbGQvTFJYMjFUKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDM2MCxcbiAgICAgICAgICAgIGhlaWdodDogNjQwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnR2FsYXh5IFM1IGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA1LjA7IFNNLUc5MDBQIEJ1aWxkL0xSWDIxVCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDM2MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBhZCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGFkOyBDUFUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zNCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBNTM0MWYgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA3NjgsXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMjQsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGFkIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGFkOyBDUFUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zNCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBNTM0MWYgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDI0LFxuICAgICAgICAgICAgaGVpZ2h0OiA3NjgsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQYWQgTWluaScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGFkOyBDUFUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zNCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBNTM0MWYgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA3NjgsXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMjQsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGFkIE1pbmkgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQYWQ7IENQVSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM0IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUE1MzQxZiBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDEwMjQsXG4gICAgICAgICAgICBoZWlnaHQ6IDc2OCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBhZCBQcm8nLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBhZDsgQ1BVIE9TIDExXzAgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA0LjEuMzQgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzExLjAgTW9iaWxlLzE1QTUzNDFmIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMTAyNCxcbiAgICAgICAgICAgIGhlaWdodDogMTM2NixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQYWQgUHJvIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGFkOyBDUFUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zNCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBNTM0MWYgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMzY2LFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDI0LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgNCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgN18xXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNTM3LjUxLjIgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzcuMCBNb2JpbGUvMTFEMjU3IFNhZmFyaS85NTM3LjUzJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzMjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSA0IGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgN18xXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNTM3LjUxLjIgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzcuMCBNb2JpbGUvMTFEMjU3IFNhZmFyaS85NTM3LjUzJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA0ODAsXG4gICAgICAgICAgICBoZWlnaHQ6IDMyMCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDEwXzNfMSBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDMuMS4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTAuMCBNb2JpbGUvMTRFMzA0IFNhZmFyaS82MDIuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMzIwLFxuICAgICAgICAgICAgaGVpZ2h0OiA1NjgsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgNSBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDEwXzNfMSBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDMuMS4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTAuMCBNb2JpbGUvMTRFMzA0IFNhZmFyaS82MDIuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNTY4LFxuICAgICAgICAgICAgaGVpZ2h0OiAzMjAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSA2JyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM4IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUEzNzIgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNzUsXG4gICAgICAgICAgICBoZWlnaHQ6IDY2NyxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSA2IGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zOCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBMzcyIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNjY3LFxuICAgICAgICAgICAgaGVpZ2h0OiAzNzUsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSA2IFBsdXMnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDExXzAgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA0LjEuMzggKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzExLjAgTW9iaWxlLzE1QTM3MiBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDQxNCxcbiAgICAgICAgICAgIGhlaWdodDogNzM2LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDYgUGx1cyBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDExXzAgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA0LjEuMzggKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzExLjAgTW9iaWxlLzE1QTM3MiBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDczNixcbiAgICAgICAgICAgIGhlaWdodDogNDE0LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgNycsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zOCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBMzcyIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMzc1LFxuICAgICAgICAgICAgaGVpZ2h0OiA2NjcsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgNyBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDExXzAgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA0LjEuMzggKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzExLjAgTW9iaWxlLzE1QTM3MiBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY2NyxcbiAgICAgICAgICAgIGhlaWdodDogMzc1LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgNyBQbHVzJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM4IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUEzNzIgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA0MTQsXG4gICAgICAgICAgICBoZWlnaHQ6IDczNixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSA3IFBsdXMgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM4IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUEzNzIgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA3MzYsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxNCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDgnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDExXzAgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA0LjEuMzggKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzExLjAgTW9iaWxlLzE1QTM3MiBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDM3NSxcbiAgICAgICAgICAgIGhlaWdodDogNjY3LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDggbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM4IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUEzNzIgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NjcsXG4gICAgICAgICAgICBoZWlnaHQ6IDM3NSxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDggUGx1cycsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zOCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBMzcyIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNDE0LFxuICAgICAgICAgICAgaGVpZ2h0OiA3MzYsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMyxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgOCBQbHVzIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zOCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBMzcyIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNzM2LFxuICAgICAgICAgICAgaGVpZ2h0OiA0MTQsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMyxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSBTRScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTBfM18xIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwMy4xLjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMC4wIE1vYmlsZS8xNEUzMDQgU2FmYXJpLzYwMi4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzMjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDU2OCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSBTRSBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDEwXzNfMSBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDMuMS4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTAuMCBNb2JpbGUvMTRFMzA0IFNhZmFyaS82MDIuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNTY4LFxuICAgICAgICAgICAgaGVpZ2h0OiAzMjAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSBYJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMV8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNC4xLjM4IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMS4wIE1vYmlsZS8xNUEzNzIgU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNzUsXG4gICAgICAgICAgICBoZWlnaHQ6IDgxMixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSBYIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTFfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDQuMS4zOCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTEuMCBNb2JpbGUvMTVBMzcyIFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogODEyLFxuICAgICAgICAgICAgaGVpZ2h0OiAzNzUsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMyxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSBYUicsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChpUGhvbmU7IENQVSBpUGhvbmUgT1MgMTJfMCBsaWtlIE1hYyBPUyBYKSBBcHBsZVdlYktpdC82MDUuMS4xNSAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vMTIuMCBNb2JpbGUvMTVFMTQ4IFNhZmFyaS82MDQuMScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNDE0LFxuICAgICAgICAgICAgaGVpZ2h0OiA4OTYsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMyxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgWFIgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMl8wIGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMi4wIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA4OTYsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxNCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDExJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxM183IGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMy4xIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA0MTQsXG4gICAgICAgICAgICBoZWlnaHQ6IDgyOCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSAxMSBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDEzXzcgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA1LjEuMTUgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzEzLjEgTW9iaWxlLzE1RTE0OCBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDgyOCxcbiAgICAgICAgICAgIGhlaWdodDogNDE0LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpUGhvbmUgMTEgUHJvJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxM183IGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMy4xIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzNzUsXG4gICAgICAgICAgICBoZWlnaHQ6IDgxMixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lQaG9uZSAxMSBQcm8gbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxM183IGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMy4xIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA4MTIsXG4gICAgICAgICAgICBoZWlnaHQ6IDM3NSxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDExIFBybyBNYXgnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoaVBob25lOyBDUFUgaVBob25lIE9TIDEzXzcgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjA1LjEuMTUgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzEzLjEgTW9iaWxlLzE1RTE0OCBTYWZhcmkvNjA0LjEnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDQxNCxcbiAgICAgICAgICAgIGhlaWdodDogODk2LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaVBob25lIDExIFBybyBNYXggbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxM183IGxpa2UgTWFjIE9TIFgpIEFwcGxlV2ViS2l0LzYwNS4xLjE1IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8xMy4xIE1vYmlsZS8xNUUxNDggU2FmYXJpLzYwNC4xJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA4OTYsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxNCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSmlvUGhvbmUgMicsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChNb2JpbGU7IExZRi9GMzAwQi9MWUYtRjMwMEItMDAxLTAxLTE1LTEzMDcxOC1pO0FuZHJvaWQ7IHJ2OjQ4LjApIEdlY2tvLzQ4LjAgRmlyZWZveC80OC4wIEtBSU9TLzIuNScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiAzMjAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdKaW9QaG9uZSAyIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChNb2JpbGU7IExZRi9GMzAwQi9MWUYtRjMwMEItMDAxLTAxLTE1LTEzMDcxOC1pO0FuZHJvaWQ7IHJ2OjQ4LjApIEdlY2tvLzQ4LjAgRmlyZWZveC80OC4wIEtBSU9TLzIuNScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMzIwLFxuICAgICAgICAgICAgaGVpZ2h0OiAyNDAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0tpbmRsZSBGaXJlIEhEWCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgZW4tdXM7IEtGQVBXSSBCdWlsZC9KRFEzOSkgQXBwbGVXZWJLaXQvNTM1LjE5IChLSFRNTCwgbGlrZSBHZWNrbykgU2lsay8zLjEzIFNhZmFyaS81MzUuMTkgU2lsay1BY2NlbGVyYXRlZD10cnVlJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDEyODAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdLaW5kbGUgRmlyZSBIRFggbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBVOyBlbi11czsgS0ZBUFdJIEJ1aWxkL0pEUTM5KSBBcHBsZVdlYktpdC81MzUuMTkgKEtIVE1MLCBsaWtlIEdlY2tvKSBTaWxrLzMuMTMgU2FmYXJpLzUzNS4xOSBTaWxrLUFjY2VsZXJhdGVkPXRydWUnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgICAgICBoZWlnaHQ6IDgwMCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTEcgT3B0aW11cyBMNzAnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IFU7IEFuZHJvaWQgNC40LjI7IGVuLXVzOyBMR01TMzIzIEJ1aWxkL0tPVDQ5SS5NUzMyMzEwYykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAzODQsXG4gICAgICAgICAgICBoZWlnaHQ6IDY0MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAxLjI1LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0xHIE9wdGltdXMgTDcwIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgVTsgQW5kcm9pZCA0LjQuMjsgZW4tdXM7IExHTVMzMjMgQnVpbGQvS09UNDlJLk1TMzIzMTBjKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogMzg0LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDEuMjUsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdNaWNyb3NvZnQgTHVtaWEgNTUwJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKFdpbmRvd3MgUGhvbmUgMTAuMDsgQW5kcm9pZCA0LjIuMTsgTWljcm9zb2Z0OyBMdW1pYSA1NTApIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS80Ni4wLjI0ODYuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiBFZGdlLzE0LjE0MjYzJyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDM2MCxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ01pY3Jvc29mdCBMdW1pYSA5NTAnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBQaG9uZSAxMC4wOyBBbmRyb2lkIDQuMi4xOyBNaWNyb3NvZnQ7IEx1bWlhIDk1MCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzQ2LjAuMjQ4Ni4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IEVkZ2UvMTQuMTQyNjMnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDM2MCxcbiAgICAgICAgICAgIGhlaWdodDogNjQwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDQsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTWljcm9zb2Z0IEx1bWlhIDk1MCBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBQaG9uZSAxMC4wOyBBbmRyb2lkIDQuMi4xOyBNaWNyb3NvZnQ7IEx1bWlhIDk1MCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzQ2LjAuMjQ4Ni4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IEVkZ2UvMTQuMTQyNjMnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogMzYwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDQsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyAxMCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA2LjAuMTsgTmV4dXMgMTAgQnVpbGQvTU9CMzFUKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogODAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAxMjgwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTmV4dXMgMTAgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDYuMC4xOyBOZXh1cyAxMCBCdWlsZC9NT0IzMVQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS83NS4wLjM3NjUuMCBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMjgwLFxuICAgICAgICAgICAgaGVpZ2h0OiA4MDAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05leHVzIDQnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjI7IE5leHVzIDQgQnVpbGQvS09UNDlIKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDM4NCxcbiAgICAgICAgICAgIGhlaWdodDogNjQwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTmV4dXMgNCBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjI7IE5leHVzIDQgQnVpbGQvS09UNDlIKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogMzg0LFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA1JyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDYuMDsgTmV4dXMgNSBCdWlsZC9NUkE1OE4pIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS83NS4wLjM3NjUuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogMzYwLFxuICAgICAgICAgICAgaGVpZ2h0OiA2NDAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMyxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA1IGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA2LjA7IE5leHVzIDUgQnVpbGQvTVJBNThOKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogMzYwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA1WCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA4LjAuMDsgTmV4dXMgNVggQnVpbGQvT1BSNC4xNzA2MjMuMDA2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDQxMixcbiAgICAgICAgICAgIGhlaWdodDogNzMyLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIuNjI1LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05leHVzIDVYIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA4LjAuMDsgTmV4dXMgNVggQnVpbGQvT1BSNC4xNzA2MjMuMDA2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDczMixcbiAgICAgICAgICAgIGhlaWdodDogNDEyLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIuNjI1LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTmV4dXMgNicsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjEuMTsgTmV4dXMgNiBCdWlsZC9ONkYyNlUpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS83NS4wLjM3NjUuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNDEyLFxuICAgICAgICAgICAgaGVpZ2h0OiA3MzIsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMy41LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05leHVzIDYgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDcuMS4xOyBOZXh1cyA2IEJ1aWxkL042RjI2VSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA3MzIsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxMixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLjUsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA2UCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA4LjAuMDsgTmV4dXMgNlAgQnVpbGQvT1BQMy4xNzA1MTguMDA2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDQxMixcbiAgICAgICAgICAgIGhlaWdodDogNzMyLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDMuNSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA2UCBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgOC4wLjA7IE5leHVzIDZQIEJ1aWxkL09QUDMuMTcwNTE4LjAwNikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA3MzIsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxMixcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLjUsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOZXh1cyA3JyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDYuMC4xOyBOZXh1cyA3IEJ1aWxkL01PQjMwWCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDYwMCxcbiAgICAgICAgICAgIGhlaWdodDogOTYwLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTmV4dXMgNyBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wLjE7IE5leHVzIDcgQnVpbGQvTU9CMzBYKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogOTYwLFxuICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMixcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ05va2lhIEx1bWlhIDUyMCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChjb21wYXRpYmxlOyBNU0lFIDEwLjA7IFdpbmRvd3MgUGhvbmUgOC4wOyBUcmlkZW50LzYuMDsgSUVNb2JpbGUvMTAuMDsgQVJNOyBUb3VjaDsgTk9LSUE7IEx1bWlhIDUyMCknLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDMyMCxcbiAgICAgICAgICAgIGhlaWdodDogNTMzLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDEuNSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOb2tpYSBMdW1pYSA1MjAgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBQaG9uZSA4LjA7IFRyaWRlbnQvNi4wOyBJRU1vYmlsZS8xMC4wOyBBUk07IFRvdWNoOyBOT0tJQTsgTHVtaWEgNTIwKScsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNTMzLFxuICAgICAgICAgICAgaGVpZ2h0OiAzMjAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMS41LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnTm9raWEgTjknLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTWVlR287IE5va2lhTjkpIEFwcGxlV2ViS2l0LzUzNC4xMyAoS0hUTUwsIGxpa2UgR2Vja28pIE5va2lhQnJvd3Nlci84LjUuMCBNb2JpbGUgU2FmYXJpLzUzNC4xMycsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNDgwLFxuICAgICAgICAgICAgaGVpZ2h0OiA4NTQsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOb2tpYSBOOSBsYW5kc2NhcGUnLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTWVlR287IE5va2lhTjkpIEFwcGxlV2ViS2l0LzUzNC4xMyAoS0hUTUwsIGxpa2UgR2Vja28pIE5va2lhQnJvd3Nlci84LjUuMCBNb2JpbGUgU2FmYXJpLzUzNC4xMycsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogODU0LFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1BpeGVsIDInLFxuICAgICAgICB1c2VyQWdlbnQ6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgOC4wOyBQaXhlbCAyIEJ1aWxkL09QRDMuMTcwODE2LjAxMikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA0MTEsXG4gICAgICAgICAgICBoZWlnaHQ6IDczMSxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAyLjYyNSxcbiAgICAgICAgICAgIGlzTW9iaWxlOiB0cnVlLFxuICAgICAgICAgICAgaGFzVG91Y2g6IHRydWUsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdQaXhlbCAyIGxhbmRzY2FwZScsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA4LjA7IFBpeGVsIDIgQnVpbGQvT1BEMy4xNzA4MTYuMDEyKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzUuMC4zNzY1LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYnLFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgd2lkdGg6IDczMSxcbiAgICAgICAgICAgIGhlaWdodDogNDExLFxuICAgICAgICAgICAgZGV2aWNlU2NhbGVGYWN0b3I6IDIuNjI1LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnUGl4ZWwgMiBYTCcsXG4gICAgICAgIHVzZXJBZ2VudDogJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA4LjAuMDsgUGl4ZWwgMiBYTCBCdWlsZC9PUEQxLjE3MDgxNi4wMDQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS83NS4wLjM3NjUuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICB3aWR0aDogNDExLFxuICAgICAgICAgICAgaGVpZ2h0OiA4MjMsXG4gICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogMy41LFxuICAgICAgICAgICAgaXNNb2JpbGU6IHRydWUsXG4gICAgICAgICAgICBoYXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFuZHNjYXBlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1BpeGVsIDIgWEwgbGFuZHNjYXBlJyxcbiAgICAgICAgdXNlckFnZW50OiAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDguMC4wOyBQaXhlbCAyIFhMIEJ1aWxkL09QRDEuMTcwODE2LjAwNCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzc1LjAuMzc2NS4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiA4MjMsXG4gICAgICAgICAgICBoZWlnaHQ6IDQxMSxcbiAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yOiAzLjUsXG4gICAgICAgICAgICBpc01vYmlsZTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgaXNMYW5kc2NhcGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbl07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgZGV2aWNlc01hcCA9IHt9O1xuZm9yIChjb25zdCBkZXZpY2Ugb2YgZGV2aWNlcylcbiAgICBkZXZpY2VzTWFwW2RldmljZS5uYW1lXSA9IGRldmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURldmljZURlc2NyaXB0b3JzLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbi8qKlxuICogRGlhbG9nIGluc3RhbmNlcyBhcmUgZGlzcGF0Y2hlZCBieSB0aGUge0BsaW5rIFBhZ2V9IHZpYSB0aGUgYGRpYWxvZ2AgZXZlbnQuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IHB1cHBldGVlciA9IHJlcXVpcmUoJ3B1cHBldGVlcicpO1xuICpcbiAqIChhc3luYyAoKSA9PiB7XG4gKiAgIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKCk7XG4gKiAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAqICAgcGFnZS5vbignZGlhbG9nJywgYXN5bmMgZGlhbG9nID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhkaWFsb2cubWVzc2FnZSgpKTtcbiAqICAgICBhd2FpdCBkaWFsb2cuZGlzbWlzcygpO1xuICogICAgIGF3YWl0IGJyb3dzZXIuY2xvc2UoKTtcbiAqICAgfSk7XG4gKiAgIHBhZ2UuZXZhbHVhdGUoKCkgPT4gYWxlcnQoJzEnKSk7XG4gKiB9KSgpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWFsb2cge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgdHlwZSwgbWVzc2FnZSwgZGVmYXVsdFZhbHVlID0gJycpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgZGlhbG9nLlxuICAgICAqL1xuICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBkaXNwbGF5ZWQgaW4gdGhlIGRpYWxvZy5cbiAgICAgKi9cbiAgICBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHByb21wdCwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBkaWFsb2dcbiAgICAgKiBpcyBub3QgYSBgcHJvbXB0YC5cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwcm9tcHRUZXh0IC0gb3B0aW9uYWwgdGV4dCB0aGF0IHdpbGwgYmUgZW50ZXJlZCBpbiB0aGUgZGlhbG9nXG4gICAgICogcHJvbXB0LiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBkaWFsb2cncyB0eXBlIGlzIG5vdCBgcHJvbXB0YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGRpYWxvZyBoYXMgYmVlbiBhY2NlcHRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhY2NlcHQocHJvbXB0VGV4dCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2hhbmRsZWQsICdDYW5ub3QgYWNjZXB0IGRpYWxvZyB3aGljaCBpcyBhbHJlYWR5IGhhbmRsZWQhJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5oYW5kbGVKYXZhU2NyaXB0RGlhbG9nJywge1xuICAgICAgICAgICAgYWNjZXB0OiB0cnVlLFxuICAgICAgICAgICAgcHJvbXB0VGV4dDogcHJvbXB0VGV4dCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgb25jZSB0aGUgZGlhbG9nIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGRpc21pc3MoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5faGFuZGxlZCwgJ0Nhbm5vdCBkaXNtaXNzIGRpYWxvZyB3aGljaCBpcyBhbHJlYWR5IGhhbmRsZWQhJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5oYW5kbGVKYXZhU2NyaXB0RGlhbG9nJywge1xuICAgICAgICAgICAgYWNjZXB0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlhbG9nLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBFbXVsYXRpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5fZW11bGF0aW5nTW9iaWxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc1RvdWNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgZW11bGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGNvbnN0IG1vYmlsZSA9IHZpZXdwb3J0LmlzTW9iaWxlIHx8IGZhbHNlO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGRldmljZVNjYWxlRmFjdG9yID0gdmlld3BvcnQuZGV2aWNlU2NhbGVGYWN0b3IgfHwgMTtcbiAgICAgICAgY29uc3Qgc2NyZWVuT3JpZW50YXRpb24gPSB2aWV3cG9ydC5pc0xhbmRzY2FwZVxuICAgICAgICAgICAgPyB7IGFuZ2xlOiA5MCwgdHlwZTogJ2xhbmRzY2FwZVByaW1hcnknIH1cbiAgICAgICAgICAgIDogeyBhbmdsZTogMCwgdHlwZTogJ3BvcnRyYWl0UHJpbWFyeScgfTtcbiAgICAgICAgY29uc3QgaGFzVG91Y2ggPSB2aWV3cG9ydC5oYXNUb3VjaCB8fCBmYWxzZTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXREZXZpY2VNZXRyaWNzT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgbW9iaWxlLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcixcbiAgICAgICAgICAgICAgICBzY3JlZW5PcmllbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXRUb3VjaEVtdWxhdGlvbkVuYWJsZWQnLCB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogaGFzVG91Y2gsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHJlbG9hZE5lZWRlZCA9IHRoaXMuX2VtdWxhdGluZ01vYmlsZSAhPT0gbW9iaWxlIHx8IHRoaXMuX2hhc1RvdWNoICE9PSBoYXNUb3VjaDtcbiAgICAgICAgdGhpcy5fZW11bGF0aW5nTW9iaWxlID0gbW9iaWxlO1xuICAgICAgICB0aGlzLl9oYXNUb3VjaCA9IGhhc1RvdWNoO1xuICAgICAgICByZXR1cm4gcmVsb2FkTmVlZGVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtdWxhdGlvbk1hbmFnZXIuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbi8qKlxuICogVGltZW91dEVycm9yIGlzIGVtaXR0ZWQgd2hlbmV2ZXIgY2VydGFpbiBvcGVyYXRpb25zIGFyZSB0ZXJtaW5hdGVkIGR1ZSB0byB0aW1lb3V0LlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogRXhhbXBsZSBvcGVyYXRpb25zIGFyZSB7QGxpbmsgUGFnZS53YWl0Rm9yU2VsZWN0b3IgfCBwYWdlLndhaXRGb3JTZWxlY3Rvcn1cbiAqIG9yIHtAbGluayBQdXBwZXRlZXJOb2RlLmxhdW5jaCB8IHB1cHBldGVlci5sYXVuY2h9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcHVwcGV0ZWVyRXJyb3JzID0ge1xuICAgIFRpbWVvdXRFcnJvcixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIiwiaW1wb3J0IG1pdHQgZnJvbSAnLi4vLi4vdmVuZG9yL21pdHQvc3JjL2luZGV4LmpzJztcbi8qKlxuICogVGhlIEV2ZW50RW1pdHRlciBjbGFzcyB0aGF0IG1hbnkgUHVwcGV0ZWVyIGNsYXNzZXMgZXh0ZW5kLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIGxpc3RlbiB0byBldmVudHMgdGhhdCBQdXBwZXRlZXIgY2xhc3NlcyBmaXJlIGFuZCBhY3RcbiAqIGFjY29yZGluZ2x5LiBUaGVyZWZvcmUgeW91J2xsIG1vc3RseSB1c2Uge0BsaW5rIEV2ZW50RW1pdHRlci5vbiB8IG9ufSBhbmRcbiAqIHtAbGluayBFdmVudEVtaXR0ZXIub2ZmIHwgb2ZmfSB0byBiaW5kXG4gKiBhbmQgdW5iaW5kIHRvIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV2ZW50c01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbWl0dCh0aGlzLmV2ZW50c01hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZmlyZSB3aGVuIGFuIGV2ZW50IG9jY3Vycy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgdHlwZSB5b3UnZCBsaWtlIHRvIGxpc3RlbiB0by4gQ2FuIGJlIGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgLSB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cbiAgICAgKiBAcmV0dXJucyBgdGhpc2AgdG8gZW5hYmxlIHlvdSB0byBjaGFpbiBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGZpcmluZy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgdHlwZSB5b3UnZCBsaWtlIHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAtIHRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm5zIGB0aGlzYCB0byBlbmFibGUgeW91IHRvIGNoYWluIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cbiAgICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9mZihldmVudCwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSB7QGxpbmsgRXZlbnRFbWl0dGVyLm9mZn0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9mZihldmVudCwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSB7QGxpbmsgRXZlbnRFbWl0dGVyLm9ufSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudCBhbmQgY2FsbCBhbnkgYXNzb2NpYXRlZCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgeW91J2QgbGlrZSB0byBlbWl0XG4gICAgICogQHBhcmFtIGV2ZW50RGF0YSAtIGFueSBkYXRhIHlvdSdkIGxpa2UgdG8gZW1pdCB3aXRoIHRoZSBldmVudFxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBhcmUgYW55IGxpc3RlbmVycywgYGZhbHNlYCBpZiB0aGVyZSBhcmUgbm90LlxuICAgICAqL1xuICAgIGVtaXQoZXZlbnQsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRMaXN0ZW5lcnNDb3VudChldmVudCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIGBvbmAgYnV0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgYmUgZmlyZWQgb25jZSBhbmQgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gdGhlIGV2ZW50IHlvdSdkIGxpa2UgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSB0aGUgaGFuZGxlciBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgZXZlbnQgb2NjdXJzXG4gICAgICogQHJldHVybnMgYHRoaXNgIHRvIGVuYWJsZSB5b3UgdG8gY2hhaW4gbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgb25jZUhhbmRsZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gdGhlIGV2ZW50IHRvIGdldCB0aGUgbGlzdGVuZXIgY291bnQgZm9yXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgYm91bmQgdG8gdGhlIGdpdmVuIGV2ZW50XG4gICAgICovXG4gICAgbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudExpc3RlbmVyc0NvdW50KGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJZiBnaXZlbiBhbiBldmVudCBhcmd1bWVudCwgaXQgd2lsbCByZW1vdmUgb25seVxuICAgICAqIGxpc3RlbmVycyBmb3IgdGhhdCBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHJldHVybnMgYHRoaXNgIHRvIGVuYWJsZSB5b3UgdG8gY2hhaW4gbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzTWFwLmRlbGV0ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c01hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBldmVudExpc3RlbmVyc0NvdW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50c01hcC5oYXMoZXZlbnQpID8gdGhpcy5ldmVudHNNYXAuZ2V0KGV2ZW50KS5sZW5ndGggOiAwO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RW1pdHRlci5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVKU0hhbmRsZSwgSlNIYW5kbGUgfSBmcm9tICcuL0pTSGFuZGxlLmpzJztcbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgRVZBTFVBVElPTl9TQ1JJUFRfVVJMID0gJ19fcHVwcGV0ZWVyX2V2YWx1YXRpb25fc2NyaXB0X18nO1xuY29uc3QgU09VUkNFX1VSTF9SRUdFWCA9IC9eW1xcMDQwXFx0XSpcXC9cXC9bQCNdIHNvdXJjZVVSTD1cXHMqKFxcUyo/KVxccyokL207XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIGNvbnRleHQgZm9yIEphdmFTY3JpcHQgZXhlY3V0aW9uLiBBIFtQYWdlXSBtaWdodCBoYXZlXG4gKiBtYW55IGV4ZWN1dGlvbiBjb250ZXh0czpcbiAqIC0gZWFjaFxuICogICB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lmcmFtZSB8XG4gKiAgIGZyYW1lIH0gaGFzIFwiZGVmYXVsdFwiIGV4ZWN1dGlvbiBjb250ZXh0IHRoYXQgaXMgYWx3YXlzIGNyZWF0ZWQgYWZ0ZXIgZnJhbWUgaXNcbiAqICAgYXR0YWNoZWQgdG8gRE9NLiBUaGlzIGNvbnRleHQgaXMgcmV0dXJuZWQgYnkgdGhlXG4gKiAgIHtAbGluayBGcmFtZS5leGVjdXRpb25Db250ZXh0fSBtZXRob2QuXG4gKiAtIHtAbGluayBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMgfCBFeHRlbnNpb259J3MgY29udGVudCBzY3JpcHRzXG4gKiAgIGNyZWF0ZSBhZGRpdGlvbmFsIGV4ZWN1dGlvbiBjb250ZXh0cy5cbiAqXG4gKiBCZXNpZGVzIHBhZ2VzLCBleGVjdXRpb24gY29udGV4dHMgY2FuIGJlIGZvdW5kIGluXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSSB8XG4gKiB3b3JrZXJzIH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uQ29udGV4dCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBjb250ZXh0UGF5bG9hZCwgd29ybGQpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLl93b3JsZCA9IHdvcmxkO1xuICAgICAgICB0aGlzLl9jb250ZXh0SWQgPSBjb250ZXh0UGF5bG9hZC5pZDtcbiAgICAgICAgdGhpcy5fY29udGV4dE5hbWUgPSBjb250ZXh0UGF5bG9hZC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogTm90IGV2ZXJ5IGV4ZWN1dGlvbiBjb250ZXh0IGlzIGFzc29jaWF0ZWQgd2l0aCBhIGZyYW1lLiBGb3JcbiAgICAgKiBleGFtcGxlLCB3b3JrZXJzIGFuZCBleHRlbnNpb25zIGhhdmUgZXhlY3V0aW9uIGNvbnRleHRzIHRoYXQgYXJlIG5vdFxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCBmcmFtZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZnJhbWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXhlY3V0aW9uIGNvbnRleHQuXG4gICAgICovXG4gICAgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZCA/IHRoaXMuX3dvcmxkLmZyYW1lKCkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlIGBleGVjdXRpb25Db250ZXh0LmV2YWx1YXRlYCByZXR1cm5zIGFcbiAgICAgKiBQcm9taXNlLCB0aGVuIGBleGVjdXRpb25Db250ZXh0LmV2YWx1YXRlYCB3b3VsZCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0b1xuICAgICAqIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlXG4gICAgICogYGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVgIHJldHVybnMgYSBub24tc2VyaWFsaXphYmxlIHZhbHVlLCB0aGVuXG4gICAgICogYGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVgIHJlc29sdmVzIHRvIGB1bmRlZmluZWRgLiBEZXZUb29scyBQcm90b2NvbCBhbHNvXG4gICAgICogc3VwcG9ydHMgdHJhbnNmZXJyaW5nIHNvbWUgYWRkaXRpb25hbCB2YWx1ZXMgdGhhdCBhcmUgbm90IHNlcmlhbGl6YWJsZSBieVxuICAgICAqIGBKU09OYDogYC0wYCwgYE5hTmAsIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYmlnaW50IGxpdGVyYWxzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgZXhlY3V0aW9uQ29udGV4dCA9IGF3YWl0IHBhZ2UubWFpbkZyYW1lKCkuZXhlY3V0aW9uQ29udGV4dCgpO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGUoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKDggKiA3KSkqIDtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBwcmludHMgXCI1NlwiXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEEgc3RyaW5nIGNhbiBhbHNvIGJlIHBhc3NlZCBpbiBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGUoJzEgKyAyJykpOyAvLyBwcmludHMgXCIzXCJcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICoge0BsaW5rIEpTSGFuZGxlfSBpbnN0YW5jZXMgY2FuIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlXG4gICAgICogYGV4ZWN1dGlvbkNvbnRleHQuKiBldmFsdWF0ZWA6XG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBvbmVIYW5kbGUgPSBhd2FpdCBleGVjdXRpb25Db250ZXh0LmV2YWx1YXRlSGFuZGxlKCgpID0+IDEpO1xuICAgICAqIGNvbnN0IHR3b0hhbmRsZSA9IGF3YWl0IGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVIYW5kbGUoKCkgPT4gMik7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0aW9uQ29udGV4dC5ldmFsdWF0ZShcbiAgICAgKiAgICAoYSwgYikgPT4gYSArIGIsIG9uZUhhbmRsZSwgKiB0d29IYW5kbGVcbiAgICAgKiApO1xuICAgICAqIGF3YWl0IG9uZUhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICogYXdhaXQgdHdvSGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBwcmludHMgJzMnLlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBwYWdlRnVuY3Rpb24gLSBhIGZ1bmN0aW9uIHRvIGJlIGV2YWx1YXRlZCBpbiB0aGUgYGV4ZWN1dGlvbkNvbnRleHRgXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudCB0byBwYXNzIHRvIHRoZSBwYWdlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2V2YWx1YXRlSW50ZXJuYWwodHJ1ZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gYGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVgIGFuZFxuICAgICAqIGBleGVjdXRpb25Db250ZXh0LmV2YWx1YXRlSGFuZGxlYCBpcyB0aGF0IGBleGVjdXRpb25Db250ZXh0LmV2YWx1YXRlSGFuZGxlYFxuICAgICAqIHJldHVybnMgYW4gaW4tcGFnZSBvYmplY3QgKGEge0BsaW5rIEpTSGFuZGxlfSkuXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byB0aGUgYGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVIYW5kbGVgIHJldHVybnMgYVxuICAgICAqIFByb21pc2UsIHRoZW4gYGV4ZWN1dGlvbkNvbnRleHQuZXZhbHVhdGVIYW5kbGVgIHdvdWxkIHdhaXQgZm9yIHRoZVxuICAgICAqIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBjb250ZXh0ID0gYXdhaXQgcGFnZS5tYWluRnJhbWUoKS5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICogY29uc3QgYUhhbmRsZSA9IGF3YWl0IGNvbnRleHQuZXZhbHVhdGVIYW5kbGUoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHNlbGYpKTtcbiAgICAgKiBhSGFuZGxlOyAvLyBIYW5kbGUgZm9yIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBBIHN0cmluZyBjYW4gYWxzbyBiZSBwYXNzZWQgaW4gaW5zdGVhZCBvZiBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAvLyBIYW5kbGUgZm9yIHRoZSAnMycgKiBvYmplY3QuXG4gICAgICogY29uc3QgYUhhbmRsZSA9IGF3YWl0IGNvbnRleHQuZXZhbHVhdGVIYW5kbGUoJzEgKyAyJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEpTSGFuZGxlIGluc3RhbmNlcyBjYW4gYmUgcGFzc2VkIGFzIGFyZ3VtZW50c1xuICAgICAqIHRvIHRoZSBgZXhlY3V0aW9uQ29udGV4dC4qIGV2YWx1YXRlSGFuZGxlYDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgYUhhbmRsZSA9IGF3YWl0IGNvbnRleHQuZXZhbHVhdGVIYW5kbGUoKCkgPT4gZG9jdW1lbnQuYm9keSk7XG4gICAgICogY29uc3QgcmVzdWx0SGFuZGxlID0gYXdhaXQgY29udGV4dC5ldmFsdWF0ZUhhbmRsZShib2R5ID0+IGJvZHkuaW5uZXJIVE1MLCAqIGFIYW5kbGUpO1xuICAgICAqIGNvbnNvbGUubG9nKGF3YWl0IHJlc3VsdEhhbmRsZS5qc29uVmFsdWUoKSk7IC8vIHByaW50cyBib2R5J3MgaW5uZXJIVE1MXG4gICAgICogYXdhaXQgYUhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICogYXdhaXQgcmVzdWx0SGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlRnVuY3Rpb24gLSBhIGZ1bmN0aW9uIHRvIGJlIGV2YWx1YXRlZCBpbiB0aGUgYGV4ZWN1dGlvbkNvbnRleHRgXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudCB0byBwYXNzIHRvIHRoZSBwYWdlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnaXZlbiBmdW5jdGlvblxuICAgICAqIGFzIGFuIGluLXBhZ2Ugb2JqZWN0IChhIHtAbGluayBKU0hhbmRsZX0pLlxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlSGFuZGxlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVJbnRlcm5hbChmYWxzZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgX2V2YWx1YXRlSW50ZXJuYWwocmV0dXJuQnlWYWx1ZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGAvLyMgc291cmNlVVJMPSR7RVZBTFVBVElPTl9TQ1JJUFRfVVJMfWA7XG4gICAgICAgIGlmIChoZWxwZXIuaXNTdHJpbmcocGFnZUZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dElkID0gdGhpcy5fY29udGV4dElkO1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhZ2VGdW5jdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25XaXRoU291cmNlVXJsID0gU09VUkNFX1VSTF9SRUdFWC50ZXN0KGV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgPyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgOiBleHByZXNzaW9uICsgJ1xcbicgKyBzdWZmaXg7XG4gICAgICAgICAgICBjb25zdCB7IGV4Y2VwdGlvbkRldGFpbHMsIHJlc3VsdDogcmVtb3RlT2JqZWN0IH0gPSBhd2FpdCB0aGlzLl9jbGllbnRcbiAgICAgICAgICAgICAgICAuc2VuZCgnUnVudGltZS5ldmFsdWF0ZScsIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uV2l0aFNvdXJjZVVybCxcbiAgICAgICAgICAgICAgICBjb250ZXh0SWQsXG4gICAgICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZSxcbiAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNlckdlc3R1cmU6IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZXdyaXRlRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbkRldGFpbHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmFsdWF0aW9uIGZhaWxlZDogJyArIGhlbHBlci5nZXRFeGNlcHRpb25NZXNzYWdlKGV4Y2VwdGlvbkRldGFpbHMpKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5CeVZhbHVlXG4gICAgICAgICAgICAgICAgPyBoZWxwZXIudmFsdWVGcm9tUmVtb3RlT2JqZWN0KHJlbW90ZU9iamVjdClcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUpTSGFuZGxlKHRoaXMsIHJlbW90ZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYWdlRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRvIGdldCB8c3RyaW5nfCBvciB8ZnVuY3Rpb258IGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgYnV0IGdvdCBcIiR7cGFnZUZ1bmN0aW9ufVwiIGluc3RlYWQuYCk7XG4gICAgICAgIGxldCBmdW5jdGlvblRleHQgPSBwYWdlRnVuY3Rpb24udG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbignKCcgKyBmdW5jdGlvblRleHQgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBtaWdodCBoYXZlIGEgZnVuY3Rpb24gc2hvcnRoYW5kLiBUcnkgYW5vdGhlclxuICAgICAgICAgICAgLy8gdGltZSBwcmVmaXhpbmcgJ2Z1bmN0aW9uICcuXG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25UZXh0LnN0YXJ0c1dpdGgoJ2FzeW5jICcpKVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICdhc3luYyBmdW5jdGlvbiAnICsgZnVuY3Rpb25UZXh0LnN1YnN0cmluZygnYXN5bmMgJy5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uVGV4dCA9ICdmdW5jdGlvbiAnICsgZnVuY3Rpb25UZXh0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgRnVuY3Rpb24oJygnICsgZnVuY3Rpb25UZXh0ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIHRyaWVkIGhhcmQgdG8gc2VyaWFsaXplLCBidXQgdGhlcmUncyBhIHdlaXJkIGJlYXN0IGhlcmUuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzZWQgZnVuY3Rpb24gaXMgbm90IHdlbGwtc2VyaWFsaXphYmxlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsRnVuY3Rpb25PblByb21pc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsRnVuY3Rpb25PblByb21pc2UgPSB0aGlzLl9jbGllbnQuc2VuZCgnUnVudGltZS5jYWxsRnVuY3Rpb25PbicsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvblRleHQgKyAnXFxuJyArIHN1ZmZpeCArICdcXG4nLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5fY29udGV4dElkLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJncy5tYXAoY29udmVydEFyZ3VtZW50LmJpbmQodGhpcykpLFxuICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWUsXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZXJHZXN0dXJlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKSlcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9ICcgQXJlIHlvdSBwYXNzaW5nIGEgbmVzdGVkIEpTSGFuZGxlPyc7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGV4Y2VwdGlvbkRldGFpbHMsIHJlc3VsdDogcmVtb3RlT2JqZWN0IH0gPSBhd2FpdCBjYWxsRnVuY3Rpb25PblByb21pc2UuY2F0Y2gocmV3cml0ZUVycm9yKTtcbiAgICAgICAgaWYgKGV4Y2VwdGlvbkRldGFpbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2YWx1YXRpb24gZmFpbGVkOiAnICsgaGVscGVyLmdldEV4Y2VwdGlvbk1lc3NhZ2UoZXhjZXB0aW9uRGV0YWlscykpO1xuICAgICAgICByZXR1cm4gcmV0dXJuQnlWYWx1ZVxuICAgICAgICAgICAgPyBoZWxwZXIudmFsdWVGcm9tUmVtb3RlT2JqZWN0KHJlbW90ZU9iamVjdClcbiAgICAgICAgICAgIDogY3JlYXRlSlNIYW5kbGUodGhpcywgcmVtb3RlT2JqZWN0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gYXJnXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKiBAdGhpcyB7RXhlY3V0aW9uQ29udGV4dH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRBcmd1bWVudChhcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6IGAke2FyZy50b1N0cmluZygpfW5gIH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzKGFyZywgLTApKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICctMCcgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaXMoYXJnLCBJbmZpbml0eSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJ0luZmluaXR5JyB9O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5pcyhhcmcsIC1JbmZpbml0eSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJy1JbmZpbml0eScgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaXMoYXJnLCBOYU4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICdOYU4nIH07XG4gICAgICAgICAgICBjb25zdCBvYmplY3RIYW5kbGUgPSBhcmcgJiYgYXJnIGluc3RhbmNlb2YgSlNIYW5kbGUgPyBhcmcgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG9iamVjdEhhbmRsZSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIYW5kbGUuX2NvbnRleHQgIT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNIYW5kbGVzIGNhbiBiZSBldmFsdWF0ZWQgb25seSBpbiB0aGUgY29udGV4dCB0aGV5IHdlcmUgY3JlYXRlZCEnKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGFuZGxlLl9kaXNwb3NlZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU0hhbmRsZSBpcyBkaXNwb3NlZCEnKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGFuZGxlLl9yZW1vdGVPYmplY3QudW5zZXJpYWxpemFibGVWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc2VyaWFsaXphYmxlVmFsdWU6IG9iamVjdEhhbmRsZS5fcmVtb3RlT2JqZWN0LnVuc2VyaWFsaXphYmxlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RIYW5kbGUuX3JlbW90ZU9iamVjdC5vYmplY3RJZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9iamVjdEhhbmRsZS5fcmVtb3RlT2JqZWN0LnZhbHVlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IG9iamVjdEhhbmRsZS5fcmVtb3RlT2JqZWN0Lm9iamVjdElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYXJnIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV3cml0ZUVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnT2JqZWN0IHJlZmVyZW5jZSBjaGFpbiBpcyB0b28gbG9uZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogeyB0eXBlOiAndW5kZWZpbmVkJyB9IH07XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIk9iamVjdCBjb3VsZG4ndCBiZSByZXR1cm5lZCBieSB2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHsgdHlwZTogJ3VuZGVmaW5lZCcgfSB9O1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuZW5kc1dpdGgoJ0Nhbm5vdCBmaW5kIGNvbnRleHQgd2l0aCBzcGVjaWZpZWQgaWQnKSB8fFxuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UuZW5kc1dpdGgoJ0luc3BlY3RlZCB0YXJnZXQgbmF2aWdhdGVkIG9yIGNsb3NlZCcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0aW9uIGNvbnRleHQgd2FzIGRlc3Ryb3llZCwgbW9zdCBsaWtlbHkgYmVjYXVzZSBvZiBhIG5hdmlnYXRpb24uJyk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpdGVyYXRlcyB0aGUgSmF2YVNjcmlwdCBoZWFwIGFuZCBmaW5kcyBhbGwgdGhlIG9iamVjdHMgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiBwcm90b3R5cGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogLy8gQ3JlYXRlIGEgTWFwIG9iamVjdFxuICAgICAqIGF3YWl0IHBhZ2UuZXZhbHVhdGUoKCkgPT4gd2luZG93Lm1hcCA9IG5ldyBNYXAoKSk7XG4gICAgICogLy8gR2V0IGEgaGFuZGxlIHRvIHRoZSBNYXAgb2JqZWN0IHByb3RvdHlwZVxuICAgICAqIGNvbnN0IG1hcFByb3RvdHlwZSA9IGF3YWl0IHBhZ2UuZXZhbHVhdGVIYW5kbGUoKCkgPT4gTWFwLnByb3RvdHlwZSk7XG4gICAgICogLy8gUXVlcnkgYWxsIG1hcCBpbnN0YW5jZXMgaW50byBhbiBhcnJheVxuICAgICAqIGNvbnN0IG1hcEluc3RhbmNlcyA9IGF3YWl0IHBhZ2UucXVlcnlPYmplY3RzKG1hcFByb3RvdHlwZSk7XG4gICAgICogLy8gQ291bnQgYW1vdW50IG9mIG1hcCBvYmplY3RzIGluIGhlYXBcbiAgICAgKiBjb25zdCBjb3VudCA9IGF3YWl0IHBhZ2UuZXZhbHVhdGUobWFwcyA9PiBtYXBzLmxlbmd0aCwgbWFwSW5zdGFuY2VzKTtcbiAgICAgKiBhd2FpdCBtYXBJbnN0YW5jZXMuZGlzcG9zZSgpO1xuICAgICAqIGF3YWl0IG1hcFByb3RvdHlwZS5kaXNwb3NlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdG90eXBlSGFuZGxlIC0gYSBoYW5kbGUgdG8gdGhlIG9iamVjdCBwcm90b3R5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgaGFuZGxlIHRvIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZW4gcHJvdG90eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5T2JqZWN0cyhwcm90b3R5cGVIYW5kbGUpIHtcbiAgICAgICAgYXNzZXJ0KCFwcm90b3R5cGVIYW5kbGUuX2Rpc3Bvc2VkLCAnUHJvdG90eXBlIEpTSGFuZGxlIGlzIGRpc3Bvc2VkIScpO1xuICAgICAgICBhc3NlcnQocHJvdG90eXBlSGFuZGxlLl9yZW1vdGVPYmplY3Qub2JqZWN0SWQsICdQcm90b3R5cGUgSlNIYW5kbGUgbXVzdCBub3QgYmUgcmVmZXJlbmNpbmcgcHJpbWl0aXZlIHZhbHVlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1J1bnRpbWUucXVlcnlPYmplY3RzJywge1xuICAgICAgICAgICAgcHJvdG90eXBlT2JqZWN0SWQ6IHByb3RvdHlwZUhhbmRsZS5fcmVtb3RlT2JqZWN0Lm9iamVjdElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUpTSGFuZGxlKHRoaXMsIHJlc3BvbnNlLm9iamVjdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfYWRvcHRCYWNrZW5kTm9kZUlkKGJhY2tlbmROb2RlSWQpIHtcbiAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdET00ucmVzb2x2ZU5vZGUnLCB7XG4gICAgICAgICAgICBiYWNrZW5kTm9kZUlkOiBiYWNrZW5kTm9kZUlkLFxuICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiB0aGlzLl9jb250ZXh0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlSlNIYW5kbGUodGhpcywgb2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgX2Fkb3B0RWxlbWVudEhhbmRsZShlbGVtZW50SGFuZGxlKSB7XG4gICAgICAgIGFzc2VydChlbGVtZW50SGFuZGxlLmV4ZWN1dGlvbkNvbnRleHQoKSAhPT0gdGhpcywgJ0Nhbm5vdCBhZG9wdCBoYW5kbGUgdGhhdCBhbHJlYWR5IGJlbG9uZ3MgdG8gdGhpcyBleGVjdXRpb24gY29udGV4dCcpO1xuICAgICAgICBhc3NlcnQodGhpcy5fd29ybGQsICdDYW5ub3QgYWRvcHQgaGFuZGxlIHdpdGhvdXQgRE9NV29ybGQnKTtcbiAgICAgICAgY29uc3Qgbm9kZUluZm8gPSBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRE9NLmRlc2NyaWJlTm9kZScsIHtcbiAgICAgICAgICAgIG9iamVjdElkOiBlbGVtZW50SGFuZGxlLl9yZW1vdGVPYmplY3Qub2JqZWN0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRvcHRCYWNrZW5kTm9kZUlkKG5vZGVJbmZvLm5vZGUuYmFja2VuZE5vZGVJZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXhlY3V0aW9uQ29udGV4dC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG4vKipcbiAqIEZpbGUgY2hvb3NlcnMgbGV0IHlvdSByZWFjdCB0byB0aGUgcGFnZSByZXF1ZXN0aW5nIGZvciBhIGZpbGUuXG4gKiBAcmVtYXJrc1xuICogYEZpbGVDaG9vc2VyYCBvYmplY3RzIGFyZSByZXR1cm5lZCB2aWEgdGhlIGBwYWdlLndhaXRGb3JGaWxlQ2hvb3NlcmAgbWV0aG9kLlxuICogQGV4YW1wbGVcbiAqIEFuIGV4YW1wbGUgb2YgdXNpbmcgYEZpbGVDaG9vc2VyYDpcbiAqIGBgYGpzXG4gKiBjb25zdCBbZmlsZUNob29zZXJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICogICBwYWdlLndhaXRGb3JGaWxlQ2hvb3NlcigpLFxuICogICBwYWdlLmNsaWNrKCcjdXBsb2FkLWZpbGUtYnV0dG9uJyksIC8vIHNvbWUgYnV0dG9uIHRoYXQgdHJpZ2dlcnMgZmlsZSBzZWxlY3Rpb25cbiAqIF0pO1xuICogYXdhaXQgZmlsZUNob29zZXIuYWNjZXB0KFsnL3RtcC9teWZpbGUucGRmJ10pO1xuICogYGBgXG4gKiAqKk5PVEUqKiBJbiBicm93c2Vycywgb25seSBvbmUgZmlsZSBjaG9vc2VyIGNhbiBiZSBvcGVuZWQgYXQgYSB0aW1lLlxuICogQWxsIGZpbGUgY2hvb3NlcnMgbXVzdCBiZSBhY2NlcHRlZCBvciBjYW5jZWxlZC4gTm90IGRvaW5nIHNvIHdpbGwgcHJldmVudFxuICogc3Vic2VxdWVudCBmaWxlIGNob29zZXJzIGZyb20gYXBwZWFyaW5nLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRmlsZUNob29zZXIge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gZXZlbnQubW9kZSAhPT0gJ3NlbGVjdFNpbmdsZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZmlsZSBjaG9vc2VyIGFsbG93IGZvciB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0L2ZpbGUjYXR0ci1tdWx0aXBsZSB8IG11bHRpcGxlfSBmaWxlIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBpc011bHRpcGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGlwbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdCB0aGUgZmlsZSBjaG9vc2VyIHJlcXVlc3Qgd2l0aCBnaXZlbiBwYXRocy5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGhzIC0gSWYgc29tZSBvZiB0aGUgIGBmaWxlUGF0aHNgIGFyZSByZWxhdGl2ZSBwYXRocyxcbiAgICAgKiB0aGVuIHRoZXkgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2N3ZCB8IGN1cnJlbnQgd29ya2luZyBkaXJlY3Rvcnl9LlxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdChmaWxlUGF0aHMpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLl9oYW5kbGVkLCAnQ2Fubm90IGFjY2VwdCBGaWxlQ2hvb3NlciB3aGljaCBpcyBhbHJlYWR5IGhhbmRsZWQhJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbGVtZW50LnVwbG9hZEZpbGUoLi4uZmlsZVBhdGhzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBmaWxlIGNob29zZXIgd2l0aG91dCBzZWxlY3RpbmcgYW55IGZpbGVzLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLl9oYW5kbGVkLCAnQ2Fubm90IGNhbmNlbCBGaWxlQ2hvb3NlciB3aGljaCBpcyBhbHJlYWR5IGhhbmRsZWQhJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVDaG9vc2VyLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vY29tbW9uL0RlYnVnLmpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhlbHBlciwgZGVidWdFcnJvciB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IEV4ZWN1dGlvbkNvbnRleHQsIEVWQUxVQVRJT05fU0NSSVBUX1VSTCB9IGZyb20gJy4vRXhlY3V0aW9uQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBMaWZlY3ljbGVXYXRjaGVyLCB9IGZyb20gJy4vTGlmZWN5Y2xlV2F0Y2hlci5qcyc7XG5pbXBvcnQgeyBET01Xb3JsZCB9IGZyb20gJy4vRE9NV29ybGQuanMnO1xuaW1wb3J0IHsgTmV0d29ya01hbmFnZXIgfSBmcm9tICcuL05ldHdvcmtNYW5hZ2VyLmpzJztcbmNvbnN0IFVUSUxJVFlfV09STERfTkFNRSA9ICdfX3B1cHBldGVlcl91dGlsaXR5X3dvcmxkX18nO1xuLyoqXG4gKiBXZSB1c2Ugc3ltYm9scyB0byBwcmV2ZW50IGV4dGVybmFsIHBhcnRpZXMgbGlzdGVuaW5nIHRvIHRoZXNlIGV2ZW50cy5cbiAqIFRoZXkgYXJlIGludGVybmFsIHRvIFB1cHBldGVlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMgPSB7XG4gICAgRnJhbWVBdHRhY2hlZDogU3ltYm9sKCdGcmFtZU1hbmFnZXIuRnJhbWVBdHRhY2hlZCcpLFxuICAgIEZyYW1lTmF2aWdhdGVkOiBTeW1ib2woJ0ZyYW1lTWFuYWdlci5GcmFtZU5hdmlnYXRlZCcpLFxuICAgIEZyYW1lRGV0YWNoZWQ6IFN5bWJvbCgnRnJhbWVNYW5hZ2VyLkZyYW1lRGV0YWNoZWQnKSxcbiAgICBMaWZlY3ljbGVFdmVudDogU3ltYm9sKCdGcmFtZU1hbmFnZXIuTGlmZWN5Y2xlRXZlbnQnKSxcbiAgICBGcmFtZU5hdmlnYXRlZFdpdGhpbkRvY3VtZW50OiBTeW1ib2woJ0ZyYW1lTWFuYWdlci5GcmFtZU5hdmlnYXRlZFdpdGhpbkRvY3VtZW50JyksXG4gICAgRXhlY3V0aW9uQ29udGV4dENyZWF0ZWQ6IFN5bWJvbCgnRnJhbWVNYW5hZ2VyLkV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkJyksXG4gICAgRXhlY3V0aW9uQ29udGV4dERlc3Ryb3llZDogU3ltYm9sKCdGcmFtZU1hbmFnZXIuRXhlY3V0aW9uQ29udGV4dERlc3Ryb3llZCcpLFxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFtZU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgcGFnZSwgaWdub3JlSFRUUFNFcnJvcnMsIHRpbWVvdXRTZXR0aW5ncykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9mcmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faXNvbGF0ZWRXb3JsZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgICAgIHRoaXMuX25ldHdvcmtNYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKGNsaWVudCwgaWdub3JlSFRUUFNFcnJvcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLl90aW1lb3V0U2V0dGluZ3MgPSB0aW1lb3V0U2V0dGluZ3M7XG4gICAgICAgIHRoaXMuX2NsaWVudC5vbignUGFnZS5mcmFtZUF0dGFjaGVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkZyYW1lQXR0YWNoZWQoZXZlbnQuZnJhbWVJZCwgZXZlbnQucGFyZW50RnJhbWVJZCkpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ1BhZ2UuZnJhbWVOYXZpZ2F0ZWQnLCAoZXZlbnQpID0+IHRoaXMuX29uRnJhbWVOYXZpZ2F0ZWQoZXZlbnQuZnJhbWUpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdQYWdlLm5hdmlnYXRlZFdpdGhpbkRvY3VtZW50JywgKGV2ZW50KSA9PiB0aGlzLl9vbkZyYW1lTmF2aWdhdGVkV2l0aGluRG9jdW1lbnQoZXZlbnQuZnJhbWVJZCwgZXZlbnQudXJsKSk7XG4gICAgICAgIHRoaXMuX2NsaWVudC5vbignUGFnZS5mcmFtZURldGFjaGVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkZyYW1lRGV0YWNoZWQoZXZlbnQuZnJhbWVJZCkpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ1BhZ2UuZnJhbWVTdG9wcGVkTG9hZGluZycsIChldmVudCkgPT4gdGhpcy5fb25GcmFtZVN0b3BwZWRMb2FkaW5nKGV2ZW50LmZyYW1lSWQpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkKGV2ZW50LmNvbnRleHQpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHREZXN0cm95ZWQnLCAoZXZlbnQpID0+IHRoaXMuX29uRXhlY3V0aW9uQ29udGV4dERlc3Ryb3llZChldmVudC5leGVjdXRpb25Db250ZXh0SWQpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdSdW50aW1lLmV4ZWN1dGlvbkNvbnRleHRzQ2xlYXJlZCcsICgpID0+IHRoaXMuX29uRXhlY3V0aW9uQ29udGV4dHNDbGVhcmVkKCkpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ1BhZ2UubGlmZWN5Y2xlRXZlbnQnLCAoZXZlbnQpID0+IHRoaXMuX29uTGlmZWN5Y2xlRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdUYXJnZXQuYXR0YWNoZWRUb1RhcmdldCcsIGFzeW5jIChldmVudCkgPT4gdGhpcy5fb25GcmFtZU1vdmVkKGV2ZW50KSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLmVuYWJsZScpLFxuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuZ2V0RnJhbWVUcmVlJyksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCB7IGZyYW1lVHJlZSB9ID0gcmVzdWx0WzFdO1xuICAgICAgICB0aGlzLl9oYW5kbGVGcmFtZVRyZWUoZnJhbWVUcmVlKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2Uuc2V0TGlmZWN5Y2xlRXZlbnRzRW5hYmxlZCcsIHsgZW5hYmxlZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgICAgIC5zZW5kKCdSdW50aW1lLmVuYWJsZScpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fZW5zdXJlSXNvbGF0ZWRXb3JsZChVVElMSVRZX1dPUkxEX05BTUUpKSxcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtNYW5hZ2VyLmluaXRpYWxpemUoKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG5ldHdvcmtNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29ya01hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlRnJhbWUoZnJhbWUsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGFzc2VydE5vTGVnYWN5TmF2aWdhdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcmVmZXJlciA9IHRoaXMuX25ldHdvcmtNYW5hZ2VyLmV4dHJhSFRUUEhlYWRlcnMoKVsncmVmZXJlciddLCB3YWl0VW50aWwgPSBbJ2xvYWQnXSwgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy5uYXZpZ2F0aW9uVGltZW91dCgpLCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBMaWZlY3ljbGVXYXRjaGVyKHRoaXMsIGZyYW1lLCB3YWl0VW50aWwsIHRpbWVvdXQpO1xuICAgICAgICBsZXQgZW5zdXJlTmV3RG9jdW1lbnROYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBlcnJvciA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBuYXZpZ2F0ZSh0aGlzLl9jbGllbnQsIHVybCwgcmVmZXJlciwgZnJhbWUuX2lkKSxcbiAgICAgICAgICAgIHdhdGNoZXIudGltZW91dE9yVGVybWluYXRpb25Qcm9taXNlKCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgd2F0Y2hlci50aW1lb3V0T3JUZXJtaW5hdGlvblByb21pc2UoKSxcbiAgICAgICAgICAgICAgICBlbnN1cmVOZXdEb2N1bWVudE5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyB3YXRjaGVyLm5ld0RvY3VtZW50TmF2aWdhdGlvblByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IHdhdGNoZXIuc2FtZURvY3VtZW50TmF2aWdhdGlvblByb21pc2UoKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHdhdGNoZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgcmV0dXJuIHdhdGNoZXIubmF2aWdhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKGNsaWVudCwgdXJsLCByZWZlcnJlciwgZnJhbWVJZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kKCdQYWdlLm5hdmlnYXRlJywge1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVycmVyLFxuICAgICAgICAgICAgICAgICAgICBmcmFtZUlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVuc3VyZU5ld0RvY3VtZW50TmF2aWdhdGlvbiA9ICEhcmVzcG9uc2UubG9hZGVySWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmVycm9yVGV4dFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBFcnJvcihgJHtyZXNwb25zZS5lcnJvclRleHR9IGF0ICR7dXJsfWApXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yRnJhbWVOYXZpZ2F0aW9uKGZyYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXNzZXJ0Tm9MZWdhY3lOYXZpZ2F0aW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyB3YWl0VW50aWwgPSBbJ2xvYWQnXSwgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy5uYXZpZ2F0aW9uVGltZW91dCgpLCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBMaWZlY3ljbGVXYXRjaGVyKHRoaXMsIGZyYW1lLCB3YWl0VW50aWwsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB3YXRjaGVyLnRpbWVvdXRPclRlcm1pbmF0aW9uUHJvbWlzZSgpLFxuICAgICAgICAgICAgd2F0Y2hlci5zYW1lRG9jdW1lbnROYXZpZ2F0aW9uUHJvbWlzZSgpLFxuICAgICAgICAgICAgd2F0Y2hlci5uZXdEb2N1bWVudE5hdmlnYXRpb25Qcm9taXNlKCksXG4gICAgICAgIF0pO1xuICAgICAgICB3YXRjaGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIHJldHVybiB3YXRjaGVyLm5hdmlnYXRpb25SZXNwb25zZSgpO1xuICAgIH1cbiAgICBhc3luYyBfb25GcmFtZU1vdmVkKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXRJbmZvLnR5cGUgIT09ICdpZnJhbWUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhzYWR5bSk6IFJlbW92ZSBkZWJ1ZyBtZXNzYWdlIG9uY2UgcHJvcGVyIE9PUElGIHN1cHBvcnQgaXNcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9wdXBwZXRlZXIvcHVwcGV0ZWVyL2lzc3Vlcy8yNTQ4XG4gICAgICAgIGRlYnVnKCdwdXBwZXRlZXI6ZnJhbWUnKShgVGhlIGZyYW1lICcke2V2ZW50LnRhcmdldEluZm8udGFyZ2V0SWR9JyBtb3ZlZCB0byBhbm90aGVyIHNlc3Npb24uIGAgK1xuICAgICAgICAgICAgYE91dC1vZi1wcm9jZXNzIGlmcmFtZXMgKE9PUElGKSBhcmUgbm90IHN1cHBvcnRlZCBieSBQdXBwZXRlZXIgeWV0LiBgICtcbiAgICAgICAgICAgIGBodHRwczovL2dpdGh1Yi5jb20vcHVwcGV0ZWVyL3B1cHBldGVlci9pc3N1ZXMvMjU0OGApO1xuICAgIH1cbiAgICBfb25MaWZlY3ljbGVFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2ZyYW1lcy5nZXQoZXZlbnQuZnJhbWVJZCk7XG4gICAgICAgIGlmICghZnJhbWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZyYW1lLl9vbkxpZmVjeWNsZUV2ZW50KGV2ZW50LmxvYWRlcklkLCBldmVudC5uYW1lKTtcbiAgICAgICAgdGhpcy5lbWl0KEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMuTGlmZWN5Y2xlRXZlbnQsIGZyYW1lKTtcbiAgICB9XG4gICAgX29uRnJhbWVTdG9wcGVkTG9hZGluZyhmcmFtZUlkKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fZnJhbWVzLmdldChmcmFtZUlkKTtcbiAgICAgICAgaWYgKCFmcmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnJhbWUuX29uTG9hZGluZ1N0b3BwZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0KEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMuTGlmZWN5Y2xlRXZlbnQsIGZyYW1lKTtcbiAgICB9XG4gICAgX2hhbmRsZUZyYW1lVHJlZShmcmFtZVRyZWUpIHtcbiAgICAgICAgaWYgKGZyYW1lVHJlZS5mcmFtZS5wYXJlbnRJZClcbiAgICAgICAgICAgIHRoaXMuX29uRnJhbWVBdHRhY2hlZChmcmFtZVRyZWUuZnJhbWUuaWQsIGZyYW1lVHJlZS5mcmFtZS5wYXJlbnRJZCk7XG4gICAgICAgIHRoaXMuX29uRnJhbWVOYXZpZ2F0ZWQoZnJhbWVUcmVlLmZyYW1lKTtcbiAgICAgICAgaWYgKCFmcmFtZVRyZWUuY2hpbGRGcmFtZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZnJhbWVUcmVlLmNoaWxkRnJhbWVzKVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlRnJhbWVUcmVlKGNoaWxkKTtcbiAgICB9XG4gICAgcGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gICAgfVxuICAgIG1haW5GcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5GcmFtZTtcbiAgICB9XG4gICAgZnJhbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9mcmFtZXMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBmcmFtZShmcmFtZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXMuZ2V0KGZyYW1lSWQpIHx8IG51bGw7XG4gICAgfVxuICAgIF9vbkZyYW1lQXR0YWNoZWQoZnJhbWVJZCwgcGFyZW50RnJhbWVJZCkge1xuICAgICAgICBpZiAodGhpcy5fZnJhbWVzLmhhcyhmcmFtZUlkKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYXNzZXJ0KHBhcmVudEZyYW1lSWQpO1xuICAgICAgICBjb25zdCBwYXJlbnRGcmFtZSA9IHRoaXMuX2ZyYW1lcy5nZXQocGFyZW50RnJhbWVJZCk7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IEZyYW1lKHRoaXMsIHBhcmVudEZyYW1lLCBmcmFtZUlkKTtcbiAgICAgICAgdGhpcy5fZnJhbWVzLnNldChmcmFtZS5faWQsIGZyYW1lKTtcbiAgICAgICAgdGhpcy5lbWl0KEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMuRnJhbWVBdHRhY2hlZCwgZnJhbWUpO1xuICAgIH1cbiAgICBfb25GcmFtZU5hdmlnYXRlZChmcmFtZVBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgaXNNYWluRnJhbWUgPSAhZnJhbWVQYXlsb2FkLnBhcmVudElkO1xuICAgICAgICBsZXQgZnJhbWUgPSBpc01haW5GcmFtZVxuICAgICAgICAgICAgPyB0aGlzLl9tYWluRnJhbWVcbiAgICAgICAgICAgIDogdGhpcy5fZnJhbWVzLmdldChmcmFtZVBheWxvYWQuaWQpO1xuICAgICAgICBhc3NlcnQoaXNNYWluRnJhbWUgfHwgZnJhbWUsICdXZSBlaXRoZXIgbmF2aWdhdGUgdG9wIGxldmVsIG9yIGhhdmUgb2xkIHZlcnNpb24gb2YgdGhlIG5hdmlnYXRlZCBmcmFtZScpO1xuICAgICAgICAvLyBEZXRhY2ggYWxsIGNoaWxkIGZyYW1lcyBmaXJzdC5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGZyYW1lLmNoaWxkRnJhbWVzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRnJhbWVzUmVjdXJzaXZlbHkoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBvciBjcmVhdGUgbWFpbiBmcmFtZS5cbiAgICAgICAgaWYgKGlzTWFpbkZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZnJhbWUgaWQgdG8gcmV0YWluIGZyYW1lIGlkZW50aXR5IG9uIGNyb3NzLXByb2Nlc3MgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZXMuZGVsZXRlKGZyYW1lLl9pZCk7XG4gICAgICAgICAgICAgICAgZnJhbWUuX2lkID0gZnJhbWVQYXlsb2FkLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBtYWluIGZyYW1lIG5hdmlnYXRpb24uXG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgRnJhbWUodGhpcywgbnVsbCwgZnJhbWVQYXlsb2FkLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lcy5zZXQoZnJhbWVQYXlsb2FkLmlkLCBmcmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9tYWluRnJhbWUgPSBmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgZnJhbWUgcGF5bG9hZC5cbiAgICAgICAgZnJhbWUuX25hdmlnYXRlZChmcmFtZVBheWxvYWQpO1xuICAgICAgICB0aGlzLmVtaXQoRnJhbWVNYW5hZ2VyRW1pdHRlZEV2ZW50cy5GcmFtZU5hdmlnYXRlZCwgZnJhbWUpO1xuICAgIH1cbiAgICBhc3luYyBfZW5zdXJlSXNvbGF0ZWRXb3JsZChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc29sYXRlZFdvcmxkcy5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2lzb2xhdGVkV29ybGRzLmFkZChuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuYWRkU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnQnLCB7XG4gICAgICAgICAgICBzb3VyY2U6IGAvLyMgc291cmNlVVJMPSR7RVZBTFVBVElPTl9TQ1JJUFRfVVJMfWAsXG4gICAgICAgICAgICB3b3JsZE5hbWU6IG5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGcmFtZXMgbWlnaHQgYmUgcmVtb3ZlZCBiZWZvcmUgd2Ugc2VuZCB0aGlzLlxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmZyYW1lcygpLm1hcCgoZnJhbWUpID0+IHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgLnNlbmQoJ1BhZ2UuY3JlYXRlSXNvbGF0ZWRXb3JsZCcsIHtcbiAgICAgICAgICAgIGZyYW1lSWQ6IGZyYW1lLl9pZCxcbiAgICAgICAgICAgIHdvcmxkTmFtZTogbmFtZSxcbiAgICAgICAgICAgIGdyYW50VW5pdmVyYWxBY2Nlc3M6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZGVidWdFcnJvcikpKTtcbiAgICB9XG4gICAgX29uRnJhbWVOYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudChmcmFtZUlkLCB1cmwpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLl9mcmFtZXMuZ2V0KGZyYW1lSWQpO1xuICAgICAgICBpZiAoIWZyYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmcmFtZS5fbmF2aWdhdGVkV2l0aGluRG9jdW1lbnQodXJsKTtcbiAgICAgICAgdGhpcy5lbWl0KEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMuRnJhbWVOYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudCwgZnJhbWUpO1xuICAgICAgICB0aGlzLmVtaXQoRnJhbWVNYW5hZ2VyRW1pdHRlZEV2ZW50cy5GcmFtZU5hdmlnYXRlZCwgZnJhbWUpO1xuICAgIH1cbiAgICBfb25GcmFtZURldGFjaGVkKGZyYW1lSWQpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLl9mcmFtZXMuZ2V0KGZyYW1lSWQpO1xuICAgICAgICBpZiAoZnJhbWUpXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVGcmFtZXNSZWN1cnNpdmVseShmcmFtZSk7XG4gICAgfVxuICAgIF9vbkV4ZWN1dGlvbkNvbnRleHRDcmVhdGVkKGNvbnRleHRQYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGF1eERhdGEgPSBjb250ZXh0UGF5bG9hZC5hdXhEYXRhO1xuICAgICAgICBjb25zdCBmcmFtZUlkID0gYXV4RGF0YSA/IGF1eERhdGEuZnJhbWVJZCA6IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fZnJhbWVzLmdldChmcmFtZUlkKSB8fCBudWxsO1xuICAgICAgICBsZXQgd29ybGQgPSBudWxsO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0UGF5bG9hZC5hdXhEYXRhICYmICEhY29udGV4dFBheWxvYWQuYXV4RGF0YVsnaXNEZWZhdWx0J10pIHtcbiAgICAgICAgICAgICAgICB3b3JsZCA9IGZyYW1lLl9tYWluV29ybGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0UGF5bG9hZC5uYW1lID09PSBVVElMSVRZX1dPUkxEX05BTUUgJiZcbiAgICAgICAgICAgICAgICAhZnJhbWUuX3NlY29uZGFyeVdvcmxkLl9oYXNDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIHNlc3Npb25zIHRvIHRoZSBzYW1lIHRhcmdldCwgdGhlcmUncyBhIHJhY2UgYmV0d2VlblxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb25zIHNvIHdlIG1pZ2h0IGVuZCB1cCBjcmVhdGluZyBtdWx0aXBsZSBpc29sYXRlZCB3b3JsZHMuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBlaXRoZXIuXG4gICAgICAgICAgICAgICAgd29ybGQgPSBmcmFtZS5fc2Vjb25kYXJ5V29ybGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHRoaXMuX2NsaWVudCwgY29udGV4dFBheWxvYWQsIHdvcmxkKTtcbiAgICAgICAgaWYgKHdvcmxkKVxuICAgICAgICAgICAgd29ybGQuX3NldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dC5zZXQoY29udGV4dFBheWxvYWQuaWQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBfb25FeGVjdXRpb25Db250ZXh0RGVzdHJveWVkKGV4ZWN1dGlvbkNvbnRleHRJZCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dElkVG9Db250ZXh0LmdldChleGVjdXRpb25Db250ZXh0SWQpO1xuICAgICAgICBpZiAoIWNvbnRleHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dC5kZWxldGUoZXhlY3V0aW9uQ29udGV4dElkKTtcbiAgICAgICAgaWYgKGNvbnRleHQuX3dvcmxkKVxuICAgICAgICAgICAgY29udGV4dC5fd29ybGQuX3NldENvbnRleHQobnVsbCk7XG4gICAgfVxuICAgIF9vbkV4ZWN1dGlvbkNvbnRleHRzQ2xlYXJlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuX3dvcmxkKVxuICAgICAgICAgICAgICAgIGNvbnRleHQuX3dvcmxkLl9zZXRDb250ZXh0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dC5jbGVhcigpO1xuICAgIH1cbiAgICBleGVjdXRpb25Db250ZXh0QnlJZChjb250ZXh0SWQpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHRJZFRvQ29udGV4dC5nZXQoY29udGV4dElkKTtcbiAgICAgICAgYXNzZXJ0KGNvbnRleHQsICdJTlRFUk5BTCBFUlJPUjogbWlzc2luZyBjb250ZXh0IHdpdGggaWQgPSAnICsgY29udGV4dElkKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIF9yZW1vdmVGcmFtZXNSZWN1cnNpdmVseShmcmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGZyYW1lLmNoaWxkRnJhbWVzKCkpXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVGcmFtZXNSZWN1cnNpdmVseShjaGlsZCk7XG4gICAgICAgIGZyYW1lLl9kZXRhY2goKTtcbiAgICAgICAgdGhpcy5fZnJhbWVzLmRlbGV0ZShmcmFtZS5faWQpO1xuICAgICAgICB0aGlzLmVtaXQoRnJhbWVNYW5hZ2VyRW1pdHRlZEV2ZW50cy5GcmFtZURldGFjaGVkLCBmcmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBdCBldmVyeSBwb2ludCBvZiB0aW1lLCBwYWdlIGV4cG9zZXMgaXRzIGN1cnJlbnQgZnJhbWUgdHJlZSB2aWEgdGhlXG4gKiB7QGxpbmsgUGFnZS5tYWluRnJhbWUgfCBwYWdlLm1haW5GcmFtZX0gYW5kXG4gKiB7QGxpbmsgRnJhbWUuY2hpbGRGcmFtZXMgfCBmcmFtZS5jaGlsZEZyYW1lc30gbWV0aG9kcy5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIGBGcmFtZWAgb2JqZWN0IGxpZmVjeWNsZXMgYXJlIGNvbnRyb2xsZWQgYnkgdGhyZWUgZXZlbnRzIHRoYXQgYXJlIGFsbFxuICogZGlzcGF0Y2hlZCBvbiB0aGUgcGFnZSBvYmplY3Q6XG4gKlxuICogLSB7QGxpbmsgUGFnZUVtaXR0ZWRFdmVudHMuRnJhbWVBdHRhY2hlZH1cbiAqXG4gKiAtIHtAbGluayBQYWdlRW1pdHRlZEV2ZW50cy5GcmFtZU5hdmlnYXRlZH1cbiAqXG4gKiAtIHtAbGluayBQYWdlRW1pdHRlZEV2ZW50cy5GcmFtZURldGFjaGVkfVxuICpcbiAqIEBFeGFtcGxlXG4gKiBBbiBleGFtcGxlIG9mIGR1bXBpbmcgZnJhbWUgdHJlZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gKlxuICogKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHB1cHBldGVlci5sYXVuY2goKTtcbiAqICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICogICBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vY2hyb21lL2Jyb3dzZXIvY2FuYXJ5Lmh0bWwnKTtcbiAqICAgZHVtcEZyYW1lVHJlZShwYWdlLm1haW5GcmFtZSgpLCAnJyk7XG4gKiAgIGF3YWl0IGJyb3dzZXIuY2xvc2UoKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIGR1bXBGcmFtZVRyZWUoZnJhbWUsIGluZGVudCkge1xuICogICAgIGNvbnNvbGUubG9nKGluZGVudCArIGZyYW1lLnVybCgpKTtcbiAqICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGZyYW1lLmNoaWxkRnJhbWVzKCkpIHtcbiAqICAgICBkdW1wRnJhbWVUcmVlKGNoaWxkLCBpbmRlbnQgKyAnICAnKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pKCk7XG4gKiBgYGBcbiAqXG4gKiBARXhhbXBsZVxuICogQW4gZXhhbXBsZSBvZiBnZXR0aW5nIHRleHQgZnJvbSBhbiBpZnJhbWUgZWxlbWVudDpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZnJhbWUgPSBwYWdlLmZyYW1lcygpLmZpbmQoZnJhbWUgPT4gZnJhbWUubmFtZSgpID09PSAnbXlmcmFtZScpO1xuICogY29uc3QgdGV4dCA9IGF3YWl0IGZyYW1lLiRldmFsKCcuc2VsZWN0b3InLCBlbGVtZW50ID0+IGVsZW1lbnQudGV4dENvbnRlbnQpO1xuICogY29uc29sZS5sb2codGV4dCk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFtZSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhbWVNYW5hZ2VyLCBwYXJlbnRGcmFtZSwgZnJhbWVJZCkge1xuICAgICAgICB0aGlzLl91cmwgPSAnJztcbiAgICAgICAgdGhpcy5fZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZGVySWQgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGlmZWN5Y2xlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9mcmFtZU1hbmFnZXIgPSBmcmFtZU1hbmFnZXI7XG4gICAgICAgIHRoaXMuX3BhcmVudEZyYW1lID0gcGFyZW50RnJhbWU7XG4gICAgICAgIHRoaXMuX3VybCA9ICcnO1xuICAgICAgICB0aGlzLl9pZCA9IGZyYW1lSWQ7XG4gICAgICAgIHRoaXMuX2RldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvYWRlcklkID0gJyc7XG4gICAgICAgIHRoaXMuX21haW5Xb3JsZCA9IG5ldyBET01Xb3JsZChmcmFtZU1hbmFnZXIsIHRoaXMsIGZyYW1lTWFuYWdlci5fdGltZW91dFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5V29ybGQgPSBuZXcgRE9NV29ybGQoZnJhbWVNYW5hZ2VyLCB0aGlzLCBmcmFtZU1hbmFnZXIuX3RpbWVvdXRTZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuX2NoaWxkRnJhbWVzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50RnJhbWUpXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRGcmFtZS5fY2hpbGRGcmFtZXMuYWRkKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogYGZyYW1lLmdvdG9gIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWY6XG4gICAgICogLSB0aGVyZSdzIGFuIFNTTCBlcnJvciAoZS5nLiBpbiBjYXNlIG9mIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlcykuXG4gICAgICpcbiAgICAgKiAtIHRhcmdldCBVUkwgaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIC0gdGhlIGB0aW1lb3V0YCBpcyBleGNlZWRlZCBkdXJpbmcgbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIC0gdGhlIHJlbW90ZSBzZXJ2ZXIgZG9lcyBub3QgcmVzcG9uZCBvciBpcyB1bnJlYWNoYWJsZS5cbiAgICAgKlxuICAgICAqIC0gdGhlIG1haW4gcmVzb3VyY2UgZmFpbGVkIHRvIGxvYWQuXG4gICAgICpcbiAgICAgKiBgZnJhbWUuZ290b2Agd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBhbnkgdmFsaWQgSFRUUCBzdGF0dXMgY29kZSBpc1xuICAgICAqIHJldHVybmVkIGJ5IHRoZSByZW1vdGUgc2VydmVyLCBpbmNsdWRpbmcgNDA0IFwiTm90IEZvdW5kXCIgYW5kIDUwMCBcIkludGVybmFsXG4gICAgICogU2VydmVyIEVycm9yXCIuICBUaGUgc3RhdHVzIGNvZGUgZm9yIHN1Y2ggcmVzcG9uc2VzIGNhbiBiZSByZXRyaWV2ZWQgYnlcbiAgICAgKiBjYWxsaW5nIHtAbGluayBIVFRQUmVzcG9uc2Uuc3RhdHVzfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IGBmcmFtZS5nb3RvYCBlaXRoZXIgdGhyb3dzIGFuIGVycm9yIG9yIHJldHVybnMgYSBtYWluIHJlc291cmNlXG4gICAgICogcmVzcG9uc2UuIFRoZSBvbmx5IGV4Y2VwdGlvbnMgYXJlIG5hdmlnYXRpb24gdG8gYGFib3V0OmJsYW5rYCBvclxuICAgICAqIG5hdmlnYXRpb24gdG8gdGhlIHNhbWUgVVJMIHdpdGggYSBkaWZmZXJlbnQgaGFzaCwgd2hpY2ggd291bGQgc3VjY2VlZCBhbmRcbiAgICAgKiByZXR1cm4gYG51bGxgLlxuICAgICAqXG4gICAgICogTk9URTogSGVhZGxlc3MgbW9kZSBkb2Vzbid0IHN1cHBvcnQgbmF2aWdhdGlvbiB0byBhIFBERiBkb2N1bWVudC4gU2VlXG4gICAgICogdGhlIHtAbGluayBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NjEyOTUgfCB1cHN0cmVhbVxuICAgICAqIGlzc3VlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSB0aGUgVVJMIHRvIG5hdmlnYXRlIHRoZSBmcmFtZSB0by4gVGhpcyBzaG91bGQgaW5jbHVkZSB0aGVcbiAgICAgKiBzY2hlbWUsIGUuZy4gYGh0dHBzOi8vYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG5hdmlnYXRpb24gb3B0aW9ucy4gYHdhaXRVbnRpbGAgaXMgdXNlZnVsIHRvIGRlZmluZSB3aGVuXG4gICAgICogdGhlIG5hdmlnYXRpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bCAtIHNlZSB0aGUgZG9jcyBmb3JcbiAgICAgKiB7QGxpbmsgUHVwcGV0ZWVyTGlmZUN5Y2xlRXZlbnR9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG1haW4gcmVzb3VyY2UgcmVzcG9uc2UuIEluIGNhc2Ugb2ZcbiAgICAgKiBtdWx0aXBsZSByZWRpcmVjdHMsIHRoZSBuYXZpZ2F0aW9uIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSByZXNwb25zZSBvZiB0aGVcbiAgICAgKiBsYXN0IHJlZGlyZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdvdG8odXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2ZyYW1lTWFuYWdlci5uYXZpZ2F0ZUZyYW1lKHRoaXMsIHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBUaGlzIHJlc29sdmVzIHdoZW4gdGhlIGZyYW1lIG5hdmlnYXRlcyB0byBhIG5ldyBVUkwuIEl0IGlzIHVzZWZ1bCBmb3Igd2hlblxuICAgICAqIHlvdSBydW4gY29kZSB3aGljaCB3aWxsIGluZGlyZWN0bHkgY2F1c2UgdGhlIGZyYW1lIHRvIG5hdmlnYXRlLiBDb25zaWRlclxuICAgICAqIHRoaXMgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIC8vIFRoZSBuYXZpZ2F0aW9uIHByb21pc2UgcmVzb2x2ZXMgYWZ0ZXIgbmF2aWdhdGlvbiBoYXMgZmluaXNoZWRcbiAgICAgKiAgIGZyYW1lLndhaXRGb3JOYXZpZ2F0aW9uKCksXG4gICAgICogICAvLyBDbGlja2luZyB0aGUgbGluayB3aWxsIGluZGlyZWN0bHkgY2F1c2UgYSBuYXZpZ2F0aW9uXG4gICAgICogICBmcmFtZS5jbGljaygnYS5teS1saW5rJyksXG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2FnZSBvZiB0aGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5X0FQSSB8IEhpc3RvcnkgQVBJfSB0byBjaGFuZ2UgdGhlIFVSTCBpcyBjb25zaWRlcmVkIGEgbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byBjb25maWd1cmUgd2hlbiB0aGUgbmF2aWdhdGlvbiBpcyBjb25zaWRlZCBmaW5pc2hlZC5cbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBmcmFtZSBuYXZpZ2F0ZXMgdG8gYSBuZXcgVVJMLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JOYXZpZ2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZnJhbWVNYW5hZ2VyLndhaXRGb3JGcmFtZU5hdmlnYXRpb24odGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmcmFtZSdzIGRlZmF1bHQgZXhlY3V0aW9uIGNvbnRleHQuXG4gICAgICovXG4gICAgZXhlY3V0aW9uQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIEZyYW1lLmV2YWx1YXRlfSBhbmRcbiAgICAgKiBgZnJhbWUuZXZhbHVhdGVIYW5kbGVgIGlzIHRoYXQgYGV2YWx1YXRlSGFuZGxlYCB3aWxsIHJldHVybiB0aGUgdmFsdWVcbiAgICAgKiB3cmFwcGVkIGluIGFuIGluLXBhZ2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYmVoYXZlcyBpZGVudGljYWxseSB0byB7QGxpbmsgUGFnZS5ldmFsdWF0ZUhhbmRsZX0gZXhjZXB0IGl0J3NcbiAgICAgKiBydW4gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBgZnJhbWVgLCByYXRoZXIgdGhhbiB0aGUgZW50aXJlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUZ1bmN0aW9uIC0gYSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aXRoaW4gdGhlIGZyYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBwYWdlRnVuY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZUhhbmRsZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC5ldmFsdWF0ZUhhbmRsZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYmVoYXZlcyBpZGVudGljYWxseSB0byB7QGxpbmsgUGFnZS5ldmFsdWF0ZX0gZXhjZXB0IGl0J3MgcnVuXG4gICAgICogd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBgZnJhbWVgLCByYXRoZXIgdGhhbiB0aGUgZW50aXJlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUZ1bmN0aW9uIC0gYSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aXRoaW4gdGhlIGZyYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBwYWdlRnVuY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC5ldmFsdWF0ZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBxdWVyaWVzIHRoZSBmcmFtZSBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gYSBzZWxlY3RvciB0byBxdWVyeSBmb3IuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGFuIGBFbGVtZW50SGFuZGxlYCBwb2ludGluZyBhdCB0aGVcbiAgICAgKiBlbGVtZW50LCBvciBgbnVsbGAgaWYgaXQgd2FzIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyAkKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluV29ybGQuJChzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV2YWx1YXRlcyB0aGUgZ2l2ZW4gWFBhdGggZXhwcmVzc2lvbiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHByZXNzaW9uIC0gdGhlIFhQYXRoIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUuXG4gICAgICovXG4gICAgYXN5bmMgJHgoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbldvcmxkLiR4KGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcnVucyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2l0aGluXG4gICAgICogdGhlIGZyYW1lIGFuZCBwYXNzZXMgaXQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogSWYgYHBhZ2VGdW5jdGlvbmAgcmV0dXJucyBhIFByb21pc2UsIHRoZW4gYGZyYW1lLiRldmFsYCB3b3VsZCB3YWl0IGZvclxuICAgICAqIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBzZWFyY2hWYWx1ZSA9IGF3YWl0IGZyYW1lLiRldmFsKCcjc2VhcmNoJywgZWwgPT4gZWwudmFsdWUpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlIHNlbGVjdG9yIHRvIHF1ZXJ5IGZvclxuICAgICAqIEBwYXJhbSBwYWdlRnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gYmUgZXZhbHVhdGVkIGluIHRoZSBmcmFtZSdzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gYHBhZ2VGdW5jdG9uYFxuICAgICAqL1xuICAgIGFzeW5jICRldmFsKHNlbGVjdG9yLCBwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC4kZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHJ1bnMgYEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpYCB3aXRoaW5cbiAgICAgKiB0aGUgZnJhbWUgYW5kIHBhc3NlcyBpdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYHBhZ2VGdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBJZiBgcGFnZUZ1bmN0aW9uYCByZXR1cm5zIGEgUHJvbWlzZSwgdGhlbiBgZnJhbWUuJCRldmFsYCB3b3VsZCB3YWl0IGZvclxuICAgICAqIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBkaXZzQ291bnRzID0gYXdhaXQgZnJhbWUuJCRldmFsKCdkaXYnLCBkaXZzID0+IGRpdnMubGVuZ3RoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIHRoZSBzZWxlY3RvciB0byBxdWVyeSBmb3JcbiAgICAgKiBAcGFyYW0gcGFnZUZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGJlIGV2YWx1YXRlZCBpbiB0aGUgZnJhbWUncyBjb250ZXh0XG4gICAgICogQHBhcmFtIGFyZ3MgLSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIGBwYWdlRnVuY3RvbmBcbiAgICAgKi9cbiAgICBhc3luYyAkJGV2YWwoc2VsZWN0b3IsIHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbldvcmxkLiQkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBydW5zIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsYCBpbiB0aGUgZnJhbWUgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIGEgc2VsZWN0b3IgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGVsZW1lbnQgaGFuZGxlcyBwb2ludGluZyB0byB0aGUgZm91bmQgZnJhbWUgZWxlbWVudHMuXG4gICAgICovXG4gICAgYXN5bmMgJCQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC4kJChzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBmdWxsIEhUTUwgY29udGVudHMgb2YgdGhlIGZyYW1lLCBpbmNsdWRpbmcgdGhlIGRvY3R5cGUuXG4gICAgICovXG4gICAgYXN5bmMgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLmNvbnRlbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IG9mIHRoZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBodG1sIC0gSFRNTCBtYXJrdXAgdG8gYXNzaWduIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byBjb25maWd1cmUgaG93IGxvbmcgYmVmb3JlIHRpbWluZyBvdXQgYW5kIGF0XG4gICAgICogd2hhdCBwb2ludCB0byBjb25zaWRlciB0aGUgY29udGVudCBzZXR0aW5nIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgYXN5bmMgc2V0Q29udGVudChodG1sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLnNldENvbnRlbnQoaHRtbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbmFtZSBpcyBlbXB0eSwgaXQgcmV0dXJucyB0aGUgYGlkYCBhdHRyaWJ1dGUgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgdmFsdWUgaXMgY2FsY3VsYXRlZCBvbmNlIHdoZW4gdGhlIGZyYW1lIGlzIGNyZWF0ZWQsIGFuZCB3aWxsIG5vdFxuICAgICAqIHVwZGF0ZSBpZiB0aGUgYXR0cmlidXRlIGlzIGNoYW5nZWQgbGF0ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgZnJhbWUncyBgbmFtZWAgYXR0cmlidXRlIGFzIHNwZWNpZmllZCBpbiB0aGUgdGFnLlxuICAgICAqL1xuICAgIG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgZnJhbWUncyBVUkwuXG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgcGFyZW50IGBGcmFtZWAsIGlmIGFueS4gRGV0YWNoZWQgYW5kIG1haW4gZnJhbWVzIHJldHVybiBgbnVsbGAuXG4gICAgICovXG4gICAgcGFyZW50RnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRGcmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgY2hpbGQgZnJhbWVzLlxuICAgICAqL1xuICAgIGNoaWxkRnJhbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9jaGlsZEZyYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZnJhbWUgaGFzIGJlZW4gZGV0YWNoZWQsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRGV0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXRhY2hlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGA8c2NyaXB0PmAgdGFnIGludG8gdGhlIHBhZ2Ugd2l0aCB0aGUgZGVzaXJlZCB1cmwgb3IgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gY29uZmlndXJlIHRoZSBzY3JpcHQgdG8gYWRkIHRvIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFkZGVkIHRhZyB3aGVuIHRoZSBzY3JpcHQnc1xuICAgICAqIGBvbmxvYWRgIGV2ZW50IGZpcmVzIG9yIHdoZW4gdGhlIHNjcmlwdCBjb250ZW50IHdhcyBpbmplY3RlZCBpbnRvIHRoZVxuICAgICAqIGZyYW1lLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZFNjcmlwdFRhZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluV29ybGQuYWRkU2NyaXB0VGFnKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj5gIHRhZyBpbnRvIHRoZSBwYWdlIHdpdGggdGhlIGRlc2lyZWQgdXJsIG9yXG4gICAgICogYSBgPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPmAgdGFnIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIGNvbmZpZ3VyZSB0aGUgQ1NTIHRvIGFkZCB0byB0aGUgcGFnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBhZGRlZCB0YWcgd2hlbiB0aGUgc3R5bGVzaGVldHMnc1xuICAgICAqIGBvbmxvYWRgIGV2ZW50IGZpcmVzIG9yIHdoZW4gdGhlIENTUyBjb250ZW50IHdhcyBpbmplY3RlZCBpbnRvIHRoZVxuICAgICAqIGZyYW1lLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZFN0eWxlVGFnKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Xb3JsZC5hZGRTdHlsZVRhZyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjbGlja3MgdGhlIGZpcnN0IGVsZW1lbnQgZm91bmQgdGhhdCBtYXRjaGVzIGBzZWxlY3RvcmAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgc2Nyb2xscyB0aGUgZWxlbWVudCBpbnRvIHZpZXcgaWYgbmVlZGVkLCBhbmQgdGhlbiB1c2VzXG4gICAgICoge0BsaW5rIFBhZ2UubW91c2V9IHRvIGNsaWNrIGluIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQuIElmIHRoZXJlJ3Mgbm9cbiAgICAgKiBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAsIHRoZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQmVhciBpbiBtaW5kIHRoYXQgaWYgYGNsaWNrKClgIHRyaWdnZXJzIGEgbmF2aWdhdGlvbiBldmVudCBhbmQgdGhlcmUncyBhXG4gICAgICogc2VwYXJhdGUgYHBhZ2Uud2FpdEZvck5hdmlnYXRpb24oKWAgcHJvbWlzZSB0byBiZSByZXNvbHZlZCwgeW91IG1heSBlbmQgdXBcbiAgICAgKiB3aXRoIGEgcmFjZSBjb25kaXRpb24gdGhhdCB5aWVsZHMgdW5leHBlY3RlZCByZXN1bHRzLiBUaGUgY29ycmVjdCBwYXR0ZXJuXG4gICAgICogZm9yIGNsaWNrIGFuZCB3YWl0IGZvciBuYXZpZ2F0aW9uIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3QgW3Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIHBhZ2Uud2FpdEZvck5hdmlnYXRpb24od2FpdE9wdGlvbnMpLFxuICAgICAqICAgZnJhbWUuY2xpY2soc2VsZWN0b3IsIGNsaWNrT3B0aW9ucyksXG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlIHNlbGVjdG9yIHRvIHNlYXJjaCBmb3IgdG8gY2xpY2suIElmIHRoZXJlIGFyZVxuICAgICAqIG11bHRpcGxlIGVsZW1lbnRzLCB0aGUgZmlyc3Qgd2lsbCBiZSBjbGlja2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGNsaWNrKHNlbGVjdG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLmNsaWNrKHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyBhbiBlbGVtZW50IHdpdGggYHNlbGVjdG9yYCBhbmQgZm9jdXNlcyBpdC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUncyBubyBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAsIHRoZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudCB0byBmb2N1cy4gSWYgdGhlcmUgYXJlXG4gICAgICogbXVsdGlwbGUgZWxlbWVudHMsIHRoZSBmaXJzdCB3aWxsIGJlIGZvY3VzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZm9jdXMoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLmZvY3VzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyBhbiBlbGVtZW50IHdpdGggYHNlbGVjdG9yYCwgc2Nyb2xscyBpdCBpbnRvIHZpZXcgaWZcbiAgICAgKiBuZWVkZWQsIGFuZCB0aGVuIHVzZXMge0BsaW5rIFBhZ2UubW91c2V9IHRvIGhvdmVyIG92ZXIgdGhlIGNlbnRlciBvZiB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCwgdGhlIG1ldGhvZCB0aHJvd3MgYW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIHRoZSBzZWxlY3RvciBmb3IgdGhlIGVsZW1lbnQgdG8gaG92ZXIuIElmIHRoZXJlIGFyZVxuICAgICAqIG11bHRpcGxlIGVsZW1lbnRzLCB0aGUgZmlyc3Qgd2lsbCBiZSBob3ZlcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGhvdmVyKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRhcnlXb3JsZC5ob3ZlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgYGNoYW5nZWAgYW5kIGBpbnB1dGAgZXZlbnQgb25jZSBhbGwgdGhlIHByb3ZpZGVkIG9wdGlvbnMgaGF2ZVxuICAgICAqIGJlZW4gc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogSWYgdGhlcmUncyBubyBgPHNlbGVjdD5gIGVsZW1lbnQgbWF0Y2hpbmcgYHNlbGVjdG9yYCwgdGhlXG4gICAgICogbWV0aG9kIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBmcmFtZS5zZWxlY3QoJ3NlbGVjdCNjb2xvcnMnLCAnYmx1ZScpOyAvLyBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICogZnJhbWUuc2VsZWN0KCdzZWxlY3QjY29sb3JzJywgJ3JlZCcsICdncmVlbicsICdibHVlJyk7IC8vIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIGEgc2VsZWN0b3IgdG8gcXVlcnkgdGhlIGZyYW1lIGZvclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gc2VsZWN0LiBJZiB0aGUgYDxzZWxlY3Q+YCBoYXMgdGhlXG4gICAgICogYG11bHRpcGxlYCBhdHRyaWJ1dGUsIGFsbCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQsIG90aGVyd2lzZSBvbmx5IHRoZSBmaXJzdFxuICAgICAqIG9uZSBpcyB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICogQHJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIHRoYXQgd2VyZSBzdWNjZXNzZnVsbHkgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgc2VsZWN0KHNlbGVjdG9yLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLnNlbGVjdChzZWxlY3RvciwgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyBhbiBlbGVtZW50IHdpdGggYHNlbGVjdG9yYCwgc2Nyb2xscyBpdCBpbnRvIHZpZXcgaWZcbiAgICAgKiBuZWVkZWQsIGFuZCB0aGVuIHVzZXMge0BsaW5rIFBhZ2UudG91Y2hzY3JlZW59IHRvIHRhcCBpbiB0aGUgY2VudGVyIG9mIHRoZVxuICAgICAqIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogSWYgdGhlcmUncyBubyBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAsIHRoZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlIHNlbGVjdG9yIHRvIHRhcC5cbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbGVtZW50IGhhcyBiZWVuIHRhcHBlZC5cbiAgICAgKi9cbiAgICBhc3luYyB0YXAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLnRhcChzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYGtleWRvd25gLCBga2V5cHJlc3NgL2BpbnB1dGAsIGFuZCBga2V5dXBgIGV2ZW50IGZvciBlYWNoIGNoYXJhY3RlclxuICAgICAqIGluIHRoZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUbyBwcmVzcyBhIHNwZWNpYWwga2V5LCBsaWtlIGBDb250cm9sYCBvciBgQXJyb3dEb3duYCwgdXNlXG4gICAgICoge0BsaW5rIEtleWJvYXJkLnByZXNzfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBhd2FpdCBmcmFtZS50eXBlKCcjbXl0ZXh0YXJlYScsICdIZWxsbycpOyAvLyBUeXBlcyBpbnN0YW50bHlcbiAgICAgKiBhd2FpdCBmcmFtZS50eXBlKCcjbXl0ZXh0YXJlYScsICdXb3JsZCcsIHtkZWxheTogMTAwfSk7IC8vIFR5cGVzIHNsb3dlciwgbGlrZSBhIHVzZXJcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIHRoZSBzZWxlY3RvciBmb3IgdGhlIGVsZW1lbnQgdG8gdHlwZSBpbnRvLiBJZiB0aGVyZSBhcmVcbiAgICAgKiBtdWx0aXBsZSB0aGUgZmlyc3Qgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB0ZXh0IC0gdGV4dCB0byB0eXBlIGludG8gdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHRha2VzIG9uZSBvcHRpb24sIGBkZWxheWAsIHdoaWNoIHNldHMgdGhlIHRpbWUgdG8gd2FpdFxuICAgICAqIGJldHdlZW4ga2V5IHByZXNzZXMgaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB0eXBpbmcgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgYXN5bmMgdHlwZShzZWxlY3RvciwgdGV4dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbldvcmxkLnR5cGUoc2VsZWN0b3IsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYmVoYXZlcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gdGhlIGZpcnN0IHBhcmFtZXRlci4gSWYgaXQncyBhXG4gICAgICogYHN0cmluZ2AsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGBzZWxlY3RvcmAgb3IgYHhwYXRoYCAoaWYgdGhlIHN0cmluZ1xuICAgICAqIHN0YXJ0cyB3aXRoIGAvL2ApLiBUaGlzIG1ldGhvZCB0aGVuIGlzIGEgc2hvcnRjdXQgZm9yXG4gICAgICoge0BsaW5rIEZyYW1lLndhaXRGb3JTZWxlY3Rvcn0gb3Ige0BsaW5rIEZyYW1lLndhaXRGb3JYUGF0aH0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiB0aGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IGZvclxuICAgICAqIHtAbGluayBGcmFtZS53YWl0Rm9yRnVuY3Rpb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgYG51bWJlcmAsIGl0J3MgdHJlYXRlZCBhcyBhIHRpbWVvdXQgaW5cbiAgICAgKiBtaWxsaXNlY29uZHMgYW5kIHRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgYWZ0ZXIgdGhlXG4gICAgICogdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQgLSBhIHNlbGVjdG9yLCBwcmVkaWNhdGUgb3IgdGltZW91dCB0b1xuICAgICAqIHdhaXQgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9uYWwgd2FpdGluZyBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gYXJndW1lbnRzIHRvIHBhc3MgdG8gYHBhZ2VGdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBEb24ndCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIHRoZSBtb3JlIGV4cGxpY2l0XG4gICAgICogbWV0aG9kcyBhdmFpbGFibGU6IHtAbGluayBGcmFtZS53YWl0Rm9yU2VsZWN0b3J9LFxuICAgICAqIHtAbGluayBGcmFtZS53YWl0Rm9yWFBhdGh9LCB7QGxpbmsgRnJhbWUud2FpdEZvckZ1bmN0aW9ufSBvclxuICAgICAqIHtAbGluayBGcmFtZS53YWl0Rm9yVGltZW91dH0uXG4gICAgICovXG4gICAgd2FpdEZvcihzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQsIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCB4UGF0aFBhdHRlcm4gPSAnLy8nO1xuICAgICAgICBjb25zb2xlLndhcm4oJ3dhaXRGb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHVwcGV0ZWVyL3B1cHBldGVlci9pc3N1ZXMvNjIxNCBmb3IgZGV0YWlscyBhbmQgaG93IHRvIG1pZ3JhdGUgeW91ciBjb2RlLicpO1xuICAgICAgICBpZiAoaGVscGVyLmlzU3RyaW5nKHNlbGVjdG9yT3JGdW5jdGlvbk9yVGltZW91dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHNlbGVjdG9yT3JGdW5jdGlvbk9yVGltZW91dDtcbiAgICAgICAgICAgIGlmIChzdHJpbmcuc3RhcnRzV2l0aCh4UGF0aFBhdHRlcm4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JYUGF0aChzdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvclNlbGVjdG9yKHN0cmluZywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlbHBlci5pc051bWJlcihzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiBzZXRUaW1lb3V0KGZ1bGZpbGwsIHNlbGVjdG9yT3JGdW5jdGlvbk9yVGltZW91dCkpO1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JGdW5jdGlvbk9yVGltZW91dCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JGdW5jdGlvbihzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQsIG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0YXJnZXQgdHlwZTogJyArIHR5cGVvZiBzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHlvdXIgc2NyaXB0IHRvIHdhaXQgZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJdCdzIGdlbmVyYWxseSByZWNvbW1lbmRlZCB0byBub3Qgd2FpdCBmb3IgYSBudW1iZXIgb2Ygc2Vjb25kcywgYnV0IGluc3RlYWRcbiAgICAgKiB1c2Uge0BsaW5rIEZyYW1lLndhaXRGb3JTZWxlY3Rvcn0sIHtAbGluayBGcmFtZS53YWl0Rm9yWFBhdGh9IG9yXG4gICAgICoge0BsaW5rIEZyYW1lLndhaXRGb3JGdW5jdGlvbn0gdG8gd2FpdCBmb3IgZXhhY3RseSB0aGUgY29uZGl0aW9ucyB5b3Ugd2FudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBXYWl0IGZvciAxIHNlY29uZDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGF3YWl0IGZyYW1lLndhaXRGb3JUaW1lb3V0KDEwMDApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gICAgICovXG4gICAgd2FpdEZvclRpbWVvdXQobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXNlY29uZHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqXG4gICAgICogV2FpdCBmb3IgdGhlIGBzZWxlY3RvcmAgdG8gYXBwZWFyIGluIHBhZ2UuIElmIGF0IHRoZSBtb21lbnQgb2YgY2FsbGluZyB0aGVcbiAgICAgKiBtZXRob2QgdGhlIGBzZWxlY3RvcmAgYWxyZWFkeSBleGlzdHMsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICogSWYgdGhlIHNlbGVjdG9yIGRvZXNuJ3QgYXBwZWFyIGFmdGVyIHRoZSBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdhaXRpbmcsXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgdGhyb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBhY3Jvc3MgbmF2aWdhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gICAgICpcbiAgICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgICAqICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHB1cHBldGVlci5sYXVuY2goKTtcbiAgICAgKiAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAgICAgKiAgIGxldCBjdXJyZW50VVJMO1xuICAgICAqICAgcGFnZS5tYWluRnJhbWUoKVxuICAgICAqICAgLndhaXRGb3JTZWxlY3RvcignaW1nJylcbiAgICAgKiAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdGaXJzdCBVUkwgd2l0aCBpbWFnZTogJyArIGN1cnJlbnRVUkwpKTtcbiAgICAgKlxuICAgICAqICAgZm9yIChjdXJyZW50VVJMIG9mIFsnaHR0cHM6Ly9leGFtcGxlLmNvbScsICdodHRwczovL2dvb2dsZS5jb20nLCAnaHR0cHM6Ly9iYmMuY29tJ10pIHtcbiAgICAgKiAgICAgYXdhaXQgcGFnZS5nb3RvKGN1cnJlbnRVUkwpO1xuICAgICAqICAgfVxuICAgICAqICAgYXdhaXQgYnJvd3Nlci5jbG9zZSgpO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlIHNlbGVjdG9yIHRvIHdhaXQgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB0byBkZWZpbmUgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHZpc2libGUgYW5kIGhvd1xuICAgICAqIGxvbmcgdG8gd2FpdCBiZWZvcmUgdGltaW5nIG91dC5cbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhbiBlbGVtZW50IG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICAgICAqIHN0cmluZyBpcyBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JTZWxlY3RvcihzZWxlY3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX3NlY29uZGFyeVdvcmxkLndhaXRGb3JTZWxlY3RvcihzZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghaGFuZGxlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IG1haW5FeGVjdXRpb25Db250ZXh0ID0gYXdhaXQgdGhpcy5fbWFpbldvcmxkLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFpbkV4ZWN1dGlvbkNvbnRleHQuX2Fkb3B0RWxlbWVudEhhbmRsZShoYW5kbGUpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFdhaXQgZm9yIHRoZSBgeHBhdGhgIHRvIGFwcGVhciBpbiBwYWdlLiBJZiBhdCB0aGUgbW9tZW50IG9mIGNhbGxpbmcgdGhlXG4gICAgICogbWV0aG9kIHRoZSBgeHBhdGhgIGFscmVhZHkgZXhpc3RzLCB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuIGltbWVkaWF0ZWx5LiBJZlxuICAgICAqIHRoZSB4cGF0aCBkb2Vzbid0IGFwcGVhciBhZnRlciB0aGUgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3YWl0aW5nLCB0aGVcbiAgICAgKiBmdW5jdGlvbiB3aWxsIHRocm93LlxuICAgICAqXG4gICAgICogRm9yIGEgY29kZSBleGFtcGxlLCBzZWUgdGhlIGV4YW1wbGUgZm9yIHtAbGluayBGcmFtZS53YWl0Rm9yU2VsZWN0b3J9LiBUaGF0XG4gICAgICogZnVuY3Rpb24gYmVoYXZlcyBpZGVudGljYWxseSBvdGhlciB0aGFuIHRha2luZyBhIENTUyBzZWxlY3RvciByYXRoZXIgdGhhblxuICAgICAqIGFuIFhQYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHhwYXRoIC0gdGhlIFhQYXRoIGV4cHJlc3Npb24gdG8gd2FpdCBmb3IuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgIC0gb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHZpc2libGl0eSBvZiB0aGUgZWxlbWVudCBhbmQgaG93XG4gICAgICogbG9uZyB0byB3YWl0IGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JYUGF0aCh4cGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX3NlY29uZGFyeVdvcmxkLndhaXRGb3JYUGF0aCh4cGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghaGFuZGxlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IG1haW5FeGVjdXRpb25Db250ZXh0ID0gYXdhaXQgdGhpcy5fbWFpbldvcmxkLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFpbkV4ZWN1dGlvbkNvbnRleHQuX2Fkb3B0RWxlbWVudEhhbmRsZShoYW5kbGUpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIFRoZSBgd2FpdEZvckZ1bmN0aW9uYCBjYW4gYmUgdXNlZCB0byBvYnNlcnZlIHZpZXdwb3J0IHNpemUgY2hhbmdlOlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gICAgICpcbiAgICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgICAqIC4gIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKCk7XG4gICAgICogLiAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAqIC4gIGNvbnN0IHdhdGNoRG9nID0gcGFnZS5tYWluRnJhbWUoKS53YWl0Rm9yRnVuY3Rpb24oJ3dpbmRvdy5pbm5lcldpZHRoIDwgMTAwJyk7XG4gICAgICogLiAgcGFnZS5zZXRWaWV3cG9ydCh7d2lkdGg6IDUwLCBoZWlnaHQ6IDUwfSk7XG4gICAgICogLiAgYXdhaXQgd2F0Y2hEb2c7XG4gICAgICogLiAgYXdhaXQgYnJvd3Nlci5jbG9zZSgpO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUbyBwYXNzIGFyZ3VtZW50cyBmcm9tIE5vZGUuanMgdG8gdGhlIHByZWRpY2F0ZSBvZiBgcGFnZS53YWl0Rm9yRnVuY3Rpb25gIGZ1bmN0aW9uOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBzZWxlY3RvciA9ICcuZm9vJztcbiAgICAgKiBhd2FpdCBmcmFtZS53YWl0Rm9yRnVuY3Rpb24oXG4gICAgICogICBzZWxlY3RvciA9PiAhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgICAqICAge30sIC8vIGVtcHR5IG9wdGlvbnMgb2JqZWN0XG4gICAgICogICBzZWxlY3RvclxuICAgICAqKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlRnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgaW4gdGhlIGZyYW1lIGNvbnRleHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgcG9sbGluZyBtZXRob2QgYW5kIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgYHBhZ2VGdW5jdGlvbmAuXG4gICAgICogQHJldHVybnMgdGhlIHByb21pc2Ugd2hpY2ggcmVzb2x2ZSB3aGVuIHRoZSBgcGFnZUZ1bmN0aW9uYCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLlxuICAgICAqL1xuICAgIHdhaXRGb3JGdW5jdGlvbihwYWdlRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbldvcmxkLndhaXRGb3JGdW5jdGlvbihwYWdlRnVuY3Rpb24sIG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgZnJhbWUncyB0aXRsZS5cbiAgICAgKi9cbiAgICBhc3luYyB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZGFyeVdvcmxkLnRpdGxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9uYXZpZ2F0ZWQoZnJhbWVQYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBmcmFtZVBheWxvYWQubmFtZTtcbiAgICAgICAgdGhpcy5fdXJsID0gYCR7ZnJhbWVQYXlsb2FkLnVybH0ke2ZyYW1lUGF5bG9hZC51cmxGcmFnbWVudCB8fCAnJ31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbmF2aWdhdGVkV2l0aGluRG9jdW1lbnQodXJsKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uTGlmZWN5Y2xlRXZlbnQobG9hZGVySWQsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVySWQgPSBsb2FkZXJJZDtcbiAgICAgICAgICAgIHRoaXMuX2xpZmVjeWNsZUV2ZW50cy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpZmVjeWNsZUV2ZW50cy5hZGQobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbkxvYWRpbmdTdG9wcGVkKCkge1xuICAgICAgICB0aGlzLl9saWZlY3ljbGVFdmVudHMuYWRkKCdET01Db250ZW50TG9hZGVkJyk7XG4gICAgICAgIHRoaXMuX2xpZmVjeWNsZUV2ZW50cy5hZGQoJ2xvYWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2RldGFjaCgpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9tYWluV29ybGQuX2RldGFjaCgpO1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnlXb3JsZC5fZGV0YWNoKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRGcmFtZSlcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudEZyYW1lLl9jaGlsZEZyYW1lcy5kZWxldGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudEZyYW1lID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnROb0xlZ2FjeU5hdmlnYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBhc3NlcnQob3B0aW9uc1snbmV0d29ya0lkbGVUaW1lb3V0J10gPT09IHVuZGVmaW5lZCwgJ0VSUk9SOiBuZXR3b3JrSWRsZVRpbWVvdXQgb3B0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyk7XG4gICAgYXNzZXJ0KG9wdGlvbnNbJ25ldHdvcmtJZGxlSW5mbGlnaHQnXSA9PT0gdW5kZWZpbmVkLCAnRVJST1I6IG5ldHdvcmtJZGxlSW5mbGlnaHQgb3B0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyk7XG4gICAgYXNzZXJ0KG9wdGlvbnMud2FpdFVudGlsICE9PSAnbmV0d29ya2lkbGUnLCAnRVJST1I6IFwibmV0d29ya2lkbGVcIiBvcHRpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIFwibmV0d29ya2lkbGUyXCIgaW5zdGVhZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVNYW5hZ2VyLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhlbHBlciwgZGVidWdFcnJvciB9IGZyb20gJy4vaGVscGVyLmpzJztcbi8qKlxuICpcbiAqIFJlcHJlc2VudHMgYW4gSFRUUCByZXF1ZXN0IHNlbnQgYnkgYSBwYWdlLlxuICogQHJlbWFya3NcbiAqXG4gKiBXaGVuZXZlciB0aGUgcGFnZSBzZW5kcyBhIHJlcXVlc3QsIHN1Y2ggYXMgZm9yIGEgbmV0d29yayByZXNvdXJjZSwgdGhlXG4gKiBmb2xsb3dpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIGJ5IFB1cHBldGVlcidzIGBwYWdlYDpcbiAqXG4gKiAtIGByZXF1ZXN0YDogIGVtaXR0ZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBpc3N1ZWQgYnkgdGhlIHBhZ2UuXG4gKiAtIGByZXF1ZXN0ZmluaXNoZWRgIC0gZW1pdHRlZCB3aGVuIHRoZSByZXNwb25zZSBib2R5IGlzIGRvd25sb2FkZWQgYW5kIHRoZVxuICogICByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICpcbiAqIElmIHJlcXVlc3QgZmFpbHMgYXQgc29tZSBwb2ludCwgdGhlbiBpbnN0ZWFkIG9mIGByZXF1ZXN0ZmluaXNoZWRgIGV2ZW50IHRoZVxuICogYHJlcXVlc3RmYWlsZWRgIGV2ZW50IGlzIGVtaXR0ZWQuXG4gKlxuICogQWxsIG9mIHRoZXNlIGV2ZW50cyBwcm92aWRlIGFuIGluc3RhbmNlIG9mIGBIVFRQUmVxdWVzdGAgcmVwcmVzZW50aW5nIHRoZVxuICogcmVxdWVzdCB0aGF0IG9jY3VycmVkOlxuICpcbiAqIGBgYFxuICogcGFnZS5vbigncmVxdWVzdCcsIHJlcXVlc3QgPT4gLi4uKVxuICogYGBgXG4gKlxuICogTk9URTogSFRUUCBFcnJvciByZXNwb25zZXMsIHN1Y2ggYXMgNDA0IG9yIDUwMywgYXJlIHN0aWxsIHN1Y2Nlc3NmdWxcbiAqIHJlc3BvbnNlcyBmcm9tIEhUVFAgc3RhbmRwb2ludCwgc28gcmVxdWVzdCB3aWxsIGNvbXBsZXRlIHdpdGhcbiAqIGByZXF1ZXN0ZmluaXNoZWRgIGV2ZW50LlxuICpcbiAqIElmIHJlcXVlc3QgZ2V0cyBhICdyZWRpcmVjdCcgcmVzcG9uc2UsIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWxseSBmaW5pc2hlZFxuICogd2l0aCB0aGUgYHJlcXVlc3RmaW5pc2hlZGAgZXZlbnQsIGFuZCBhIG5ldyByZXF1ZXN0IGlzIGlzc3VlZCB0byBhXG4gKiByZWRpcmVjdGVkIHVybC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBIVFRQUmVxdWVzdCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBmcmFtZSwgaW50ZXJjZXB0aW9uSWQsIGFsbG93SW50ZXJjZXB0aW9uLCBldmVudCwgcmVkaXJlY3RDaGFpbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mYWlsdXJlVGV4dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZnJvbU1lbW9yeUNhY2hlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ludGVyY2VwdGlvbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IGV2ZW50LnJlcXVlc3RJZDtcbiAgICAgICAgdGhpcy5faXNOYXZpZ2F0aW9uUmVxdWVzdCA9XG4gICAgICAgICAgICBldmVudC5yZXF1ZXN0SWQgPT09IGV2ZW50LmxvYWRlcklkICYmIGV2ZW50LnR5cGUgPT09ICdEb2N1bWVudCc7XG4gICAgICAgIHRoaXMuX2ludGVyY2VwdGlvbklkID0gaW50ZXJjZXB0aW9uSWQ7XG4gICAgICAgIHRoaXMuX2FsbG93SW50ZXJjZXB0aW9uID0gYWxsb3dJbnRlcmNlcHRpb247XG4gICAgICAgIHRoaXMuX3VybCA9IGV2ZW50LnJlcXVlc3QudXJsO1xuICAgICAgICB0aGlzLl9yZXNvdXJjZVR5cGUgPSBldmVudC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX21ldGhvZCA9IGV2ZW50LnJlcXVlc3QubWV0aG9kO1xuICAgICAgICB0aGlzLl9wb3N0RGF0YSA9IGV2ZW50LnJlcXVlc3QucG9zdERhdGE7XG4gICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMuX3JlZGlyZWN0Q2hhaW4gPSByZWRpcmVjdENoYWluO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhldmVudC5yZXF1ZXN0LmhlYWRlcnMpKVxuICAgICAgICAgICAgdGhpcy5faGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBldmVudC5yZXF1ZXN0LmhlYWRlcnNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIFVSTCBvZiB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdGhlIHJlcXVlc3QncyByZXNvdXJjZSB0eXBlIGFzIGl0IHdhcyBwZXJjZWl2ZWQgYnkgdGhlIHJlbmRlcmluZ1xuICAgICAqIGVuZ2luZS5cbiAgICAgKi9cbiAgICByZXNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBtZXRob2QgdXNlZCAoYEdFVGAsIGBQT1NUYCwgZXRjLilcbiAgICAgKi9cbiAgICBtZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0J3MgcG9zdCBib2R5LCBpZiBhbnkuXG4gICAgICovXG4gICAgcG9zdERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3N0RGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggSFRUUCBoZWFkZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdC4gQWxsXG4gICAgICogaGVhZGVyIG5hbWVzIGFyZSBsb3dlci1jYXNlLlxuICAgICAqL1xuICAgIGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBIG1hdGNoaW5nIGBIVFRQUmVzcG9uc2VgIG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgcmVzcG9uc2UgaGFzIG5vdFxuICAgICAqIGJlZW4gcmVjZWl2ZWQgeWV0LlxuICAgICAqL1xuICAgIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBmcmFtZSB0aGF0IGluaXRpYXRlZCB0aGUgcmVxdWVzdCwgb3IgbnVsbCBpZiBuYXZpZ2F0aW5nIHRvXG4gICAgICogZXJyb3IgcGFnZXMuXG4gICAgICovXG4gICAgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBpcyB0aGUgZHJpdmVyIG9mIHRoZSBjdXJyZW50IGZyYW1lJ3MgbmF2aWdhdGlvbi5cbiAgICAgKi9cbiAgICBpc05hdmlnYXRpb25SZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNOYXZpZ2F0aW9uUmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBgcmVkaXJlY3RDaGFpbmAgaXMgYSBjaGFpbiBvZiByZXF1ZXN0cyBpbml0aWF0ZWQgdG8gZmV0Y2ggYSByZXNvdXJjZS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogYHJlZGlyZWN0Q2hhaW5gIGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGUgcmVxdWVzdHMgb2YgdGhlIHNhbWUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHdlYnNpdGUgYGh0dHA6Ly9leGFtcGxlLmNvbWAgaGFzIGEgc2luZ2xlIHJlZGlyZWN0IHRvXG4gICAgICogYGh0dHBzOi8vZXhhbXBsZS5jb21gLCB0aGVuIHRoZSBjaGFpbiB3aWxsIGNvbnRhaW4gb25lIHJlcXVlc3Q6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcGFnZS5nb3RvKCdodHRwOi8vZXhhbXBsZS5jb20nKTtcbiAgICAgKiBjb25zdCBjaGFpbiA9IHJlc3BvbnNlLnJlcXVlc3QoKS5yZWRpcmVjdENoYWluKCk7XG4gICAgICogY29uc29sZS5sb2coY2hhaW4ubGVuZ3RoKTsgLy8gMVxuICAgICAqIGNvbnNvbGUubG9nKGNoYWluWzBdLnVybCgpKTsgLy8gJ2h0dHA6Ly9leGFtcGxlLmNvbSdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHRoZSB3ZWJzaXRlIGBodHRwczovL2dvb2dsZS5jb21gIGhhcyBubyByZWRpcmVjdHMsIHRoZW4gdGhlIGNoYWluIHdpbGwgYmUgZW1wdHk6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcGFnZS5nb3RvKCdodHRwczovL2dvb2dsZS5jb20nKTtcbiAgICAgKiBjb25zdCBjaGFpbiA9IHJlc3BvbnNlLnJlcXVlc3QoKS5yZWRpcmVjdENoYWluKCk7XG4gICAgICogY29uc29sZS5sb2coY2hhaW4ubGVuZ3RoKTsgLy8gMFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGNoYWluIG9mIHJlcXVlc3RzIC0gaWYgYSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCBhdCBsZWFzdCBhXG4gICAgICogc2luZ2xlIHJlZGlyZWN0LCB0aGlzIGNoYWluIHdpbGwgY29udGFpbiBhbGwgcmVxdWVzdHMgdGhhdCB3ZXJlIHJlZGlyZWN0ZWQuXG4gICAgICovXG4gICAgcmVkaXJlY3RDaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZGlyZWN0Q2hhaW4uc2xpY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0J3MgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBsb2dnaW5nIGFsbCBmYWlsZWQgcmVxdWVzdHM6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHBhZ2Uub24oJ3JlcXVlc3RmYWlsZWQnLCByZXF1ZXN0ID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlcXVlc3QudXJsKCkgKyAnICcgKyByZXF1ZXN0LmZhaWx1cmUoKS5lcnJvclRleHQpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgYG51bGxgIHVubGVzcyB0aGUgcmVxdWVzdCBmYWlsZWQuIElmIHRoZSByZXF1ZXN0IGZhaWxzIHRoaXMgY2FuXG4gICAgICogcmV0dXJuIGFuIG9iamVjdCB3aXRoIGBlcnJvclRleHRgIGNvbnRhaW5pbmcgYSBodW1hbi1yZWFkYWJsZSBlcnJvclxuICAgICAqIG1lc3NhZ2UsIGUuZy4gYG5ldDo6RVJSX0ZBSUxFRGAuIEl0IGlzIG5vdCBndWFyYW50ZWVkZWQgdGhhdCB0aGVyZSB3aWxsIGJlXG4gICAgICogZmFpbHVyZSB0ZXh0IGlmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGZhaWx1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmFpbHVyZVRleHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yVGV4dDogdGhpcy5fZmFpbHVyZVRleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRpbnVlcyByZXF1ZXN0IHdpdGggb3B0aW9uYWwgcmVxdWVzdCBvdmVycmlkZXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMsIHJlcXVlc3RcbiAgICAgKiBpbnRlcmNlcHRpb24gc2hvdWxkIGJlIGVuYWJsZWQgd2l0aCB7QGxpbmsgUGFnZS5zZXRSZXF1ZXN0SW50ZXJjZXB0aW9ufS5cbiAgICAgKlxuICAgICAqIEV4Y2VwdGlvbiBpcyBpbW1lZGlhdGVseSB0aHJvd24gaWYgdGhlIHJlcXVlc3QgaW50ZXJjZXB0aW9uIGlzIG5vdCBlbmFibGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IHBhZ2Uuc2V0UmVxdWVzdEludGVyY2VwdGlvbih0cnVlKTtcbiAgICAgKiBwYWdlLm9uKCdyZXF1ZXN0JywgcmVxdWVzdCA9PiB7XG4gICAgICogICAvLyBPdmVycmlkZSBoZWFkZXJzXG4gICAgICogICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdC5oZWFkZXJzKCksIHtcbiAgICAgKiAgICAgZm9vOiAnYmFyJywgLy8gc2V0IFwiZm9vXCIgaGVhZGVyXG4gICAgICogICAgIG9yaWdpbjogdW5kZWZpbmVkLCAvLyByZW1vdmUgXCJvcmlnaW5cIiBoZWFkZXJcbiAgICAgKiAgIH0pO1xuICAgICAqICAgcmVxdWVzdC5jb250aW51ZSh7aGVhZGVyc30pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG92ZXJyaWRlcyAtIG9wdGlvbmFsIG92ZXJyaWRlcyB0byBhcHBseSB0byB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBjb250aW51ZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICAvLyBSZXF1ZXN0IGludGVyY2VwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBkYXRhOiB1cmxzLlxuICAgICAgICBpZiAodGhpcy5fdXJsLnN0YXJ0c1dpdGgoJ2RhdGE6JykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFzc2VydCh0aGlzLl9hbGxvd0ludGVyY2VwdGlvbiwgJ1JlcXVlc3QgSW50ZXJjZXB0aW9uIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2ludGVyY2VwdGlvbkhhbmRsZWQsICdSZXF1ZXN0IGlzIGFscmVhZHkgaGFuZGxlZCEnKTtcbiAgICAgICAgY29uc3QgeyB1cmwsIG1ldGhvZCwgcG9zdERhdGEsIGhlYWRlcnMgfSA9IG92ZXJyaWRlcztcbiAgICAgICAgdGhpcy5faW50ZXJjZXB0aW9uSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHBvc3REYXRhQmluYXJ5QmFzZTY0ID0gcG9zdERhdGFcbiAgICAgICAgICAgID8gQnVmZmVyLmZyb20ocG9zdERhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgLnNlbmQoJ0ZldGNoLmNvbnRpbnVlUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy5faW50ZXJjZXB0aW9uSWQsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBwb3N0RGF0YTogcG9zdERhdGFCaW5hcnlCYXNlNjQsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzID8gaGVhZGVyc0FycmF5KGhlYWRlcnMpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSW4gY2VydGFpbiBjYXNlcywgcHJvdG9jb2wgd2lsbCByZXR1cm4gZXJyb3IgaWYgdGhlIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGNhbmNlbGVkIG9yIHRoZSBwYWdlIHdhcyBjbG9zZWQuIFdlIHNob3VsZCB0b2xlcmF0ZSB0aGVzZVxuICAgICAgICAgICAgLy8gZXJyb3JzLlxuICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdWxmaWxscyBhIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMsIHJlcXVlc3RcbiAgICAgKiBpbnRlcmNlcHRpb24gc2hvdWxkIGJlIGVuYWJsZWQgd2l0aCB7QGxpbmsgUGFnZS5zZXRSZXF1ZXN0SW50ZXJjZXB0aW9ufS5cbiAgICAgKlxuICAgICAqIEV4Y2VwdGlvbiBpcyBpbW1lZGlhdGVseSB0aHJvd24gaWYgdGhlIHJlcXVlc3QgaW50ZXJjZXB0aW9uIGlzIG5vdCBlbmFibGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBBbiBleGFtcGxlIG9mIGZ1bGZpbGxpbmcgYWxsIHJlcXVlc3RzIHdpdGggNDA0IHJlc3BvbnNlczpcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IHBhZ2Uuc2V0UmVxdWVzdEludGVyY2VwdGlvbih0cnVlKTtcbiAgICAgKiBwYWdlLm9uKCdyZXF1ZXN0JywgcmVxdWVzdCA9PiB7XG4gICAgICogICByZXF1ZXN0LnJlc3BvbmQoe1xuICAgICAqICAgICBzdGF0dXM6IDQwNCxcbiAgICAgKiAgICAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiAgICAgYm9keTogJ05vdCBGb3VuZCEnXG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5PVEU6IE1vY2tpbmcgcmVzcG9uc2VzIGZvciBkYXRhVVJMIHJlcXVlc3RzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogQ2FsbGluZyBgcmVxdWVzdC5yZXNwb25kYCBmb3IgYSBkYXRhVVJMIHJlcXVlc3QgaXMgYSBub29wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIC0gdGhlIHJlc3BvbnNlIHRvIGZ1bGZpbGwgdGhlIHJlcXVlc3Qgd2l0aC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNwb25kKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIE1vY2tpbmcgcmVzcG9uc2VzIGZvciBkYXRhVVJMIHJlcXVlc3RzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAgICBpZiAodGhpcy5fdXJsLnN0YXJ0c1dpdGgoJ2RhdGE6JykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFzc2VydCh0aGlzLl9hbGxvd0ludGVyY2VwdGlvbiwgJ1JlcXVlc3QgSW50ZXJjZXB0aW9uIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2ludGVyY2VwdGlvbkhhbmRsZWQsICdSZXF1ZXN0IGlzIGFscmVhZHkgaGFuZGxlZCEnKTtcbiAgICAgICAgdGhpcy5faW50ZXJjZXB0aW9uSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHJlc3BvbnNlLmJvZHkgJiYgaGVscGVyLmlzU3RyaW5nKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICA/IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICA6IHJlc3BvbnNlLmJvZHkgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0ge307XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhyZXNwb25zZS5oZWFkZXJzKSlcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLmNvbnRlbnRUeXBlKVxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHJlc3BvbnNlLmNvbnRlbnRUeXBlO1xuICAgICAgICBpZiAocmVzcG9uc2VCb2R5ICYmICEoJ2NvbnRlbnQtbGVuZ3RoJyBpbiByZXNwb25zZUhlYWRlcnMpKVxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gU3RyaW5nKEJ1ZmZlci5ieXRlTGVuZ3RoKHJlc3BvbnNlQm9keSkpO1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnRcbiAgICAgICAgICAgIC5zZW5kKCdGZXRjaC5mdWxmaWxsUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy5faW50ZXJjZXB0aW9uSWQsXG4gICAgICAgICAgICByZXNwb25zZUNvZGU6IHJlc3BvbnNlLnN0YXR1cyB8fCAyMDAsXG4gICAgICAgICAgICByZXNwb25zZVBocmFzZTogU1RBVFVTX1RFWFRTW3Jlc3BvbnNlLnN0YXR1cyB8fCAyMDBdLFxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiBoZWFkZXJzQXJyYXkocmVzcG9uc2VIZWFkZXJzKSxcbiAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQm9keSA/IHJlc3BvbnNlQm9keS50b1N0cmluZygnYmFzZTY0JykgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBJbiBjZXJ0YWluIGNhc2VzLCBwcm90b2NvbCB3aWxsIHJldHVybiBlcnJvciBpZiB0aGUgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgIC8vIGFscmVhZHkgY2FuY2VsZWQgb3IgdGhlIHBhZ2Ugd2FzIGNsb3NlZC4gV2Ugc2hvdWxkIHRvbGVyYXRlIHRoZXNlXG4gICAgICAgICAgICAvLyBlcnJvcnMuXG4gICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0cyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRvIHVzZSB0aGlzLCByZXF1ZXN0IGludGVyY2VwdGlvbiBzaG91bGQgYmUgZW5hYmxlZCB3aXRoXG4gICAgICoge0BsaW5rIFBhZ2Uuc2V0UmVxdWVzdEludGVyY2VwdGlvbn0uIElmIGl0IGlzIG5vdCBlbmFibGVkLCB0aGlzIG1ldGhvZCB3aWxsXG4gICAgICogdGhyb3cgYW4gZXhjZXB0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yQ29kZSAtIG9wdGlvbmFsIGVycm9yIGNvZGUgdG8gcHJvdmlkZS5cbiAgICAgKi9cbiAgICBhc3luYyBhYm9ydChlcnJvckNvZGUgPSAnZmFpbGVkJykge1xuICAgICAgICAvLyBSZXF1ZXN0IGludGVyY2VwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBkYXRhOiB1cmxzLlxuICAgICAgICBpZiAodGhpcy5fdXJsLnN0YXJ0c1dpdGgoJ2RhdGE6JykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gZXJyb3JSZWFzb25zW2Vycm9yQ29kZV07XG4gICAgICAgIGFzc2VydChlcnJvclJlYXNvbiwgJ1Vua25vd24gZXJyb3IgY29kZTogJyArIGVycm9yQ29kZSk7XG4gICAgICAgIGFzc2VydCh0aGlzLl9hbGxvd0ludGVyY2VwdGlvbiwgJ1JlcXVlc3QgSW50ZXJjZXB0aW9uIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICBhc3NlcnQoIXRoaXMuX2ludGVyY2VwdGlvbkhhbmRsZWQsICdSZXF1ZXN0IGlzIGFscmVhZHkgaGFuZGxlZCEnKTtcbiAgICAgICAgdGhpcy5faW50ZXJjZXB0aW9uSGFuZGxlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgLnNlbmQoJ0ZldGNoLmZhaWxSZXF1ZXN0Jywge1xuICAgICAgICAgICAgcmVxdWVzdElkOiB0aGlzLl9pbnRlcmNlcHRpb25JZCxcbiAgICAgICAgICAgIGVycm9yUmVhc29uLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSW4gY2VydGFpbiBjYXNlcywgcHJvdG9jb2wgd2lsbCByZXR1cm4gZXJyb3IgaWYgdGhlIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGNhbmNlbGVkIG9yIHRoZSBwYWdlIHdhcyBjbG9zZWQuIFdlIHNob3VsZCB0b2xlcmF0ZSB0aGVzZVxuICAgICAgICAgICAgLy8gZXJyb3JzLlxuICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGVycm9yUmVhc29ucyA9IHtcbiAgICBhYm9ydGVkOiAnQWJvcnRlZCcsXG4gICAgYWNjZXNzZGVuaWVkOiAnQWNjZXNzRGVuaWVkJyxcbiAgICBhZGRyZXNzdW5yZWFjaGFibGU6ICdBZGRyZXNzVW5yZWFjaGFibGUnLFxuICAgIGJsb2NrZWRieWNsaWVudDogJ0Jsb2NrZWRCeUNsaWVudCcsXG4gICAgYmxvY2tlZGJ5cmVzcG9uc2U6ICdCbG9ja2VkQnlSZXNwb25zZScsXG4gICAgY29ubmVjdGlvbmFib3J0ZWQ6ICdDb25uZWN0aW9uQWJvcnRlZCcsXG4gICAgY29ubmVjdGlvbmNsb3NlZDogJ0Nvbm5lY3Rpb25DbG9zZWQnLFxuICAgIGNvbm5lY3Rpb25mYWlsZWQ6ICdDb25uZWN0aW9uRmFpbGVkJyxcbiAgICBjb25uZWN0aW9ucmVmdXNlZDogJ0Nvbm5lY3Rpb25SZWZ1c2VkJyxcbiAgICBjb25uZWN0aW9ucmVzZXQ6ICdDb25uZWN0aW9uUmVzZXQnLFxuICAgIGludGVybmV0ZGlzY29ubmVjdGVkOiAnSW50ZXJuZXREaXNjb25uZWN0ZWQnLFxuICAgIG5hbWVub3RyZXNvbHZlZDogJ05hbWVOb3RSZXNvbHZlZCcsXG4gICAgdGltZWRvdXQ6ICdUaW1lZE91dCcsXG4gICAgZmFpbGVkOiAnRmFpbGVkJyxcbn07XG5mdW5jdGlvbiBoZWFkZXJzQXJyYXkoaGVhZGVycykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKGhlYWRlcnNbbmFtZV0sIHVuZGVmaW5lZCkpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWUsIHZhbHVlOiBoZWFkZXJzW25hbWVdICsgJycgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBMaXN0IHRha2VuIGZyb21cbi8vIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2h0dHAtc3RhdHVzLWNvZGVzL2h0dHAtc3RhdHVzLWNvZGVzLnhodG1sXG4vLyB3aXRoIGV4dHJhIDMwNiBhbmQgNDE4IGNvZGVzLlxuY29uc3QgU1RBVFVTX1RFWFRTID0ge1xuICAgICcxMDAnOiAnQ29udGludWUnLFxuICAgICcxMDEnOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgJzEwMic6ICdQcm9jZXNzaW5nJyxcbiAgICAnMTAzJzogJ0Vhcmx5IEhpbnRzJyxcbiAgICAnMjAwJzogJ09LJyxcbiAgICAnMjAxJzogJ0NyZWF0ZWQnLFxuICAgICcyMDInOiAnQWNjZXB0ZWQnLFxuICAgICcyMDMnOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgICcyMDQnOiAnTm8gQ29udGVudCcsXG4gICAgJzIwNSc6ICdSZXNldCBDb250ZW50JyxcbiAgICAnMjA2JzogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgJzIwNyc6ICdNdWx0aS1TdGF0dXMnLFxuICAgICcyMDgnOiAnQWxyZWFkeSBSZXBvcnRlZCcsXG4gICAgJzIyNic6ICdJTSBVc2VkJyxcbiAgICAnMzAwJzogJ011bHRpcGxlIENob2ljZXMnLFxuICAgICczMDEnOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAgICczMDInOiAnRm91bmQnLFxuICAgICczMDMnOiAnU2VlIE90aGVyJyxcbiAgICAnMzA0JzogJ05vdCBNb2RpZmllZCcsXG4gICAgJzMwNSc6ICdVc2UgUHJveHknLFxuICAgICczMDYnOiAnU3dpdGNoIFByb3h5JyxcbiAgICAnMzA3JzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG4gICAgJzMwOCc6ICdQZXJtYW5lbnQgUmVkaXJlY3QnLFxuICAgICc0MDAnOiAnQmFkIFJlcXVlc3QnLFxuICAgICc0MDEnOiAnVW5hdXRob3JpemVkJyxcbiAgICAnNDAyJzogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgICc0MDMnOiAnRm9yYmlkZGVuJyxcbiAgICAnNDA0JzogJ05vdCBGb3VuZCcsXG4gICAgJzQwNSc6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgICc0MDYnOiAnTm90IEFjY2VwdGFibGUnLFxuICAgICc0MDcnOiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxuICAgICc0MDgnOiAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICAnNDA5JzogJ0NvbmZsaWN0JyxcbiAgICAnNDEwJzogJ0dvbmUnLFxuICAgICc0MTEnOiAnTGVuZ3RoIFJlcXVpcmVkJyxcbiAgICAnNDEyJzogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgICc0MTMnOiAnUGF5bG9hZCBUb28gTGFyZ2UnLFxuICAgICc0MTQnOiAnVVJJIFRvbyBMb25nJyxcbiAgICAnNDE1JzogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLFxuICAgICc0MTYnOiAnUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcbiAgICAnNDE3JzogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgJzQxOCc6IFwiSSdtIGEgdGVhcG90XCIsXG4gICAgJzQyMSc6ICdNaXNkaXJlY3RlZCBSZXF1ZXN0JyxcbiAgICAnNDIyJzogJ1VucHJvY2Vzc2FibGUgRW50aXR5JyxcbiAgICAnNDIzJzogJ0xvY2tlZCcsXG4gICAgJzQyNCc6ICdGYWlsZWQgRGVwZW5kZW5jeScsXG4gICAgJzQyNSc6ICdUb28gRWFybHknLFxuICAgICc0MjYnOiAnVXBncmFkZSBSZXF1aXJlZCcsXG4gICAgJzQyOCc6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLFxuICAgICc0MjknOiAnVG9vIE1hbnkgUmVxdWVzdHMnLFxuICAgICc0MzEnOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsXG4gICAgJzQ1MSc6ICdVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29ucycsXG4gICAgJzUwMCc6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgICc1MDEnOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICAnNTAyJzogJ0JhZCBHYXRld2F5JyxcbiAgICAnNTAzJzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgICc1MDQnOiAnR2F0ZXdheSBUaW1lb3V0JyxcbiAgICAnNTA1JzogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICAnNTA2JzogJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJyxcbiAgICAnNTA3JzogJ0luc3VmZmljaWVudCBTdG9yYWdlJyxcbiAgICAnNTA4JzogJ0xvb3AgRGV0ZWN0ZWQnLFxuICAgICc1MTAnOiAnTm90IEV4dGVuZGVkJyxcbiAgICAnNTExJzogJ05ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBSZXF1ZXN0LmpzLm1hcCIsImltcG9ydCB7IFNlY3VyaXR5RGV0YWlscyB9IGZyb20gJy4vU2VjdXJpdHlEZXRhaWxzLmpzJztcbi8qKlxuICogVGhlIEhUVFBSZXNwb25zZSBjbGFzcyByZXByZXNlbnRzIHJlc3BvbnNlcyB3aGljaCBhcmUgcmVjZWl2ZWQgYnkgdGhlXG4gKiB7QGxpbmsgUGFnZX0gY2xhc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgSFRUUFJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHJlcXVlc3QsIHJlc3BvbnNlUGF5bG9hZCkge1xuICAgICAgICB0aGlzLl9jb250ZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5fYm9keUxvYWRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYm9keUxvYWRlZFByb21pc2VGdWxmaWxsID0gZnVsZmlsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlbW90ZUFkZHJlc3MgPSB7XG4gICAgICAgICAgICBpcDogcmVzcG9uc2VQYXlsb2FkLnJlbW90ZUlQQWRkcmVzcyxcbiAgICAgICAgICAgIHBvcnQ6IHJlc3BvbnNlUGF5bG9hZC5yZW1vdGVQb3J0LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSByZXNwb25zZVBheWxvYWQuc3RhdHVzO1xuICAgICAgICB0aGlzLl9zdGF0dXNUZXh0ID0gcmVzcG9uc2VQYXlsb2FkLnN0YXR1c1RleHQ7XG4gICAgICAgIHRoaXMuX3VybCA9IHJlcXVlc3QudXJsKCk7XG4gICAgICAgIHRoaXMuX2Zyb21EaXNrQ2FjaGUgPSAhIXJlc3BvbnNlUGF5bG9hZC5mcm9tRGlza0NhY2hlO1xuICAgICAgICB0aGlzLl9mcm9tU2VydmljZVdvcmtlciA9ICEhcmVzcG9uc2VQYXlsb2FkLmZyb21TZXJ2aWNlV29ya2VyO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXNwb25zZVBheWxvYWQuaGVhZGVycykpXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHJlc3BvbnNlUGF5bG9hZC5oZWFkZXJzW2tleV07XG4gICAgICAgIHRoaXMuX3NlY3VyaXR5RGV0YWlscyA9IHJlc3BvbnNlUGF5bG9hZC5zZWN1cml0eURldGFpbHNcbiAgICAgICAgICAgID8gbmV3IFNlY3VyaXR5RGV0YWlscyhyZXNwb25zZVBheWxvYWQuc2VjdXJpdHlEZXRhaWxzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVzb2x2ZUJvZHkoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib2R5TG9hZGVkUHJvbWlzZUZ1bGZpbGwoZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIElQIGFkZHJlc3MgYW5kIHBvcnQgbnVtYmVyIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgcmVtb3RlXG4gICAgICogc2VydmVyLlxuICAgICAqL1xuICAgIHJlbW90ZUFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIG9mIHRoZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsIChzdGF0dXMgaW4gdGhlIHJhbmdlIDIwMC0yOTkpLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICAvLyBUT0RPOiBkb2N1bWVudCA9PT0gMCBjYXNlP1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSAwIHx8ICh0aGlzLl9zdGF0dXMgPj0gMjAwICYmIHRoaXMuX3N0YXR1cyA8PSAyOTkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCAyMDAgZm9yIGEgc3VjY2VzcykuXG4gICAgICovXG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyAgVGhlIHN0YXR1cyB0ZXh0IG9mIHRoZSByZXNwb25zZSAoZS5nLiB1c3VhbGx5IGFuIFwiT0tcIiBmb3IgYVxuICAgICAqIHN1Y2Nlc3MpLlxuICAgICAqL1xuICAgIHN0YXR1c1RleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXNUZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBIVFRQIGhlYWRlcnMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXNwb25zZS4gQWxsXG4gICAgICogaGVhZGVyIG5hbWVzIGFyZSBsb3dlci1jYXNlLlxuICAgICAqL1xuICAgIGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QGxpbmsgU2VjdXJpdHlEZXRhaWxzfSBpZiB0aGUgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIG92ZXIgdGhlXG4gICAgICogc2VjdXJlIGNvbm5lY3Rpb24sIG9yIGBudWxsYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc2VjdXJpdHlEZXRhaWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VjdXJpdHlEZXRhaWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGEgYnVmZmVyIHdpdGggcmVzcG9uc2UgYm9keS5cbiAgICAgKi9cbiAgICBidWZmZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGVudFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRQcm9taXNlID0gdGhpcy5fYm9keUxvYWRlZFByb21pc2UudGhlbihhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ05ldHdvcmsuZ2V0UmVzcG9uc2VCb2R5Jywge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuX3JlcXVlc3QuX3JlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UuYmFzZTY0RW5jb2RlZCA/ICdiYXNlNjQnIDogJ3V0ZjgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50UHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBhIHRleHQgcmVwcmVzZW50YXRpb24gb2YgcmVzcG9uc2UgYm9keS5cbiAgICAgKi9cbiAgICBhc3luYyB0ZXh0KCkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5idWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiByZXNwb25zZSBib2R5LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbm90IHBhcnNhYmxlIHZpYVxuICAgICAqIGBKU09OLnBhcnNlYC5cbiAgICAgKi9cbiAgICBhc3luYyBqc29uKCkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy50ZXh0KCk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBBIG1hdGNoaW5nIHtAbGluayBIVFRQUmVxdWVzdH0gb2JqZWN0LlxuICAgICAqL1xuICAgIHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZXNwb25zZSB3YXMgc2VydmVkIGZyb20gZWl0aGVyIHRoZSBicm93c2VyJ3MgZGlza1xuICAgICAqIGNhY2hlIG9yIG1lbW9yeSBjYWNoZS5cbiAgICAgKi9cbiAgICBmcm9tQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcm9tRGlza0NhY2hlIHx8IHRoaXMuX3JlcXVlc3QuX2Zyb21NZW1vcnlDYWNoZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcmVzcG9uc2Ugd2FzIHNlcnZlZCBieSBhIHNlcnZpY2Ugd29ya2VyLlxuICAgICAqL1xuICAgIGZyb21TZXJ2aWNlV29ya2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJvbVNlcnZpY2VXb3JrZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIEZyYW1lfSB0aGF0IGluaXRpYXRlZCB0aGlzIHJlc3BvbnNlLCBvciBgbnVsbGAgaWZcbiAgICAgKiBuYXZpZ2F0aW5nIHRvIGVycm9yIHBhZ2VzLlxuICAgICAqL1xuICAgIGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdC5mcmFtZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBSZXNwb25zZS5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbmltcG9ydCB7IGtleURlZmluaXRpb25zIH0gZnJvbSAnLi9VU0tleWJvYXJkTGF5b3V0LmpzJztcbi8qKlxuICogS2V5Ym9hcmQgcHJvdmlkZXMgYW4gYXBpIGZvciBtYW5hZ2luZyBhIHZpcnR1YWwga2V5Ym9hcmQuXG4gKiBUaGUgaGlnaCBsZXZlbCBhcGkgaXMge0BsaW5rIEtleWJvYXJkLlwidHlwZVwifSxcbiAqIHdoaWNoIHRha2VzIHJhdyBjaGFyYWN0ZXJzIGFuZCBnZW5lcmF0ZXMgcHJvcGVyIGtleWRvd24sIGtleXByZXNzL2lucHV0LFxuICogYW5kIGtleXVwIGV2ZW50cyBvbiB5b3VyIHBhZ2UuXG4gKlxuICogQHJlbWFya3NcbiAqIEZvciBmaW5lciBjb250cm9sLCB5b3UgY2FuIHVzZSB7QGxpbmsgS2V5Ym9hcmQuZG93bn0sXG4gKiB7QGxpbmsgS2V5Ym9hcmQudXB9LCBhbmQge0BsaW5rIEtleWJvYXJkLnNlbmRDaGFyYWN0ZXJ9XG4gKiB0byBtYW51YWxseSBmaXJlIGV2ZW50cyBhcyBpZiB0aGV5IHdlcmUgZ2VuZXJhdGVkIGZyb20gYSByZWFsIGtleWJvYXJkLlxuICpcbiAqIE9uIE1hY09TLCBrZXlib2FyZCBzaG9ydGN1dHMgbGlrZSBg4oyYIEFgIC1cXD4gU2VsZWN0IEFsbCBkbyBub3Qgd29yay5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1cHBldGVlci9wdXBwZXRlZXIvaXNzdWVzLzEzMTMgfCAjMTMxM30uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIGV4YW1wbGUgb2YgaG9sZGluZyBkb3duIGBTaGlmdGAgaW4gb3JkZXIgdG8gc2VsZWN0IGFuZCBkZWxldGUgc29tZSB0ZXh0OlxuICogYGBganNcbiAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQudHlwZSgnSGVsbG8gV29ybGQhJyk7XG4gKiBhd2FpdCBwYWdlLmtleWJvYXJkLnByZXNzKCdBcnJvd0xlZnQnKTtcbiAqXG4gKiBhd2FpdCBwYWdlLmtleWJvYXJkLmRvd24oJ1NoaWZ0Jyk7XG4gKiBmb3IgKGxldCBpID0gMDsgaSA8ICcgV29ybGQnLmxlbmd0aDsgaSsrKVxuICogICBhd2FpdCBwYWdlLmtleWJvYXJkLnByZXNzKCdBcnJvd0xlZnQnKTtcbiAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQudXAoJ1NoaWZ0Jyk7XG4gKlxuICogYXdhaXQgcGFnZS5rZXlib2FyZC5wcmVzcygnQmFja3NwYWNlJyk7XG4gKiAvLyBSZXN1bHQgdGV4dCB3aWxsIGVuZCB1cCBzYXlpbmcgJ0hlbGxvISdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBleGFtcGxlIG9mIHByZXNzaW5nIGBBYFxuICogYGBganNcbiAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQuZG93bignU2hpZnQnKTtcbiAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQucHJlc3MoJ0tleUEnKTtcbiAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQudXAoJ1NoaWZ0Jyk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXlib2FyZCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX21vZGlmaWVycyA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXNzZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBga2V5ZG93bmAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIGBrZXlgIGlzIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgbm8gbW9kaWZpZXIga2V5cyBiZXNpZGVzIGBTaGlmdGBcbiAgICAgKiBhcmUgYmVpbmcgaGVsZCBkb3duLCBhIGBrZXlwcmVzc2AvYGlucHV0YCBldmVudCB3aWxsIGFsc28gZ2VuZXJhdGVkLlxuICAgICAqIFRoZSBgdGV4dGAgb3B0aW9uIGNhbiBiZSBzcGVjaWZpZWQgdG8gZm9yY2UgYW4gaW5wdXQgZXZlbnQgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIElmIGBrZXlgIGlzIGEgbW9kaWZpZXIga2V5LCBgU2hpZnRgLCBgTWV0YWAsIGBDb250cm9sYCwgb3IgYEFsdGAsXG4gICAgICogc3Vic2VxdWVudCBrZXkgcHJlc3NlcyB3aWxsIGJlIHNlbnQgd2l0aCB0aGF0IG1vZGlmaWVyIGFjdGl2ZS5cbiAgICAgKiBUbyByZWxlYXNlIHRoZSBtb2RpZmllciBrZXksIHVzZSB7QGxpbmsgS2V5Ym9hcmQudXB9LlxuICAgICAqXG4gICAgICogQWZ0ZXIgdGhlIGtleSBpcyBwcmVzc2VkIG9uY2UsIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgICAgKiB7QGxpbmsgS2V5Ym9hcmQuZG93bn0gd2lsbCBoYXZlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L3JlcGVhdCB8IHJlcGVhdH1cbiAgICAgKiBzZXQgdG8gdHJ1ZS4gVG8gcmVsZWFzZSB0aGUga2V5LCB1c2Uge0BsaW5rIEtleWJvYXJkLnVwfS5cbiAgICAgKlxuICAgICAqIE1vZGlmaWVyIGtleXMgRE8gaW5mbHVlbmNlIHtAbGluayBLZXlib2FyZC5kb3dufS5cbiAgICAgKiBIb2xkaW5nIGRvd24gYFNoaWZ0YCB3aWxsIHR5cGUgdGhlIHRleHQgaW4gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBOYW1lIG9mIGtleSB0byBwcmVzcywgc3VjaCBhcyBgQXJyb3dMZWZ0YC5cbiAgICAgKiBTZWUge0BsaW5rIEtleUlucHV0fSBmb3IgYSBsaXN0IG9mIGFsbCBrZXkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBvZiBvcHRpb25zLiBBY2NlcHRzIHRleHQgd2hpY2gsIGlmIHNwZWNpZmllZCxcbiAgICAgKiBnZW5lcmF0ZXMgYW4gaW5wdXQgZXZlbnQgd2l0aCB0aGlzIHRleHQuXG4gICAgICovXG4gICAgYXN5bmMgZG93bihrZXksIG9wdGlvbnMgPSB7IHRleHQ6IHVuZGVmaW5lZCB9KSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5fa2V5RGVzY3JpcHRpb25Gb3JTdHJpbmcoa2V5KTtcbiAgICAgICAgY29uc3QgYXV0b1JlcGVhdCA9IHRoaXMuX3ByZXNzZWRLZXlzLmhhcyhkZXNjcmlwdGlvbi5jb2RlKTtcbiAgICAgICAgdGhpcy5fcHJlc3NlZEtleXMuYWRkKGRlc2NyaXB0aW9uLmNvZGUpO1xuICAgICAgICB0aGlzLl9tb2RpZmllcnMgfD0gdGhpcy5fbW9kaWZpZXJCaXQoZGVzY3JpcHRpb24ua2V5KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IG9wdGlvbnMudGV4dCA9PT0gdW5kZWZpbmVkID8gZGVzY3JpcHRpb24udGV4dCA6IG9wdGlvbnMudGV4dDtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0lucHV0LmRpc3BhdGNoS2V5RXZlbnQnLCB7XG4gICAgICAgICAgICB0eXBlOiB0ZXh0ID8gJ2tleURvd24nIDogJ3Jhd0tleURvd24nLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB0aGlzLl9tb2RpZmllcnMsXG4gICAgICAgICAgICB3aW5kb3dzVmlydHVhbEtleUNvZGU6IGRlc2NyaXB0aW9uLmtleUNvZGUsXG4gICAgICAgICAgICBjb2RlOiBkZXNjcmlwdGlvbi5jb2RlLFxuICAgICAgICAgICAga2V5OiBkZXNjcmlwdGlvbi5rZXksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgdW5tb2RpZmllZFRleHQ6IHRleHQsXG4gICAgICAgICAgICBhdXRvUmVwZWF0LFxuICAgICAgICAgICAgbG9jYXRpb246IGRlc2NyaXB0aW9uLmxvY2F0aW9uLFxuICAgICAgICAgICAgaXNLZXlwYWQ6IGRlc2NyaXB0aW9uLmxvY2F0aW9uID09PSAzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX21vZGlmaWVyQml0KGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnQWx0JylcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoa2V5ID09PSAnQ29udHJvbCcpXG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgaWYgKGtleSA9PT0gJ01ldGEnKVxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGlmIChrZXkgPT09ICdTaGlmdCcpXG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9rZXlEZXNjcmlwdGlvbkZvclN0cmluZyhrZXlTdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSB0aGlzLl9tb2RpZmllcnMgJiA4O1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGtleTogJycsXG4gICAgICAgICAgICBrZXlDb2RlOiAwLFxuICAgICAgICAgICAgY29kZTogJycsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ga2V5RGVmaW5pdGlvbnNba2V5U3RyaW5nXTtcbiAgICAgICAgYXNzZXJ0KGRlZmluaXRpb24sIGBVbmtub3duIGtleTogXCIke2tleVN0cmluZ31cImApO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5rZXkpXG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5rZXkgPSBkZWZpbml0aW9uLmtleTtcbiAgICAgICAgaWYgKHNoaWZ0ICYmIGRlZmluaXRpb24uc2hpZnRLZXkpXG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5rZXkgPSBkZWZpbml0aW9uLnNoaWZ0S2V5O1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5rZXlDb2RlKVxuICAgICAgICAgICAgZGVzY3JpcHRpb24ua2V5Q29kZSA9IGRlZmluaXRpb24ua2V5Q29kZTtcbiAgICAgICAgaWYgKHNoaWZ0ICYmIGRlZmluaXRpb24uc2hpZnRLZXlDb2RlKVxuICAgICAgICAgICAgZGVzY3JpcHRpb24ua2V5Q29kZSA9IGRlZmluaXRpb24uc2hpZnRLZXlDb2RlO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5jb2RlKVxuICAgICAgICAgICAgZGVzY3JpcHRpb24uY29kZSA9IGRlZmluaXRpb24uY29kZTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ubG9jYXRpb24pXG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5sb2NhdGlvbiA9IGRlZmluaXRpb24ubG9jYXRpb247XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi5rZXkubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgZGVzY3JpcHRpb24udGV4dCA9IGRlc2NyaXB0aW9uLmtleTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24udGV4dClcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnRleHQgPSBkZWZpbml0aW9uLnRleHQ7XG4gICAgICAgIGlmIChzaGlmdCAmJiBkZWZpbml0aW9uLnNoaWZ0VGV4dClcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnRleHQgPSBkZWZpbml0aW9uLnNoaWZ0VGV4dDtcbiAgICAgICAgLy8gaWYgYW55IG1vZGlmaWVycyBiZXNpZGVzIHNoaWZ0IGFyZSBwcmVzc2VkLCBubyB0ZXh0IHNob3VsZCBiZSBzZW50XG4gICAgICAgIGlmICh0aGlzLl9tb2RpZmllcnMgJiB+OClcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnRleHQgPSAnJztcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGEgYGtleXVwYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBOYW1lIG9mIGtleSB0byByZWxlYXNlLCBzdWNoIGFzIGBBcnJvd0xlZnRgLlxuICAgICAqIFNlZSB7QGxpbmsgS2V5SW5wdXQgfCBLZXlJbnB1dH1cbiAgICAgKiBmb3IgYSBsaXN0IG9mIGFsbCBrZXkgbmFtZXMuXG4gICAgICovXG4gICAgYXN5bmMgdXAoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5fa2V5RGVzY3JpcHRpb25Gb3JTdHJpbmcoa2V5KTtcbiAgICAgICAgdGhpcy5fbW9kaWZpZXJzICY9IH50aGlzLl9tb2RpZmllckJpdChkZXNjcmlwdGlvbi5rZXkpO1xuICAgICAgICB0aGlzLl9wcmVzc2VkS2V5cy5kZWxldGUoZGVzY3JpcHRpb24uY29kZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdJbnB1dC5kaXNwYXRjaEtleUV2ZW50Jywge1xuICAgICAgICAgICAgdHlwZTogJ2tleVVwJyxcbiAgICAgICAgICAgIG1vZGlmaWVyczogdGhpcy5fbW9kaWZpZXJzLFxuICAgICAgICAgICAga2V5OiBkZXNjcmlwdGlvbi5rZXksXG4gICAgICAgICAgICB3aW5kb3dzVmlydHVhbEtleUNvZGU6IGRlc2NyaXB0aW9uLmtleUNvZGUsXG4gICAgICAgICAgICBjb2RlOiBkZXNjcmlwdGlvbi5jb2RlLFxuICAgICAgICAgICAgbG9jYXRpb246IGRlc2NyaXB0aW9uLmxvY2F0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhIGBrZXlwcmVzc2AgYW5kIGBpbnB1dGAgZXZlbnQuXG4gICAgICogVGhpcyBkb2VzIG5vdCBzZW5kIGEgYGtleWRvd25gIG9yIGBrZXl1cGAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIE1vZGlmaWVyIGtleXMgRE8gTk9UIGVmZmVjdCB7QGxpbmsgS2V5Ym9hcmQuc2VuZENoYXJhY3RlciB8IEtleWJvYXJkLnNlbmRDaGFyYWN0ZXJ9LlxuICAgICAqIEhvbGRpbmcgZG93biBgU2hpZnRgIHdpbGwgbm90IHR5cGUgdGhlIHRleHQgaW4gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBwYWdlLmtleWJvYXJkLnNlbmRDaGFyYWN0ZXIoJ+WXqCcpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYXIgLSBDaGFyYWN0ZXIgdG8gc2VuZCBpbnRvIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRDaGFyYWN0ZXIoY2hhcikge1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnSW5wdXQuaW5zZXJ0VGV4dCcsIHsgdGV4dDogY2hhciB9KTtcbiAgICB9XG4gICAgY2hhcklzS2V5KGNoYXIpIHtcbiAgICAgICAgcmV0dXJuICEha2V5RGVmaW5pdGlvbnNbY2hhcl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYGtleWRvd25gLCBga2V5cHJlc3NgL2BpbnB1dGAsXG4gICAgICogYW5kIGBrZXl1cGAgZXZlbnQgZm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUbyBwcmVzcyBhIHNwZWNpYWwga2V5LCBsaWtlIGBDb250cm9sYCBvciBgQXJyb3dEb3duYCxcbiAgICAgKiB1c2Uge0BsaW5rIEtleWJvYXJkLnByZXNzfS5cbiAgICAgKlxuICAgICAqIE1vZGlmaWVyIGtleXMgRE8gTk9UIGVmZmVjdCBga2V5Ym9hcmQudHlwZWAuXG4gICAgICogSG9sZGluZyBkb3duIGBTaGlmdGAgd2lsbCBub3QgdHlwZSB0aGUgdGV4dCBpbiB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IHBhZ2Uua2V5Ym9hcmQudHlwZSgnSGVsbG8nKTsgLy8gVHlwZXMgaW5zdGFudGx5XG4gICAgICogYXdhaXQgcGFnZS5rZXlib2FyZC50eXBlKCdXb3JsZCcsIHtkZWxheTogMTAwfSk7IC8vIFR5cGVzIHNsb3dlciwgbGlrZSBhIHVzZXJcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0IC0gQSB0ZXh0IHRvIHR5cGUgaW50byBhIGZvY3VzZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBvZiBvcHRpb25zLiBBY2NlcHRzIGRlbGF5IHdoaWNoLFxuICAgICAqIGlmIHNwZWNpZmllZCwgaXMgdGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIGBrZXlkb3duYCBhbmQgYGtleXVwYCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogRGVmYXVsdHMgdG8gMC5cbiAgICAgKi9cbiAgICBhc3luYyB0eXBlKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaGFyIG9mIHRleHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYXJJc0tleShjaGFyKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJlc3MoY2hhciwgeyBkZWxheSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkZWxheSlcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKGYpID0+IHNldFRpbWVvdXQoZiwgZGVsYXkpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmRDaGFyYWN0ZXIoY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBLZXlib2FyZC5kb3dufVxuICAgICAqIGFuZCB7QGxpbmsgS2V5Ym9hcmQudXB9LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBga2V5YCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIG5vIG1vZGlmaWVyIGtleXMgYmVzaWRlcyBgU2hpZnRgXG4gICAgICogYXJlIGJlaW5nIGhlbGQgZG93biwgYSBga2V5cHJlc3NgL2BpbnB1dGAgZXZlbnQgd2lsbCBhbHNvIGdlbmVyYXRlZC5cbiAgICAgKiBUaGUgYHRleHRgIG9wdGlvbiBjYW4gYmUgc3BlY2lmaWVkIHRvIGZvcmNlIGFuIGlucHV0IGV2ZW50IHRvIGJlIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIE1vZGlmaWVyIGtleXMgRE8gZWZmZWN0IHtAbGluayBLZXlib2FyZC5wcmVzc30uXG4gICAgICogSG9sZGluZyBkb3duIGBTaGlmdGAgd2lsbCB0eXBlIHRoZSB0ZXh0IGluIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiBrZXkgdG8gcHJlc3MsIHN1Y2ggYXMgYEFycm93TGVmdGAuXG4gICAgICogU2VlIHtAbGluayBLZXlJbnB1dH0gZm9yIGEgbGlzdCBvZiBhbGwga2V5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgb2Ygb3B0aW9ucy4gQWNjZXB0cyB0ZXh0IHdoaWNoLCBpZiBzcGVjaWZpZWQsXG4gICAgICogZ2VuZXJhdGVzIGFuIGlucHV0IGV2ZW50IHdpdGggdGhpcyB0ZXh0LiBBY2NlcHRzIGRlbGF5IHdoaWNoLFxuICAgICAqIGlmIHNwZWNpZmllZCwgaXMgdGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIGBrZXlkb3duYCBhbmQgYGtleXVwYCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogRGVmYXVsdHMgdG8gMC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVzcyhrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gbnVsbCB9ID0gb3B0aW9ucztcbiAgICAgICAgYXdhaXQgdGhpcy5kb3duKGtleSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChkZWxheSlcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChmKSA9PiBzZXRUaW1lb3V0KGYsIG9wdGlvbnMuZGVsYXkpKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cChrZXkpO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIE1vdXNlIGNsYXNzIG9wZXJhdGVzIGluIG1haW4tZnJhbWUgQ1NTIHBpeGVsc1xuICogcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcmVtYXJrc1xuICogRXZlcnkgYHBhZ2VgIG9iamVjdCBoYXMgaXRzIG93biBNb3VzZSwgYWNjZXNzaWJsZSB3aXRoIFtgcGFnZS5tb3VzZWBdKCNwYWdlbW91c2UpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gVXNpbmcg4oCYcGFnZS5tb3VzZeKAmSB0byB0cmFjZSBhIDEwMHgxMDAgc3F1YXJlLlxuICogYXdhaXQgcGFnZS5tb3VzZS5tb3ZlKDAsIDApO1xuICogYXdhaXQgcGFnZS5tb3VzZS5kb3duKCk7XG4gKiBhd2FpdCBwYWdlLm1vdXNlLm1vdmUoMCwgMTAwKTtcbiAqIGF3YWl0IHBhZ2UubW91c2UubW92ZSgxMDAsIDEwMCk7XG4gKiBhd2FpdCBwYWdlLm1vdXNlLm1vdmUoMTAwLCAwKTtcbiAqIGF3YWl0IHBhZ2UubW91c2UubW92ZSgwLCAwKTtcbiAqIGF3YWl0IHBhZ2UubW91c2UudXAoKTtcbiAqIGBgYFxuICpcbiAqICoqTm90ZSoqOiBUaGUgbW91c2UgZXZlbnRzIHRyaWdnZXIgc3ludGhldGljIGBNb3VzZUV2ZW50YHMuXG4gKiBUaGlzIG1lYW5zIHRoYXQgaXQgZG9lcyBub3QgZnVsbHkgcmVwbGljYXRlIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHdoYXQgYSBub3JtYWwgdXNlclxuICogd291bGQgYmUgYWJsZSB0byBkbyB3aXRoIHRoZWlyIG1vdXNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBkcmFnZ2luZyBhbmQgc2VsZWN0aW5nIHRleHQgaXMgbm90IHBvc3NpYmxlIHVzaW5nIGBwYWdlLm1vdXNlYC5cbiAqIEluc3RlYWQsIHlvdSBjYW4gdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50T3JTaGFkb3dSb290L2dldFNlbGVjdGlvbiB8IGBEb2N1bWVudE9yU2hhZG93Um9vdC5nZXRTZWxlY3Rpb24oKWB9IGZ1bmN0aW9uYWxpdHkgaW1wbGVtZW50ZWQgaW4gdGhlIHBsYXRmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gc2VsZWN0IGFsbCBjb250ZW50IGJldHdlZW4gbm9kZXM6XG4gKiBgYGBqc1xuICogYXdhaXQgcGFnZS5ldmFsdWF0ZSgoZnJvbSwgdG8pID0+IHtcbiAqICAgY29uc3Qgc2VsZWN0aW9uID0gZnJvbS5nZXRSb290Tm9kZSgpLmdldFNlbGVjdGlvbigpO1xuICogICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gKiAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKGZyb20pO1xuICogICByYW5nZS5zZXRFbmRBZnRlcih0byk7XG4gKiAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAqICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAqIH0sIGZyb21KU0hhbmRsZSwgdG9KU0hhbmRsZSk7XG4gKiBgYGBcbiAqIElmIHlvdSB0aGVuIHdvdWxkIHdhbnQgdG8gY29weS1wYXN0ZSB5b3VyIHNlbGVjdGlvbiwgeW91IGNhbiB1c2UgdGhlIGNsaXBib2FyZCBhcGk6XG4gKiBgYGBqc1xuICogLy8gVGhlIGNsaXBib2FyZCBhcGkgZG9lcyBub3QgYWxsb3cgeW91IHRvIGNvcHksIHVubGVzcyB0aGUgdGFiIGlzIGZvY3VzZWQuXG4gKiBhd2FpdCBwYWdlLmJyaW5nVG9Gcm9udCgpO1xuICogYXdhaXQgcGFnZS5ldmFsdWF0ZSgoKSA9PiB7XG4gKiAgIC8vIENvcHkgdGhlIHNlbGVjdGVkIGNvbnRlbnQgdG8gdGhlIGNsaXBib2FyZFxuICogICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICogICAvLyBPYnRhaW4gdGhlIGNvbnRlbnQgb2YgdGhlIGNsaXBib2FyZCBhcyBhIHN0cmluZ1xuICogICByZXR1cm4gbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpO1xuICogfSk7XG4gKiBgYGBcbiAqICoqTm90ZSoqOiBJZiB5b3Ugd2FudCBhY2Nlc3MgdG8gdGhlIGNsaXBib2FyZCBBUEksXG4gKiB5b3UgaGF2ZSB0byBnaXZlIGl0IHBlcm1pc3Npb24gdG8gZG8gc286XG4gKiBgYGBqc1xuICogYXdhaXQgYnJvd3Nlci5kZWZhdWx0QnJvd3NlckNvbnRleHQoKS5vdmVycmlkZVBlcm1pc3Npb25zKFxuICogICAnPHlvdXIgb3JpZ2luPicsIFsnY2xpcGJvYXJkLXJlYWQnLCAnY2xpcGJvYXJkLXdyaXRlJ11cbiAqICk7XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgdGhpcy5fYnV0dG9uID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkID0ga2V5Ym9hcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBgbW91c2Vtb3ZlYCBldmVudC5cbiAgICAgKiBAcGFyYW0geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgb2JqZWN0LiBJZiBzcGVjaWZpZWQsIHRoZSBgc3RlcHNgIHByb3BlcnR5XG4gICAgICogc2VuZHMgaW50ZXJtZWRpYXRlIGBtb3VzZW1vdmVgIGV2ZW50cyB3aGVuIHNldCB0byBgMWAgKGRlZmF1bHQpLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmUoeCwgeSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgc3RlcHMgPSAxIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBmcm9tWCA9IHRoaXMuX3gsIGZyb21ZID0gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzdGVwczsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnSW5wdXQuZGlzcGF0Y2hNb3VzZUV2ZW50Jywge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZU1vdmVkJyxcbiAgICAgICAgICAgICAgICBidXR0b246IHRoaXMuX2J1dHRvbixcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCArICh0aGlzLl94IC0gZnJvbVgpICogKGkgLyBzdGVwcyksXG4gICAgICAgICAgICAgICAgeTogZnJvbVkgKyAodGhpcy5feSAtIGZyb21ZKSAqIChpIC8gc3RlcHMpLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogdGhpcy5fa2V5Ym9hcmQuX21vZGlmaWVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IGZvciBgbW91c2UubW92ZWAsIGBtb3VzZS5kb3duYCBhbmQgYG1vdXNlLnVwYC5cbiAgICAgKiBAcGFyYW0geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgYE1vdXNlT3B0aW9uc2AuXG4gICAgICovXG4gICAgYXN5bmMgY2xpY2soeCwgeSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSBudWxsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubW92ZSh4LCB5KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZG93bihvcHRpb25zKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChmKSA9PiBzZXRUaW1lb3V0KGYsIGRlbGF5KSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVwKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tb3ZlKHgsIHkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kb3duKG9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51cChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGEgYG1vdXNlZG93bmAgZXZlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBgTW91c2VPcHRpb25zYC5cbiAgICAgKi9cbiAgICBhc3luYyBkb3duKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGJ1dHRvbiA9ICdsZWZ0JywgY2xpY2tDb3VudCA9IDEgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2J1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZVByZXNzZWQnLFxuICAgICAgICAgICAgYnV0dG9uLFxuICAgICAgICAgICAgeDogdGhpcy5feCxcbiAgICAgICAgICAgIHk6IHRoaXMuX3ksXG4gICAgICAgICAgICBtb2RpZmllcnM6IHRoaXMuX2tleWJvYXJkLl9tb2RpZmllcnMsXG4gICAgICAgICAgICBjbGlja0NvdW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhIGBtb3VzZXVwYCBldmVudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGBNb3VzZU9wdGlvbnNgLlxuICAgICAqL1xuICAgIGFzeW5jIHVwKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGJ1dHRvbiA9ICdsZWZ0JywgY2xpY2tDb3VudCA9IDEgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2J1dHRvbiA9ICdub25lJztcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZVJlbGVhc2VkJyxcbiAgICAgICAgICAgIGJ1dHRvbixcbiAgICAgICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgICAgICB5OiB0aGlzLl95LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB0aGlzLl9rZXlib2FyZC5fbW9kaWZpZXJzLFxuICAgICAgICAgICAgY2xpY2tDb3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBgbW91c2V3aGVlbGAgZXZlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbDogYE1vdXNlV2hlZWxPcHRpb25zYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQW4gZXhhbXBsZSBvZiB6b29taW5nIGludG8gYW4gZWxlbWVudDpcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IHBhZ2UuZ290bygnaHR0cHM6Ly9tZG4ubW96aWxsYWRlbW9zLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC93aGVlbF9ldmVudCRzYW1wbGVzL1NjYWxpbmdfYW5fZWxlbWVudF92aWFfdGhlX3doZWVsP3JldmlzaW9uPTE1ODczNjYnKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IGVsZW0gPSBhd2FpdCBwYWdlLiQoJ2RpdicpO1xuICAgICAqIGNvbnN0IGJvdW5kaW5nQm94ID0gYXdhaXQgZWxlbS5ib3VuZGluZ0JveCgpO1xuICAgICAqIGF3YWl0IHBhZ2UubW91c2UubW92ZShcbiAgICAgKiAgIGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAvIDIsXG4gICAgICogICBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0IC8gMlxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBhd2FpdCBwYWdlLm1vdXNlLndoZWVsKHsgZGVsdGFZOiAtMTAwIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgd2hlZWwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZGVsdGFYID0gMCwgZGVsdGFZID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3VzZVdoZWVsJyxcbiAgICAgICAgICAgIHg6IHRoaXMuX3gsXG4gICAgICAgICAgICB5OiB0aGlzLl95LFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB0aGlzLl9rZXlib2FyZC5fbW9kaWZpZXJzLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIFRvdWNoc2NyZWVuIGNsYXNzIGV4cG9zZXMgdG91Y2hzY3JlZW4gZXZlbnRzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVG91Y2hzY3JlZW4ge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwga2V5Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLl9rZXlib2FyZCA9IGtleWJvYXJkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGEgYHRvdWNoc3RhcnRgIGFuZCBgdG91Y2hlbmRgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICAgICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHRhcC5cbiAgICAgKi9cbiAgICBhc3luYyB0YXAoeCwgeSkge1xuICAgICAgICBjb25zdCB0b3VjaFBvaW50cyA9IFt7IHg6IE1hdGgucm91bmQoeCksIHk6IE1hdGgucm91bmQoeSkgfV07XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdJbnB1dC5kaXNwYXRjaFRvdWNoRXZlbnQnLCB7XG4gICAgICAgICAgICB0eXBlOiAndG91Y2hTdGFydCcsXG4gICAgICAgICAgICB0b3VjaFBvaW50cyxcbiAgICAgICAgICAgIG1vZGlmaWVyczogdGhpcy5fa2V5Ym9hcmQuX21vZGlmaWVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdJbnB1dC5kaXNwYXRjaFRvdWNoRXZlbnQnLCB7XG4gICAgICAgICAgICB0eXBlOiAndG91Y2hFbmQnLFxuICAgICAgICAgICAgdG91Y2hQb2ludHM6IFtdLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB0aGlzLl9rZXlib2FyZC5fbW9kaWZpZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIsIGRlYnVnRXJyb3IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBnZXRRdWVyeUhhbmRsZXJBbmRTZWxlY3RvciB9IGZyb20gJy4vUXVlcnlIYW5kbGVyLmpzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL2Vudmlyb25tZW50LmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVKU0hhbmRsZShjb250ZXh0LCByZW1vdGVPYmplY3QpIHtcbiAgICBjb25zdCBmcmFtZSA9IGNvbnRleHQuZnJhbWUoKTtcbiAgICBpZiAocmVtb3RlT2JqZWN0LnN1YnR5cGUgPT09ICdub2RlJyAmJiBmcmFtZSkge1xuICAgICAgICBjb25zdCBmcmFtZU1hbmFnZXIgPSBmcmFtZS5fZnJhbWVNYW5hZ2VyO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRIYW5kbGUoY29udGV4dCwgY29udGV4dC5fY2xpZW50LCByZW1vdGVPYmplY3QsIGZyYW1lTWFuYWdlci5wYWdlKCksIGZyYW1lTWFuYWdlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSlNIYW5kbGUoY29udGV4dCwgY29udGV4dC5fY2xpZW50LCByZW1vdGVPYmplY3QpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluLXBhZ2UgSmF2YVNjcmlwdCBvYmplY3QuIEpTSGFuZGxlcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxuICoge0BsaW5rIFBhZ2UuZXZhbHVhdGVIYW5kbGUgfCBwYWdlLmV2YWx1YXRlSGFuZGxlfSBtZXRob2QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCB3aW5kb3dIYW5kbGUgPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlKCgpID0+IHdpbmRvdyk7XG4gKiBgYGBcbiAqXG4gKiBKU0hhbmRsZSBwcmV2ZW50cyB0aGUgcmVmZXJlbmNlZCBKYXZhU2NyaXB0IG9iamVjdCBmcm9tIGJlaW5nIGdhcmJhZ2UtY29sbGVjdGVkXG4gKiB1bmxlc3MgdGhlIGhhbmRsZSBpcyB7QGxpbmsgSlNIYW5kbGUuZGlzcG9zZSB8IGRpc3Bvc2VkfS4gSlNIYW5kbGVzIGFyZSBhdXRvLVxuICogZGlzcG9zZWQgd2hlbiB0aGVpciBvcmlnaW4gZnJhbWUgZ2V0cyBuYXZpZ2F0ZWQgb3IgdGhlIHBhcmVudCBjb250ZXh0IGdldHMgZGVzdHJveWVkLlxuICpcbiAqIEpTSGFuZGxlIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudHMgZm9yIHtAbGluayBQYWdlLiRldmFsfSxcbiAqIHtAbGluayBQYWdlLmV2YWx1YXRlfSwgYW5kIHtAbGluayBQYWdlLmV2YWx1YXRlSGFuZGxlfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBKU0hhbmRsZSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2xpZW50LCByZW1vdGVPYmplY3QpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5fcmVtb3RlT2JqZWN0ID0gcmVtb3RlT2JqZWN0O1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZXhlY3V0aW9uIGNvbnRleHQgdGhlIGhhbmRsZSBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXNzZXMgdGhpcyBoYW5kbGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqIElmIGBwYWdlRnVuY3Rpb25gIHJldHVybnMgYSBQcm9taXNlLCB0aGVuIGBoYW5kbGUuZXZhbHVhdGVgIHdvdWxkIHdhaXRcbiAgICAgKiBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB0d2VldEhhbmRsZSA9IGF3YWl0IHBhZ2UuJCgnLnR3ZWV0IC5yZXR3ZWV0cycpO1xuICAgICAqIGV4cGVjdChhd2FpdCB0d2VldEhhbmRsZS5ldmFsdWF0ZShub2RlID0+IG5vZGUuaW5uZXJUZXh0KSkudG9CZSgnMTAnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0aW9uQ29udGV4dCgpLmV2YWx1YXRlKHBhZ2VGdW5jdGlvbiwgdGhpcywgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHBhc3NlcyB0aGlzIGhhbmRsZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYHBhZ2VGdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGBqc0hhbmRsZS5ldmFsdWF0ZWAgYW5kXG4gICAgICogYGpzSGFuZGxlLmV2YWx1YXRlSGFuZGxlYCBpcyB0aGF0IGBqc0hhbmRsZS5ldmFsdWF0ZUhhbmRsZWBcbiAgICAgKiByZXR1cm5zIGFuIGluLXBhZ2Ugb2JqZWN0IChKU0hhbmRsZSkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBqc0hhbmRsZS5ldmFsdWF0ZUhhbmRsZWAgcmV0dXJucyBhIFByb21pc2UsXG4gICAgICogdGhlbiBgZXZhbHVhdGVIYW5kbGUuZXZhbHVhdGVIYW5kbGVgIHdhaXRzIGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGFuZFxuICAgICAqIHJldHVybnMgaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBQYWdlLmV2YWx1YXRlSGFuZGxlfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlSGFuZGxlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRpb25Db250ZXh0KCkuZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCB0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqIEZldGNoZXMgYSBzaW5nbGUgcHJvcGVydHkgZnJvbSB0aGUgcmVmZXJlbmNlZCBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvcGVydHkocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdEhhbmRsZSA9IGF3YWl0IHRoaXMuZXZhbHVhdGVIYW5kbGUoKG9iamVjdCwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBvYmplY3RbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCBvYmplY3RIYW5kbGUuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9wZXJ0aWVzLmdldChwcm9wZXJ0eU5hbWUpIHx8IG51bGw7XG4gICAgICAgIGF3YWl0IG9iamVjdEhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIG1hcCB3aXRoIHByb3BlcnR5IG5hbWVzIGFzIGtleXMgYW5kIEpTSGFuZGxlXG4gICAgICogaW5zdGFuY2VzIGZvciB0aGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxpc3RIYW5kbGUgPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlKCgpID0+IGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCBsaXN0SGFuZGxlLmdldFByb3BlcnRpZXMoKTtcbiAgICAgKiBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAqIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcy52YWx1ZXMoKSkge1xuICAgICAqICAgY29uc3QgZWxlbWVudCA9IHByb3BlcnR5LmFzRWxlbWVudCgpO1xuICAgICAqICAgaWYgKGVsZW1lbnQpXG4gICAgICogICAgIGNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICogfVxuICAgICAqIGNoaWxkcmVuOyAvLyBob2xkcyBlbGVtZW50SGFuZGxlcyB0byBhbGwgY2hpbGRyZW4gb2YgZG9jdW1lbnQuYm9keVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3BlcnRpZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1J1bnRpbWUuZ2V0UHJvcGVydGllcycsIHtcbiAgICAgICAgICAgIG9iamVjdElkOiB0aGlzLl9yZW1vdGVPYmplY3Qub2JqZWN0SWQsXG4gICAgICAgICAgICBvd25Qcm9wZXJ0aWVzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5lbnVtZXJhYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmVzdWx0LnNldChwcm9wZXJ0eS5uYW1lLCBjcmVhdGVKU0hhbmRsZSh0aGlzLl9jb250ZXh0LCBwcm9wZXJ0eS52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuSWYgdGhlIG9iamVjdCBoYXMgYVxuICAgICAqIGB0b0pTT05gIGZ1bmN0aW9uLCBpdCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoZSBKU09OIGlzIGdlbmVyYXRlZCBieSBydW5uaW5nIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSB8IEpTT04uc3RyaW5naWZ5fVxuICAgICAqIG9uIHRoZSBvYmplY3QgaW4gcGFnZSBhbmQgY29uc2VxdWVudCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZSB8IEpTT04ucGFyc2V9IGluIHB1cHBldGVlci5cbiAgICAgKiAqKk5PVEUqKiBUaGUgbWV0aG9kIHRocm93cyBpZiB0aGUgcmVmZXJlbmNlZCBvYmplY3QgaXMgbm90IHN0cmluZ2lmaWFibGUuXG4gICAgICovXG4gICAgYXN5bmMganNvblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVtb3RlT2JqZWN0Lm9iamVjdElkKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246ICdmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0nLFxuICAgICAgICAgICAgICAgIG9iamVjdElkOiB0aGlzLl9yZW1vdGVPYmplY3Qub2JqZWN0SWQsXG4gICAgICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIudmFsdWVGcm9tUmVtb3RlT2JqZWN0KHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBlci52YWx1ZUZyb21SZW1vdGVPYmplY3QodGhpcy5fcmVtb3RlT2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRWl0aGVyIGBudWxsYCBvciB0aGUgb2JqZWN0IGhhbmRsZSBpdHNlbGYsIGlmIHRoZSBvYmplY3RcbiAgICAgKiBoYW5kbGUgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEVsZW1lbnRIYW5kbGV9LlxuICAgICAqL1xuICAgIGFzRWxlbWVudCgpIHtcbiAgICAgICAgLyogIFRoaXMgYWx3YXlzIHJldHVybnMgbnVsbCwgYnV0IHN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgYW5kIHJldHVybiBhblxuICAgICAgICAgICAgRWxlbWVudEhhbmRsZS5cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlZmVyZW5jaW5nIHRoZSBlbGVtZW50IGhhbmRsZSwgYW5kIHJlc29sdmVzIHdoZW4gdGhlIG9iamVjdCBoYW5kbGUgaXNcbiAgICAgKiBzdWNjZXNzZnVsbHkgZGlzcG9zZWQgb2YuXG4gICAgICovXG4gICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IGhlbHBlci5yZWxlYXNlT2JqZWN0KHRoaXMuX2NsaWVudCwgdGhpcy5fcmVtb3RlT2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSlNIYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrcyBVc2VmdWwgZHVyaW5nIGRlYnVnZ2luZy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbW90ZU9iamVjdC5vYmplY3RJZCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3JlbW90ZU9iamVjdC5zdWJ0eXBlIHx8IHRoaXMuX3JlbW90ZU9iamVjdC50eXBlO1xuICAgICAgICAgICAgcmV0dXJuICdKU0hhbmRsZUAnICsgdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0pTSGFuZGxlOicgKyBoZWxwZXIudmFsdWVGcm9tUmVtb3RlT2JqZWN0KHRoaXMuX3JlbW90ZU9iamVjdCk7XG4gICAgfVxufVxuLyoqXG4gKiBFbGVtZW50SGFuZGxlIHJlcHJlc2VudHMgYW4gaW4tcGFnZSBET00gZWxlbWVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIEVsZW1lbnRIYW5kbGVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlIHtAbGluayBQYWdlLiR9IG1ldGhvZC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gKlxuICogKGFzeW5jICgpID0+IHtcbiAqICBjb25zdCBicm93c2VyID0gYXdhaXQgcHVwcGV0ZWVyLmxhdW5jaCgpO1xuICogIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAqICBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vZXhhbXBsZS5jb20nKTtcbiAqICBjb25zdCBocmVmRWxlbWVudCA9IGF3YWl0IHBhZ2UuJCgnYScpO1xuICogIGF3YWl0IGhyZWZFbGVtZW50LmNsaWNrKCk7XG4gKiAgLy8gLi4uXG4gKiB9KSgpO1xuICogYGBgXG4gKlxuICogRWxlbWVudEhhbmRsZSBwcmV2ZW50cyB0aGUgRE9NIGVsZW1lbnQgZnJvbSBiZWluZyBnYXJiYWdlLWNvbGxlY3RlZCB1bmxlc3MgdGhlXG4gKiBoYW5kbGUgaXMge0BsaW5rIEpTSGFuZGxlLmRpc3Bvc2UgfCBkaXNwb3NlZH0uIEVsZW1lbnRIYW5kbGVzIGFyZSBhdXRvLWRpc3Bvc2VkXG4gKiB3aGVuIHRoZWlyIG9yaWdpbiBmcmFtZSBnZXRzIG5hdmlnYXRlZC5cbiAqXG4gKiBFbGVtZW50SGFuZGxlIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudHMgaW4ge0BsaW5rIFBhZ2UuJGV2YWx9IGFuZFxuICoge0BsaW5rIFBhZ2UuZXZhbHVhdGV9IG1ldGhvZHMuXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsIEVsZW1lbnRIYW5kbGUgdGFrZXMgYSBnZW5lcmljIGFyZ3VtZW50IHRoYXRcbiAqIGRlbm90ZXMgdGhlIHR5cGUgb2YgZWxlbWVudCB0aGUgaGFuZGxlIGlzIGhvbGRpbmcgd2l0aGluLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBoYXZlIGEgaGFuZGxlIHRvIGEgYDxzZWxlY3Q+YCBlbGVtZW50LCB5b3UgY2FuIHR5cGUgaXQgYXNcbiAqIGBFbGVtZW50SGFuZGxlPEhUTUxTZWxlY3RFbGVtZW50PmAgYW5kIHlvdSBnZXQgc29tZSBuaWNlciB0eXBlIGNoZWNrcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50SGFuZGxlIGV4dGVuZHMgSlNIYW5kbGUge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNsaWVudCwgcmVtb3RlT2JqZWN0LCBwYWdlLCBmcmFtZU1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCwgY2xpZW50LCByZW1vdGVPYmplY3QpO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX3JlbW90ZU9iamVjdCA9IHJlbW90ZU9iamVjdDtcbiAgICAgICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlciA9IGZyYW1lTWFuYWdlcjtcbiAgICB9XG4gICAgYXNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gdGhlIGNvbnRlbnQgZnJhbWUgZm9yIGVsZW1lbnQgaGFuZGxlcyByZWZlcmVuY2luZ1xuICAgICAqIGlmcmFtZSBub2Rlcywgb3IgbnVsbCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyBjb250ZW50RnJhbWUoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVJbmZvID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0RPTS5kZXNjcmliZU5vZGUnLCB7XG4gICAgICAgICAgICBvYmplY3RJZDogdGhpcy5fcmVtb3RlT2JqZWN0Lm9iamVjdElkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlSW5mby5ub2RlLmZyYW1lSWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZU1hbmFnZXIuZnJhbWUobm9kZUluZm8ubm9kZS5mcmFtZUlkKTtcbiAgICB9XG4gICAgYXN5bmMgX3Njcm9sbEludG9WaWV3SWZOZWVkZWQoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgdGhpcy5ldmFsdWF0ZShhc3luYyAoZWxlbWVudCwgcGFnZUphdmFzY3JpcHRFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuaXNDb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdOb2RlIGlzIGRldGFjaGVkIGZyb20gZG9jdW1lbnQnO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICAgICAgICAgIHJldHVybiAnTm9kZSBpcyBub3Qgb2YgdHlwZSBIVE1MRWxlbWVudCc7XG4gICAgICAgICAgICAvLyBmb3JjZS1zY3JvbGwgaWYgcGFnZSdzIGphdmFzY3JpcHQgaXMgZGlzYWJsZWQuXG4gICAgICAgICAgICBpZiAoIXBhZ2VKYXZhc2NyaXB0RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQ2hyb21lIHN0aWxsIHN1cHBvcnRzIGJlaGF2aW9yOiBpbnN0YW50IGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBpbiB0aGUgc3BlYyBzbyBUUyBzaG91dHMgV2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWtpbmcgY2hhbmdlIGluIFB1cHBldGVlciB5ZXQgc28gd2UnbGwgaWdub3JlIHRoZSBsaW5lLlxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ2luc3RhbnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVSYXRpbyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlUmF0aW8gIT09IDEuMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQ2hyb21lIHN0aWxsIHN1cHBvcnRzIGJlaGF2aW9yOiBpbnN0YW50IGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBpbiB0aGUgc3BlYyBzbyBUUyBzaG91dHMgV2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWtpbmcgY2hhbmdlIGluIFB1cHBldGVlciB5ZXQgc28gd2UnbGwgaWdub3JlIHRoZSBsaW5lLlxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ2luc3RhbnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzLl9wYWdlLmlzSmF2YVNjcmlwdEVuYWJsZWQoKSk7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGFzeW5jIF9jbGlja2FibGVQb2ludCgpIHtcbiAgICAgICAgY29uc3QgW3Jlc3VsdCwgbGF5b3V0TWV0cmljc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9jbGllbnRcbiAgICAgICAgICAgICAgICAuc2VuZCgnRE9NLmdldENvbnRlbnRRdWFkcycsIHtcbiAgICAgICAgICAgICAgICBvYmplY3RJZDogdGhpcy5fcmVtb3RlT2JqZWN0Lm9iamVjdElkLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZGVidWdFcnJvciksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5nZXRMYXlvdXRNZXRyaWNzJyksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnF1YWRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBlaXRoZXIgbm90IHZpc2libGUgb3Igbm90IGFuIEhUTUxFbGVtZW50Jyk7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgcXVhZHMgdGhhdCBoYXZlIHRvbyBzbWFsbCBhcmVhIHRvIGNsaWNrIGludG8uXG4gICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gbGF5b3V0TWV0cmljcy5sYXlvdXRWaWV3cG9ydDtcbiAgICAgICAgY29uc3QgcXVhZHMgPSByZXN1bHQucXVhZHNcbiAgICAgICAgICAgIC5tYXAoKHF1YWQpID0+IHRoaXMuX2Zyb21Qcm90b2NvbFF1YWQocXVhZCkpXG4gICAgICAgICAgICAubWFwKChxdWFkKSA9PiB0aGlzLl9pbnRlcnNlY3RRdWFkV2l0aFZpZXdwb3J0KHF1YWQsIGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQpKVxuICAgICAgICAgICAgLmZpbHRlcigocXVhZCkgPT4gY29tcHV0ZVF1YWRBcmVhKHF1YWQpID4gMSk7XG4gICAgICAgIGlmICghcXVhZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGlzIGVpdGhlciBub3QgdmlzaWJsZSBvciBub3QgYW4gSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGZpcnN0IHF1YWQuXG4gICAgICAgIGNvbnN0IHF1YWQgPSBxdWFkc1swXTtcbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcXVhZCkge1xuICAgICAgICAgICAgeCArPSBwb2ludC54O1xuICAgICAgICAgICAgeSArPSBwb2ludC55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4IC8gNCxcbiAgICAgICAgICAgIHk6IHkgLyA0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0Qm94TW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG9iamVjdElkOiB0aGlzLl9yZW1vdGVPYmplY3Qub2JqZWN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnRcbiAgICAgICAgICAgIC5zZW5kKCdET00uZ2V0Qm94TW9kZWwnLCBwYXJhbXMpXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBkZWJ1Z0Vycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIF9mcm9tUHJvdG9jb2xRdWFkKHF1YWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogcXVhZFswXSwgeTogcXVhZFsxXSB9LFxuICAgICAgICAgICAgeyB4OiBxdWFkWzJdLCB5OiBxdWFkWzNdIH0sXG4gICAgICAgICAgICB7IHg6IHF1YWRbNF0sIHk6IHF1YWRbNV0gfSxcbiAgICAgICAgICAgIHsgeDogcXVhZFs2XSwgeTogcXVhZFs3XSB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBfaW50ZXJzZWN0UXVhZFdpdGhWaWV3cG9ydChxdWFkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBxdWFkLm1hcCgocG9pbnQpID0+ICh7XG4gICAgICAgICAgICB4OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC54LCAwKSwgd2lkdGgpLFxuICAgICAgICAgICAgeTogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQueSwgMCksIGhlaWdodCksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2Nyb2xscyBlbGVtZW50IGludG8gdmlldyBpZiBuZWVkZWQsIGFuZCB0aGVuXG4gICAgICogdXNlcyB7QGxpbmsgUGFnZS5tb3VzZX0gdG8gaG92ZXIgb3ZlciB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIElmIHRoZSBlbGVtZW50IGlzIGRldGFjaGVkIGZyb20gRE9NLCB0aGUgbWV0aG9kIHRocm93cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBhc3luYyBob3ZlcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGF3YWl0IHRoaXMuX2NsaWNrYWJsZVBvaW50KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BhZ2UubW91c2UubW92ZSh4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2Nyb2xscyBlbGVtZW50IGludG8gdmlldyBpZiBuZWVkZWQsIGFuZCB0aGVuXG4gICAgICogdXNlcyB7QGxpbmsgUGFnZS5tb3VzZX0gdG8gY2xpY2sgaW4gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIERPTSwgdGhlIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICovXG4gICAgYXN5bmMgY2xpY2sob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Njcm9sbEludG9WaWV3SWZOZWVkZWQoKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBhd2FpdCB0aGlzLl9jbGlja2FibGVQb2ludCgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYWdlLm1vdXNlLmNsaWNrKHgsIHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIGBjaGFuZ2VgIGFuZCBgaW5wdXRgIGV2ZW50IG9uY2UgYWxsIHRoZSBwcm92aWRlZCBvcHRpb25zIGhhdmUgYmVlblxuICAgICAqIHNlbGVjdGVkLiBJZiB0aGVyZSdzIG5vIGA8c2VsZWN0PmAgZWxlbWVudCBtYXRjaGluZyBgc2VsZWN0b3JgLCB0aGUgbWV0aG9kXG4gICAgICogdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGhhbmRsZS5zZWxlY3QoJ2JsdWUnKTsgLy8gc2luZ2xlIHNlbGVjdGlvblxuICAgICAqIGhhbmRsZS5zZWxlY3QoJ3JlZCcsICdncmVlbicsICdibHVlJyk7IC8vIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVmFsdWVzIG9mIG9wdGlvbnMgdG8gc2VsZWN0LiBJZiB0aGUgYDxzZWxlY3Q+YCBoYXMgdGhlXG4gICAgICogICAgYG11bHRpcGxlYCBhdHRyaWJ1dGUsIGFsbCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQsIG90aGVyd2lzZSBvbmx5IHRoZSBmaXJzdFxuICAgICAqICAgIG9uZSBpcyB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0KC4uLnZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcylcbiAgICAgICAgICAgIGFzc2VydChoZWxwZXIuaXNTdHJpbmcodmFsdWUpLCAnVmFsdWVzIG11c3QgYmUgc3RyaW5ncy4gRm91bmQgdmFsdWUgXCInICtcbiAgICAgICAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgICAgICAgJ1wiIG9mIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZSgoZWxlbWVudCwgdmFsdWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBpcyBub3QgYSA8c2VsZWN0PiBlbGVtZW50LicpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEFycmF5LmZyb20oZWxlbWVudC5vcHRpb25zKTtcbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWVzLmluY2x1ZGVzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAmJiAhZWxlbWVudC5tdWx0aXBsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbi5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgIH0sIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4cGVjdHMgYGVsZW1lbnRIYW5kbGVgIHRvIHBvaW50IHRvIGFuXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCB8IGlucHV0IGVsZW1lbnR9LlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aHMgLSBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZmlsZSBpbnB1dCB0byB0aGVzZSBwYXRocy5cbiAgICAgKiAgICBJZiBzb21lIG9mIHRoZSAgYGZpbGVQYXRoc2AgYXJlIHJlbGF0aXZlIHBhdGhzLCB0aGVuIHRoZXkgYXJlIHJlc29sdmVkXG4gICAgICogICAgcmVsYXRpdmUgdG8gdGhlIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfY3dkIHwgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeX1cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlKC4uLmZpbGVQYXRocykge1xuICAgICAgICBjb25zdCBpc011bHRpcGxlID0gYXdhaXQgdGhpcy5ldmFsdWF0ZSgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGxvYWRGaWxlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhbiBpbnB1dCBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubXVsdGlwbGU7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQoZmlsZVBhdGhzLmxlbmd0aCA8PSAxIHx8IGlzTXVsdGlwbGUsICdNdWx0aXBsZSBmaWxlIHVwbG9hZHMgb25seSB3b3JrIHdpdGggPGlucHV0IHR5cGU9ZmlsZSBtdWx0aXBsZT4nKTtcbiAgICAgICAgaWYgKCFpc05vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSlNIYW5kbGUjdXBsb2FkRmlsZSBjYW4gb25seSBiZSB1c2VkIGluIE5vZGUgZW52aXJvbm1lbnRzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICBUaGlzIGltcG9ydCBpcyBvbmx5IG5lZWRlZCBmb3IgYHVwbG9hZEZpbGVgLCBzbyBrZWVwIGl0IHNjb3BlZCBoZXJlIHRvXG4gICAgICAgICBhdm9pZCBwYXlpbmcgdGhlIGNvc3QgdW5uZWNlc3NhcmlseS5cbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGF0aCA9IGF3YWl0IGltcG9ydCgncGF0aCcpO1xuICAgICAgICBjb25zdCBmcyA9IGF3YWl0IGhlbHBlci5pbXBvcnRGU01vZHVsZSgpO1xuICAgICAgICAvLyBMb2NhdGUgYWxsIGZpbGVzIGFuZCBjb25maXJtIHRoYXQgdGhleSBleGlzdC5cbiAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChmaWxlUGF0aHMubWFwKGFzeW5jIChmaWxlUGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcGF0aC5yZXNvbHZlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMuYWNjZXNzKHJlc29sdmVkUGF0aCwgZnMuY29uc3RhbnRzLlJfT0spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmlsZVBhdGh9IGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCByZWFkYWJsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IG9iamVjdElkIH0gPSB0aGlzLl9yZW1vdGVPYmplY3Q7XG4gICAgICAgIGNvbnN0IHsgbm9kZSB9ID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0RPTS5kZXNjcmliZU5vZGUnLCB7IG9iamVjdElkIH0pO1xuICAgICAgICBjb25zdCB7IGJhY2tlbmROb2RlSWQgfSA9IG5vZGU7XG4gICAgICAgIC8qICBUaGUgemVyby1sZW5ndGggYXJyYXkgaXMgYSBzcGVjaWFsIGNhc2UsIGl0IHNlZW1zIHRoYXRcbiAgICAgICAgICAgIERPTS5zZXRGaWxlSW5wdXRGaWxlcyBkb2VzIG5vdCBhY3R1YWxseSB1cGRhdGUgdGhlIGZpbGVzIGluIHRoYXQgY2FzZSxcbiAgICAgICAgICAgIHNvIHRoZSBzb2x1dGlvbiBpcyB0byBldmFsIHRoZSBlbGVtZW50IHZhbHVlIHRvIGEgbmV3IEZpbGVMaXN0IGRpcmVjdGx5LlxuICAgICAgICAqL1xuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmV2YWx1YXRlKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5maWxlcyA9IG5ldyBEYXRhVHJhbnNmZXIoKS5maWxlcztcbiAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCBldmVudHMgZm9yIHRoaXMgY2FzZSBiZWNhdXNlIGl0IHNob3VsZCBiZWhhdmUgYWtpbiB0byBhIHVzZXIgYWN0aW9uLlxuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRE9NLnNldEZpbGVJbnB1dEZpbGVzJywge1xuICAgICAgICAgICAgICAgIG9iamVjdElkLFxuICAgICAgICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzY3JvbGxzIGVsZW1lbnQgaW50byB2aWV3IGlmIG5lZWRlZCwgYW5kIHRoZW4gdXNlc1xuICAgICAqIHtAbGluayBUb3VjaHNjcmVlbi50YXB9IHRvIHRhcCBpbiB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIElmIHRoZSBlbGVtZW50IGlzIGRldGFjaGVkIGZyb20gRE9NLCB0aGUgbWV0aG9kIHRocm93cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBhc3luYyB0YXAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Njcm9sbEludG9WaWV3SWZOZWVkZWQoKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBhd2FpdCB0aGlzLl9jbGlja2FibGVQb2ludCgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYWdlLnRvdWNoc2NyZWVuLnRhcCh4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9mb2N1cyB8IGZvY3VzfSBvbiB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBmb2N1cygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5ldmFsdWF0ZSgoZWxlbWVudCkgPT4gZWxlbWVudC5mb2N1cygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZWxlbWVudCwgYW5kIHRoZW4gc2VuZHMgYSBga2V5ZG93bmAsIGBrZXlwcmVzc2AvYGlucHV0YCwgYW5kXG4gICAgICogYGtleXVwYCBldmVudCBmb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHRleHQuXG4gICAgICpcbiAgICAgKiBUbyBwcmVzcyBhIHNwZWNpYWwga2V5LCBsaWtlIGBDb250cm9sYCBvciBgQXJyb3dEb3duYCxcbiAgICAgKiB1c2Uge0BsaW5rIEVsZW1lbnRIYW5kbGUucHJlc3N9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGF3YWl0IGVsZW1lbnRIYW5kbGUudHlwZSgnSGVsbG8nKTsgLy8gVHlwZXMgaW5zdGFudGx5XG4gICAgICogYXdhaXQgZWxlbWVudEhhbmRsZS50eXBlKCdXb3JsZCcsIHtkZWxheTogMTAwfSk7IC8vIFR5cGVzIHNsb3dlciwgbGlrZSBhIHVzZXJcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogQW4gZXhhbXBsZSBvZiB0eXBpbmcgaW50byBhIHRleHQgZmllbGQgYW5kIHRoZW4gc3VibWl0dGluZyB0aGUgZm9ybTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgZWxlbWVudEhhbmRsZSA9IGF3YWl0IHBhZ2UuJCgnaW5wdXQnKTtcbiAgICAgKiBhd2FpdCBlbGVtZW50SGFuZGxlLnR5cGUoJ3NvbWUgdGV4dCcpO1xuICAgICAqIGF3YWl0IGVsZW1lbnRIYW5kbGUucHJlc3MoJ0VudGVyJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdHlwZSh0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZm9jdXMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGFnZS5rZXlib2FyZC50eXBlKHRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBlbGVtZW50LCBhbmQgdGhlbiB1c2VzIHtAbGluayBLZXlib2FyZC5kb3dufSBhbmQge0BsaW5rIEtleWJvYXJkLnVwfS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgYGtleWAgaXMgYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCBubyBtb2RpZmllciBrZXlzIGJlc2lkZXMgYFNoaWZ0YFxuICAgICAqIGFyZSBiZWluZyBoZWxkIGRvd24sIGEgYGtleXByZXNzYC9gaW5wdXRgIGV2ZW50IHdpbGwgYWxzbyBiZSBnZW5lcmF0ZWQuXG4gICAgICogVGhlIGB0ZXh0YCBvcHRpb24gY2FuIGJlIHNwZWNpZmllZCB0byBmb3JjZSBhbiBpbnB1dCBldmVudCB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBNb2RpZmllciBrZXlzIERPIGFmZmVjdCBgZWxlbWVudEhhbmRsZS5wcmVzc2AuIEhvbGRpbmcgZG93biBgU2hpZnRgXG4gICAgICogd2lsbCB0eXBlIHRoZSB0ZXh0IGluIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiBrZXkgdG8gcHJlc3MsIHN1Y2ggYXMgYEFycm93TGVmdGAuXG4gICAgICogICAgU2VlIHtAbGluayBLZXlJbnB1dH0gZm9yIGEgbGlzdCBvZiBhbGwga2V5IG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXNzKGtleSwgb3B0aW9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLmZvY3VzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BhZ2Uua2V5Ym9hcmQucHJlc3Moa2V5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgbWFpbiBmcmFtZSksXG4gICAgICogb3IgYG51bGxgIGlmIHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGJvdW5kaW5nQm94KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXRCb3hNb2RlbCgpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBxdWFkID0gcmVzdWx0Lm1vZGVsLmJvcmRlcjtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHF1YWRbMF0sIHF1YWRbMl0sIHF1YWRbNF0sIHF1YWRbNl0pO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4ocXVhZFsxXSwgcXVhZFszXSwgcXVhZFs1XSwgcXVhZFs3XSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgocXVhZFswXSwgcXVhZFsyXSwgcXVhZFs0XSwgcXVhZFs2XSkgLSB4O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChxdWFkWzFdLCBxdWFkWzNdLCBxdWFkWzVdLCBxdWFkWzddKSAtIHk7XG4gICAgICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBib3hlcyBvZiB0aGUgZWxlbWVudCwgb3IgYG51bGxgIGlmIHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEJveGVzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBwb2ludHM7XG4gICAgICogRWFjaCBQb2ludCBpcyBhbiBvYmplY3QgYHt4LCB5fWAuIEJveCBwb2ludHMgYXJlIHNvcnRlZCBjbG9jay13aXNlLlxuICAgICAqL1xuICAgIGFzeW5jIGJveE1vZGVsKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXRCb3hNb2RlbCgpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IGNvbnRlbnQsIHBhZGRpbmcsIGJvcmRlciwgbWFyZ2luLCB3aWR0aCwgaGVpZ2h0IH0gPSByZXN1bHQubW9kZWw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLl9mcm9tUHJvdG9jb2xRdWFkKGNvbnRlbnQpLFxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5fZnJvbVByb3RvY29sUXVhZChwYWRkaW5nKSxcbiAgICAgICAgICAgIGJvcmRlcjogdGhpcy5fZnJvbVByb3RvY29sUXVhZChib3JkZXIpLFxuICAgICAgICAgICAgbWFyZ2luOiB0aGlzLl9mcm9tUHJvdG9jb2xRdWFkKG1hcmdpbiksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2Nyb2xscyBlbGVtZW50IGludG8gdmlldyBpZiBuZWVkZWQsIGFuZCB0aGVuIHVzZXNcbiAgICAgKiB7QGxpbmsgUGFnZS5zY3JlZW5zaG90fSB0byB0YWtlIGEgc2NyZWVuc2hvdCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIERPTSwgdGhlIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICovXG4gICAgYXN5bmMgc2NyZWVuc2hvdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IG5lZWRzVmlld3BvcnRSZXNldCA9IGZhbHNlO1xuICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSBhd2FpdCB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIGFzc2VydChib3VuZGluZ0JveCwgJ05vZGUgaXMgZWl0aGVyIG5vdCB2aXNpYmxlIG9yIG5vdCBhbiBIVE1MRWxlbWVudCcpO1xuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuX3BhZ2Uudmlld3BvcnQoKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmXG4gICAgICAgICAgICAoYm91bmRpbmdCb3gud2lkdGggPiB2aWV3cG9ydC53aWR0aCB8fFxuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmhlaWdodCA+IHZpZXdwb3J0LmhlaWdodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdwb3J0ID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh2aWV3cG9ydC53aWR0aCwgTWF0aC5jZWlsKGJvdW5kaW5nQm94LndpZHRoKSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh2aWV3cG9ydC5oZWlnaHQsIE1hdGguY2VpbChib3VuZGluZ0JveC5oZWlnaHQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYWdlLnNldFZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHZpZXdwb3J0LCBuZXdWaWV3cG9ydCkpO1xuICAgICAgICAgICAgbmVlZHNWaWV3cG9ydFJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zY3JvbGxJbnRvVmlld0lmTmVlZGVkKCk7XG4gICAgICAgIGJvdW5kaW5nQm94ID0gYXdhaXQgdGhpcy5ib3VuZGluZ0JveCgpO1xuICAgICAgICBhc3NlcnQoYm91bmRpbmdCb3gsICdOb2RlIGlzIGVpdGhlciBub3QgdmlzaWJsZSBvciBub3QgYW4gSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgYXNzZXJ0KGJvdW5kaW5nQm94LndpZHRoICE9PSAwLCAnTm9kZSBoYXMgMCB3aWR0aC4nKTtcbiAgICAgICAgYXNzZXJ0KGJvdW5kaW5nQm94LmhlaWdodCAhPT0gMCwgJ05vZGUgaGFzIDAgaGVpZ2h0LicpO1xuICAgICAgICBjb25zdCB7IGxheW91dFZpZXdwb3J0OiB7IHBhZ2VYLCBwYWdlWSB9LCB9ID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuZ2V0TGF5b3V0TWV0cmljcycpO1xuICAgICAgICBjb25zdCBjbGlwID0gT2JqZWN0LmFzc2lnbih7fSwgYm91bmRpbmdCb3gpO1xuICAgICAgICBjbGlwLnggKz0gcGFnZVg7XG4gICAgICAgIGNsaXAueSArPSBwYWdlWTtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gYXdhaXQgdGhpcy5fcGFnZS5zY3JlZW5zaG90KE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIGNsaXAsXG4gICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKG5lZWRzVmlld3BvcnRSZXNldClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BhZ2Uuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgICAgICByZXR1cm4gaW1hZ2VEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpdGhpbiB0aGUgcGFnZS4gSWYgbm8gZWxlbWVudCBtYXRjaGVzIHRoZSBzZWxlY3RvcixcbiAgICAgKiB0aGUgcmV0dXJuIHZhbHVlIHJlc29sdmVzIHRvIGBudWxsYC5cbiAgICAgKi9cbiAgICBhc3luYyAkKHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlZFNlbGVjdG9yLCBxdWVyeUhhbmRsZXIgfSA9IGdldFF1ZXJ5SGFuZGxlckFuZFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5SGFuZGxlci5xdWVyeU9uZSh0aGlzLCB1cGRhdGVkU2VsZWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGxgIHdpdGhpbiB0aGUgcGFnZS4gSWYgbm8gZWxlbWVudHMgbWF0Y2ggdGhlIHNlbGVjdG9yLFxuICAgICAqIHRoZSByZXR1cm4gdmFsdWUgcmVzb2x2ZXMgdG8gYFtdYC5cbiAgICAgKi9cbiAgICBhc3luYyAkJChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB7IHVwZGF0ZWRTZWxlY3RvciwgcXVlcnlIYW5kbGVyIH0gPSBnZXRRdWVyeUhhbmRsZXJBbmRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBxdWVyeUhhbmRsZXIucXVlcnlBbGwodGhpcywgdXBkYXRlZFNlbGVjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcnVucyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2l0aGluIHRoZSBlbGVtZW50IGFuZCBwYXNzZXMgaXQgYXNcbiAgICAgKiB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYHBhZ2VGdW5jdGlvbmAuIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCBtYXRjaGluZyBgc2VsZWN0b3JgLFxuICAgICAqIHRoZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogSWYgYHBhZ2VGdW5jdGlvbmAgcmV0dXJucyBhIFByb21pc2UsIHRoZW4gYGZyYW1lLiRldmFsYCB3b3VsZCB3YWl0IGZvciB0aGUgcHJvbWlzZVxuICAgICAqIHRvIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgdHdlZXRIYW5kbGUgPSBhd2FpdCBwYWdlLiQoJy50d2VldCcpO1xuICAgICAqIGV4cGVjdChhd2FpdCB0d2VldEhhbmRsZS4kZXZhbCgnLmxpa2UnLCBub2RlID0+IG5vZGUuaW5uZXJUZXh0KSkudG9CZSgnMTAwJyk7XG4gICAgICogZXhwZWN0KGF3YWl0IHR3ZWV0SGFuZGxlLiRldmFsKCcucmV0d2VldHMnLCBub2RlID0+IG5vZGUuaW5uZXJUZXh0KSkudG9CZSgnMTAnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyAkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRIYW5kbGUgPSBhd2FpdCB0aGlzLiQoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIWVsZW1lbnRIYW5kbGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiBmYWlsZWQgdG8gZmluZCBlbGVtZW50IG1hdGNoaW5nIHNlbGVjdG9yIFwiJHtzZWxlY3Rvcn1cImApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbGVtZW50SGFuZGxlLmV2YWx1YXRlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncyk7XG4gICAgICAgIGF3YWl0IGVsZW1lbnRIYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBgYXNgIGlzIGEgbGl0dGxlIHVuZm9ydHVuYXRlIGJ1dCBoZWxwcyBUUyB1bmRlcnN0YW5kIHRoZSBiZWhhdmlvciBvZlxuICAgICAgICAgKiBgZWxlbWVudEhhbmRsZS5ldmFsdWF0ZWAuIElmIGV2YWx1YXRlIHJldHVybnMgYW4gZWxlbWVudCBpdCB3aWxsIHJldHVybiBhblxuICAgICAgICAgKiBFbGVtZW50SGFuZGxlIGluc3RhbmNlLCByYXRoZXIgdGhhbiB0aGUgcGxhaW4gb2JqZWN0LiBBbGwgdGhlXG4gICAgICAgICAqIFdyYXBFbGVtZW50SGFuZGxlIHR5cGUgZG9lcyBpcyB3cmFwIFJldHVyblR5cGUgaW50b1xuICAgICAgICAgKiBFbGVtZW50SGFuZGxlPFJldHVyblR5cGU+IGlmIGl0IGlzIGFuIEVsZW1lbnRIYW5kbGUsIG9yIGxlYXZlIGl0IGFsb25lIGFzXG4gICAgICAgICAqIFJldHVyblR5cGUgaWYgaXQgaXNuJ3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBydW5zIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsYCB3aXRoaW4gdGhlIGVsZW1lbnQgYW5kIHBhc3NlcyBpdCBhc1xuICAgICAqIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgcGFnZUZ1bmN0aW9uYC4gSWYgdGhlcmUncyBubyBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAsXG4gICAgICogdGhlIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBJZiBgcGFnZUZ1bmN0aW9uYCByZXR1cm5zIGEgUHJvbWlzZSwgdGhlbiBgZnJhbWUuJCRldmFsYCB3b3VsZCB3YWl0IGZvciB0aGVcbiAgICAgKiBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiZmVlZFwiPlxuICAgICAqICAgPGRpdiBjbGFzcz1cInR3ZWV0XCI+SGVsbG8hPC9kaXY+XG4gICAgICogICA8ZGl2IGNsYXNzPVwidHdlZXRcIj5IaSE8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBmZWVkSGFuZGxlID0gYXdhaXQgcGFnZS4kKCcuZmVlZCcpO1xuICAgICAqIGV4cGVjdChhd2FpdCBmZWVkSGFuZGxlLiQkZXZhbCgnLnR3ZWV0Jywgbm9kZXMgPT4gbm9kZXMubWFwKG4gPT4gbi5pbm5lclRleHQpKSlcbiAgICAgKiAgLnRvRXF1YWwoWydIZWxsbyEnLCAnSGkhJ10pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jICQkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlZFNlbGVjdG9yLCBxdWVyeUhhbmRsZXIgfSA9IGdldFF1ZXJ5SGFuZGxlckFuZFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgYXJyYXlIYW5kbGUgPSBhd2FpdCBxdWVyeUhhbmRsZXIucXVlcnlBbGxBcnJheSh0aGlzLCB1cGRhdGVkU2VsZWN0b3IpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcnJheUhhbmRsZS5ldmFsdWF0ZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpO1xuICAgICAgICBhd2FpdCBhcnJheUhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgIC8qIFRoaXMgYGFzYCBleGlzdHMgZm9yIHRoZSBzYW1lIHJlYXNvbiBhcyB0aGUgYGFzYCBpbiAkZXZhbCBhYm92ZS5cbiAgICAgICAgICogU2VlIHRoZSBjb21tZW50IHRoZXJlIGZvciBhIGZ1bGwgZXhwbGFuYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIGV2YWx1YXRlcyB0aGUgWFBhdGggZXhwcmVzc2lvbiByZWxhdGl2ZSB0byB0aGUgZWxlbWVudEhhbmRsZS5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gc3VjaCBlbGVtZW50cywgdGhlIG1ldGhvZCB3aWxsIHJlc29sdmUgdG8gYW4gZW1wdHkgYXJyYXkuXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb24gLSBFeHByZXNzaW9uIHRvIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZXZhbHVhdGUgfCBldmFsdWF0ZX1cbiAgICAgKi9cbiAgICBhc3luYyAkeChleHByZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IGFycmF5SGFuZGxlID0gYXdhaXQgdGhpcy5ldmFsdWF0ZUhhbmRsZSgoZWxlbWVudCwgZXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gZG9jdW1lbnQuZXZhbHVhdGUoZXhwcmVzc2lvbiwgZWxlbWVudCwgbnVsbCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGxldCBpdGVtO1xuICAgICAgICAgICAgd2hpbGUgKChpdGVtID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKSkpXG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfSwgZXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCBhcnJheUhhbmRsZS5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGF3YWl0IGFycmF5SGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudEhhbmRsZSA9IHByb3BlcnR5LmFzRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRIYW5kbGUpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudEhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqL1xuICAgIGFzeW5jIGlzSW50ZXJzZWN0aW5nVmlld3BvcnQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV2YWx1YXRlKGFzeW5jIChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlUmF0aW8gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmlzaWJsZVJhdGlvID4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVF1YWRBcmVhKHF1YWQpIHtcbiAgICAvKiBDb21wdXRlIHN1bSBvZiBhbGwgZGlyZWN0ZWQgYXJlYXMgb2YgYWRqYWNlbnQgdHJpYW5nbGVzXG4gICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2x5Z29uI1NpbXBsZV9wb2x5Z29uc1xuICAgICovXG4gICAgbGV0IGFyZWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwMSA9IHF1YWRbaV07XG4gICAgICAgIGNvbnN0IHAyID0gcXVhZFsoaSArIDEpICUgcXVhZC5sZW5ndGhdO1xuICAgICAgICBhcmVhICs9IChwMS54ICogcDIueSAtIHAyLnggKiBwMS55KSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhhcmVhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpTSGFuZGxlLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhlbHBlciB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IFRpbWVvdXRFcnJvciB9IGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCB7IEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMsIH0gZnJvbSAnLi9GcmFtZU1hbmFnZXIuanMnO1xuaW1wb3J0IHsgTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzIH0gZnJvbSAnLi9OZXR3b3JrTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBDRFBTZXNzaW9uRW1pdHRlZEV2ZW50cyB9IGZyb20gJy4vQ29ubmVjdGlvbi5qcyc7XG5jb25zdCBwdXBwZXRlZXJUb1Byb3RvY29sTGlmZWN5Y2xlID0gbmV3IE1hcChbXG4gICAgWydsb2FkJywgJ2xvYWQnXSxcbiAgICBbJ2RvbWNvbnRlbnRsb2FkZWQnLCAnRE9NQ29udGVudExvYWRlZCddLFxuICAgIFsnbmV0d29ya2lkbGUwJywgJ25ldHdvcmtJZGxlJ10sXG4gICAgWyduZXR3b3JraWRsZTInLCAnbmV0d29ya0FsbW9zdElkbGUnXSxcbl0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIExpZmVjeWNsZVdhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lTWFuYWdlciwgZnJhbWUsIHdhaXRVbnRpbCwgdGltZW91dCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YWl0VW50aWwpKVxuICAgICAgICAgICAgd2FpdFVudGlsID0gd2FpdFVudGlsLnNsaWNlKCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3YWl0VW50aWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgd2FpdFVudGlsID0gW3dhaXRVbnRpbF07XG4gICAgICAgIHRoaXMuX2V4cGVjdGVkTGlmZWN5Y2xlID0gd2FpdFVudGlsLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sRXZlbnQgPSBwdXBwZXRlZXJUb1Byb3RvY29sTGlmZWN5Y2xlLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnQocHJvdG9jb2xFdmVudCwgJ1Vua25vd24gdmFsdWUgZm9yIG9wdGlvbnMud2FpdFVudGlsOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sRXZlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9mcmFtZU1hbmFnZXIgPSBmcmFtZU1hbmFnZXI7XG4gICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMuX2luaXRpYWxMb2FkZXJJZCA9IGZyYW1lLl9sb2FkZXJJZDtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICBoZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcihmcmFtZU1hbmFnZXIuX2NsaWVudCwgQ0RQU2Vzc2lvbkVtaXR0ZWRFdmVudHMuRGlzY29ubmVjdGVkLCAoKSA9PiB0aGlzLl90ZXJtaW5hdGUobmV3IEVycm9yKCdOYXZpZ2F0aW9uIGZhaWxlZCBiZWNhdXNlIGJyb3dzZXIgaGFzIGRpc2Nvbm5lY3RlZCEnKSkpLFxuICAgICAgICAgICAgaGVscGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZnJhbWVNYW5hZ2VyLCBGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkxpZmVjeWNsZUV2ZW50LCB0aGlzLl9jaGVja0xpZmVjeWNsZUNvbXBsZXRlLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgaGVscGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZnJhbWVNYW5hZ2VyLCBGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkZyYW1lTmF2aWdhdGVkV2l0aGluRG9jdW1lbnQsIHRoaXMuX25hdmlnYXRlZFdpdGhpbkRvY3VtZW50LmJpbmQodGhpcykpLFxuICAgICAgICAgICAgaGVscGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZnJhbWVNYW5hZ2VyLCBGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkZyYW1lRGV0YWNoZWQsIHRoaXMuX29uRnJhbWVEZXRhY2hlZC5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGhlbHBlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2ZyYW1lTWFuYWdlci5uZXR3b3JrTWFuYWdlcigpLCBOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVxdWVzdCwgdGhpcy5fb25SZXF1ZXN0LmJpbmQodGhpcykpLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9zYW1lRG9jdW1lbnROYXZpZ2F0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zYW1lRG9jdW1lbnROYXZpZ2F0aW9uQ29tcGxldGVDYWxsYmFjayA9IGZ1bGZpbGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9saWZlY3ljbGVQcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xpZmVjeWNsZUNhbGxiYWNrID0gZnVsZmlsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25ld0RvY3VtZW50TmF2aWdhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbmV3RG9jdW1lbnROYXZpZ2F0aW9uQ29tcGxldGVDYWxsYmFjayA9IGZ1bGZpbGw7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90aW1lb3V0UHJvbWlzZSA9IHRoaXMuX2NyZWF0ZVRpbWVvdXRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGlvbkNhbGxiYWNrID0gZnVsZmlsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NoZWNrTGlmZWN5Y2xlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgX29uUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmZyYW1lKCkgIT09IHRoaXMuX2ZyYW1lIHx8ICFyZXF1ZXN0LmlzTmF2aWdhdGlvblJlcXVlc3QoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvblJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBfb25GcmFtZURldGFjaGVkKGZyYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0aW9uQ2FsbGJhY2suY2FsbChudWxsLCBuZXcgRXJyb3IoJ05hdmlnYXRpbmcgZnJhbWUgd2FzIGRldGFjaGVkJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrTGlmZWN5Y2xlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgbmF2aWdhdGlvblJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvblJlcXVlc3QgPyB0aGlzLl9uYXZpZ2F0aW9uUmVxdWVzdC5yZXNwb25zZSgpIDogbnVsbDtcbiAgICB9XG4gICAgX3Rlcm1pbmF0ZShlcnJvcikge1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGlvbkNhbGxiYWNrLmNhbGwobnVsbCwgZXJyb3IpO1xuICAgIH1cbiAgICBzYW1lRG9jdW1lbnROYXZpZ2F0aW9uUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbWVEb2N1bWVudE5hdmlnYXRpb25Qcm9taXNlO1xuICAgIH1cbiAgICBuZXdEb2N1bWVudE5hdmlnYXRpb25Qcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3RG9jdW1lbnROYXZpZ2F0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgbGlmZWN5Y2xlUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpZmVjeWNsZVByb21pc2U7XG4gICAgfVxuICAgIHRpbWVvdXRPclRlcm1pbmF0aW9uUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbdGhpcy5fdGltZW91dFByb21pc2UsIHRoaXMuX3Rlcm1pbmF0aW9uUHJvbWlzZV0pO1xuICAgIH1cbiAgICBfY3JlYXRlVGltZW91dFByb21pc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGltZW91dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnTmF2aWdhdGlvbiB0aW1lb3V0IG9mICcgKyB0aGlzLl90aW1lb3V0ICsgJyBtcyBleGNlZWRlZCc7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4gKHRoaXMuX21heGltdW1UaW1lciA9IHNldFRpbWVvdXQoZnVsZmlsbCwgdGhpcy5fdGltZW91dCkpKS50aGVuKCgpID0+IG5ldyBUaW1lb3V0RXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgfVxuICAgIF9uYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudChmcmFtZSkge1xuICAgICAgICBpZiAoZnJhbWUgIT09IHRoaXMuX2ZyYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9oYXNTYW1lRG9jdW1lbnROYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hlY2tMaWZlY3ljbGVDb21wbGV0ZSgpO1xuICAgIH1cbiAgICBfY2hlY2tMaWZlY3ljbGVDb21wbGV0ZSgpIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IG5hdmlnYXRpb24gdG8gY29tbWl0LlxuICAgICAgICBpZiAoIWNoZWNrTGlmZWN5Y2xlKHRoaXMuX2ZyYW1lLCB0aGlzLl9leHBlY3RlZExpZmVjeWNsZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2xpZmVjeWNsZUNhbGxiYWNrKCk7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZS5fbG9hZGVySWQgPT09IHRoaXMuX2luaXRpYWxMb2FkZXJJZCAmJlxuICAgICAgICAgICAgIXRoaXMuX2hhc1NhbWVEb2N1bWVudE5hdmlnYXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9oYXNTYW1lRG9jdW1lbnROYXZpZ2F0aW9uKVxuICAgICAgICAgICAgdGhpcy5fc2FtZURvY3VtZW50TmF2aWdhdGlvbkNvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lLl9sb2FkZXJJZCAhPT0gdGhpcy5faW5pdGlhbExvYWRlcklkKVxuICAgICAgICAgICAgdGhpcy5fbmV3RG9jdW1lbnROYXZpZ2F0aW9uQ29tcGxldGVDYWxsYmFjaygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshRnJhbWV9IGZyYW1lXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGV4cGVjdGVkTGlmZWN5Y2xlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaWZlY3ljbGUoZnJhbWUsIGV4cGVjdGVkTGlmZWN5Y2xlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV4cGVjdGVkTGlmZWN5Y2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmcmFtZS5fbGlmZWN5Y2xlRXZlbnRzLmhhcyhldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZnJhbWUuY2hpbGRGcmFtZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tMaWZlY3ljbGUoY2hpbGQsIGV4cGVjdGVkTGlmZWN5Y2xlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaGVscGVyLnJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuX2V2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX21heGltdW1UaW1lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlmZWN5Y2xlV2F0Y2hlci5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldHdvcmtDb25kaXRpb25zID0ge1xuICAgICdTbG93IDNHJzoge1xuICAgICAgICBkb3dubG9hZDogKCg1MDAgKiAxMDAwKSAvIDgpICogMC44LFxuICAgICAgICB1cGxvYWQ6ICgoNTAwICogMTAwMCkgLyA4KSAqIDAuOCxcbiAgICAgICAgbGF0ZW5jeTogNDAwICogNSxcbiAgICB9LFxuICAgICdGYXN0IDNHJzoge1xuICAgICAgICBkb3dubG9hZDogKCgxLjYgKiAxMDAwICogMTAwMCkgLyA4KSAqIDAuOSxcbiAgICAgICAgdXBsb2FkOiAoKDc1MCAqIDEwMDApIC8gOCkgKiAwLjksXG4gICAgICAgIGxhdGVuY3k6IDE1MCAqIDMuNzUsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXR3b3JrQ29uZGl0aW9ucy5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIsIGRlYnVnRXJyb3IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBIVFRQUmVxdWVzdCB9IGZyb20gJy4vSFRUUFJlcXVlc3QuanMnO1xuaW1wb3J0IHsgSFRUUFJlc3BvbnNlIH0gZnJvbSAnLi9IVFRQUmVzcG9uc2UuanMnO1xuLyoqXG4gKiBXZSB1c2Ugc3ltYm9scyB0byBwcmV2ZW50IGFueSBleHRlcm5hbCBwYXJ0aWVzIGxpc3RlbmluZyB0byB0aGVzZSBldmVudHMuXG4gKiBUaGV5IGFyZSBpbnRlcm5hbCB0byBQdXBwZXRlZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMgPSB7XG4gICAgUmVxdWVzdDogU3ltYm9sKCdOZXR3b3JrTWFuYWdlci5SZXF1ZXN0JyksXG4gICAgUmVxdWVzdFNlcnZlZEZyb21DYWNoZTogU3ltYm9sKCdOZXR3b3JrTWFuYWdlci5SZXF1ZXN0U2VydmVkRnJvbUNhY2hlJyksXG4gICAgUmVzcG9uc2U6IFN5bWJvbCgnTmV0d29ya01hbmFnZXIuUmVzcG9uc2UnKSxcbiAgICBSZXF1ZXN0RmFpbGVkOiBTeW1ib2woJ05ldHdvcmtNYW5hZ2VyLlJlcXVlc3RGYWlsZWQnKSxcbiAgICBSZXF1ZXN0RmluaXNoZWQ6IFN5bWJvbCgnTmV0d29ya01hbmFnZXIuUmVxdWVzdEZpbmlzaGVkJyksXG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtNYW5hZ2VyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGlnbm9yZUhUVFBTRXJyb3JzLCBmcmFtZU1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlcmUgYXJlIGZvdXIgcG9zc2libGUgb3JkZXJzIG9mIGV2ZW50czpcbiAgICAgICAgICogIEEuIGBfb25SZXF1ZXN0V2lsbEJlU2VudGBcbiAgICAgICAgICogIEIuIGBfb25SZXF1ZXN0V2lsbEJlU2VudGAsIGBfb25SZXF1ZXN0UGF1c2VkYFxuICAgICAgICAgKiAgQy4gYF9vblJlcXVlc3RQYXVzZWRgLCBgX29uUmVxdWVzdFdpbGxCZVNlbnRgXG4gICAgICAgICAqICBELiBgX29uUmVxdWVzdFBhdXNlZGAsIGBfb25SZXF1ZXN0V2lsbEJlU2VudGAsIGBfb25SZXF1ZXN0UGF1c2VkYFxuICAgICAgICAgKiAgICAgKHNlZSBjcmJ1Zy5jb20vMTE5NjAwNClcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGBfb25SZXF1ZXN0YCB3ZSBuZWVkIHRoZSBldmVudCBmcm9tIGBfb25SZXF1ZXN0V2lsbEJlU2VudGAgYW5kXG4gICAgICAgICAqIG9wdGlvbmFsbHkgdGhlIGBpbnRlcmNlcHRpb25JZGAgZnJvbSBgX29uUmVxdWVzdFBhdXNlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHJlcXVlc3QgaW50ZXJjZXB0aW9uIGlzIGRpc2FibGVkLCBjYWxsIGBfb25SZXF1ZXN0YCBvbmNlIHBlciBjYWxsIHRvXG4gICAgICAgICAqIGBfb25SZXF1ZXN0V2lsbEJlU2VudGAuXG4gICAgICAgICAqIElmIHJlcXVlc3QgaW50ZXJjZXB0aW9uIGlzIGVuYWJsZWQsIGNhbGwgYF9vblJlcXVlc3RgIG9uY2UgcGVyIGNhbGwgdG9cbiAgICAgICAgICogYF9vblJlcXVlc3RQYXVzZWRgIChvbmNlIHBlciBgaW50ZXJjZXB0aW9uSWRgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRXZlbnRzIGFyZSBzdG9yZWQgdG8gYWxsb3cgZm9yIHN1YnNlcXVlbnQgZXZlbnRzIHRvIGNhbGwgYF9vblJlcXVlc3RgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgKGNoYWlucyBvZikgcmVkaXJlY3QgcmVxdWVzdHMgaGF2ZSB0aGUgc2FtZSBgcmVxdWVzdElkYCAoISkgYXNcbiAgICAgICAgICogdGhlIG9yaWdpbmFsIHJlcXVlc3QuIFdlIGhhdmUgdG8gYW50aWNpcGF0ZSBzZXJpZXMgb2YgZXZlbnRzIGxpa2UgdGhlc2U6XG4gICAgICAgICAqICBBLiBgX29uUmVxdWVzdFdpbGxCZVNlbnRgLFxuICAgICAgICAgKiAgICAgYF9vblJlcXVlc3RXaWxsQmVTZW50YCwgLi4uXG4gICAgICAgICAqICBCLiBgX29uUmVxdWVzdFdpbGxCZVNlbnRgLCBgX29uUmVxdWVzdFBhdXNlZGAsXG4gICAgICAgICAqICAgICBgX29uUmVxdWVzdFdpbGxCZVNlbnRgLCBgX29uUmVxdWVzdFBhdXNlZGAsIC4uLlxuICAgICAgICAgKiAgQy4gYF9vblJlcXVlc3RXaWxsQmVTZW50YCwgYF9vblJlcXVlc3RQYXVzZWRgLFxuICAgICAgICAgKiAgICAgYF9vblJlcXVlc3RQYXVzZWRgLCBgX29uUmVxdWVzdFdpbGxCZVNlbnRgLCAuLi5cbiAgICAgICAgICogIEQuIGBfb25SZXF1ZXN0UGF1c2VkYCwgYF9vblJlcXVlc3RXaWxsQmVTZW50YCxcbiAgICAgICAgICogICAgIGBfb25SZXF1ZXN0UGF1c2VkYCwgYF9vblJlcXVlc3RXaWxsQmVTZW50YCwgYF9vblJlcXVlc3RQYXVzZWRgLCAuLi5cbiAgICAgICAgICogICAgIChzZWUgY3JidWcuY29tLzExOTYwMDQpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3RXaWxsQmVTZW50RXZlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdFBhdXNlZEV2ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2V4dHJhSFRUUEhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fY3JlZGVudGlhbHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdHRlbXB0ZWRBdXRoZW50aWNhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3VzZXJSZXF1ZXN0SW50ZXJjZXB0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm90b2NvbFJlcXVlc3RJbnRlcmNlcHRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VzZXJDYWNoZURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICBvZmZsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHVwbG9hZDogLTEsXG4gICAgICAgICAgICBkb3dubG9hZDogLTEsXG4gICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX2lnbm9yZUhUVFBTRXJyb3JzID0gaWdub3JlSFRUUFNFcnJvcnM7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlciA9IGZyYW1lTWFuYWdlcjtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdGZXRjaC5yZXF1ZXN0UGF1c2VkJywgdGhpcy5fb25SZXF1ZXN0UGF1c2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ0ZldGNoLmF1dGhSZXF1aXJlZCcsIHRoaXMuX29uQXV0aFJlcXVpcmVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ05ldHdvcmsucmVxdWVzdFdpbGxCZVNlbnQnLCB0aGlzLl9vblJlcXVlc3RXaWxsQmVTZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ05ldHdvcmsucmVxdWVzdFNlcnZlZEZyb21DYWNoZScsIHRoaXMuX29uUmVxdWVzdFNlcnZlZEZyb21DYWNoZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdOZXR3b3JrLnJlc3BvbnNlUmVjZWl2ZWQnLCB0aGlzLl9vblJlc3BvbnNlUmVjZWl2ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2NsaWVudC5vbignTmV0d29yay5sb2FkaW5nRmluaXNoZWQnLCB0aGlzLl9vbkxvYWRpbmdGaW5pc2hlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdOZXR3b3JrLmxvYWRpbmdGYWlsZWQnLCB0aGlzLl9vbkxvYWRpbmdGYWlsZWQuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdOZXR3b3JrLmVuYWJsZScpO1xuICAgICAgICBpZiAodGhpcy5faWdub3JlSFRUUFNFcnJvcnMpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnU2VjdXJpdHkuc2V0SWdub3JlQ2VydGlmaWNhdGVFcnJvcnMnLCB7XG4gICAgICAgICAgICAgICAgaWdub3JlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGF1dGhlbnRpY2F0ZShjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLl9jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVQcm90b2NvbFJlcXVlc3RJbnRlcmNlcHRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0RXh0cmFIVFRQSGVhZGVycyhleHRyYUhUVFBIZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuX2V4dHJhSFRUUEhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZXh0cmFIVFRQSGVhZGVycykpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXh0cmFIVFRQSGVhZGVyc1trZXldO1xuICAgICAgICAgICAgYXNzZXJ0KGhlbHBlci5pc1N0cmluZyh2YWx1ZSksIGBFeHBlY3RlZCB2YWx1ZSBvZiBoZWFkZXIgXCIke2tleX1cIiB0byBiZSBTdHJpbmcsIGJ1dCBcIiR7dHlwZW9mIHZhbHVlfVwiIGlzIGZvdW5kLmApO1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFIVFRQSGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnTmV0d29yay5zZXRFeHRyYUhUVFBIZWFkZXJzJywge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5fZXh0cmFIVFRQSGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4dHJhSFRUUEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9leHRyYUhUVFBIZWFkZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0T2ZmbGluZU1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5vZmZsaW5lID0gdmFsdWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU5ldHdvcmtDb25kaXRpb25zKCk7XG4gICAgfVxuICAgIGFzeW5jIGVtdWxhdGVOZXR3b3JrQ29uZGl0aW9ucyhuZXR3b3JrQ29uZGl0aW9ucykge1xuICAgICAgICB0aGlzLl9lbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLnVwbG9hZCA9IG5ldHdvcmtDb25kaXRpb25zXG4gICAgICAgICAgICA/IG5ldHdvcmtDb25kaXRpb25zLnVwbG9hZFxuICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgdGhpcy5fZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5kb3dubG9hZCA9IG5ldHdvcmtDb25kaXRpb25zXG4gICAgICAgICAgICA/IG5ldHdvcmtDb25kaXRpb25zLmRvd25sb2FkXG4gICAgICAgICAgICA6IC0xO1xuICAgICAgICB0aGlzLl9lbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLmxhdGVuY3kgPSBuZXR3b3JrQ29uZGl0aW9uc1xuICAgICAgICAgICAgPyBuZXR3b3JrQ29uZGl0aW9ucy5sYXRlbmN5XG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU5ldHdvcmtDb25kaXRpb25zKCk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVOZXR3b3JrQ29uZGl0aW9ucygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ05ldHdvcmsuZW11bGF0ZU5ldHdvcmtDb25kaXRpb25zJywge1xuICAgICAgICAgICAgb2ZmbGluZTogdGhpcy5fZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5vZmZsaW5lLFxuICAgICAgICAgICAgbGF0ZW5jeTogdGhpcy5fZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5sYXRlbmN5LFxuICAgICAgICAgICAgdXBsb2FkVGhyb3VnaHB1dDogdGhpcy5fZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy51cGxvYWQsXG4gICAgICAgICAgICBkb3dubG9hZFRocm91Z2hwdXQ6IHRoaXMuX2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMuZG93bmxvYWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXRVc2VyQWdlbnQodXNlckFnZW50KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdOZXR3b3JrLnNldFVzZXJBZ2VudE92ZXJyaWRlJywgeyB1c2VyQWdlbnQgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldENhY2hlRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX3VzZXJDYWNoZURpc2FibGVkID0gIWVuYWJsZWQ7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVByb3RvY29sQ2FjaGVEaXNhYmxlZCgpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSZXF1ZXN0SW50ZXJjZXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VzZXJSZXF1ZXN0SW50ZXJjZXB0aW9uRW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVQcm90b2NvbFJlcXVlc3RJbnRlcmNlcHRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVByb3RvY29sUmVxdWVzdEludGVyY2VwdGlvbigpIHtcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IHRoaXMuX3VzZXJSZXF1ZXN0SW50ZXJjZXB0aW9uRW5hYmxlZCB8fCAhIXRoaXMuX2NyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoZW5hYmxlZCA9PT0gdGhpcy5fcHJvdG9jb2xSZXF1ZXN0SW50ZXJjZXB0aW9uRW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xSZXF1ZXN0SW50ZXJjZXB0aW9uRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvdG9jb2xDYWNoZURpc2FibGVkKCksXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0ZldGNoLmVuYWJsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXV0aFJlcXVlc3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuczogW3sgdXJsUGF0dGVybjogJyonIH1dLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvdG9jb2xDYWNoZURpc2FibGVkKCksXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LnNlbmQoJ0ZldGNoLmRpc2FibGUnKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWNoZURpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckNhY2hlRGlzYWJsZWQ7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVQcm90b2NvbENhY2hlRGlzYWJsZWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdOZXR3b3JrLnNldENhY2hlRGlzYWJsZWQnLCB7XG4gICAgICAgICAgICBjYWNoZURpc2FibGVkOiB0aGlzLl9jYWNoZURpc2FibGVkKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25SZXF1ZXN0V2lsbEJlU2VudChldmVudCkge1xuICAgICAgICAvLyBSZXF1ZXN0IGludGVyY2VwdGlvbiBkb2Vzbid0IGhhcHBlbiBmb3IgZGF0YSBVUkxzIHdpdGggTmV0d29yayBTZXJ2aWNlLlxuICAgICAgICBpZiAodGhpcy5fdXNlclJlcXVlc3RJbnRlcmNlcHRpb25FbmFibGVkICYmXG4gICAgICAgICAgICAhZXZlbnQucmVxdWVzdC51cmwuc3RhcnRzV2l0aCgnZGF0YTonKSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gZXZlbnQucmVxdWVzdElkO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFBhdXNlZEV2ZW50ID0gdGhpcy5fcmVxdWVzdElkVG9SZXF1ZXN0UGF1c2VkRXZlbnQuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3RXaWxsQmVTZW50RXZlbnQuc2V0KHJlcXVlc3RJZCwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXVzZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyY2VwdGlvbklkID0gcmVxdWVzdFBhdXNlZEV2ZW50LnJlcXVlc3RJZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlcXVlc3QoZXZlbnQsIGludGVyY2VwdGlvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3RQYXVzZWRFdmVudC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vblJlcXVlc3QoZXZlbnQsIG51bGwpO1xuICAgIH1cbiAgICBfb25BdXRoUmVxdWlyZWQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gJ0RlZmF1bHQnO1xuICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdGVkQXV0aGVudGljYXRpb25zLmhhcyhldmVudC5yZXF1ZXN0SWQpKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9ICdDYW5jZWxBdXRoJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSAnUHJvdmlkZUNyZWRlbnRpYWxzJztcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRlZEF1dGhlbnRpY2F0aW9ucy5hZGQoZXZlbnQucmVxdWVzdElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9ID0gdGhpcy5fY3JlZGVudGlhbHMgfHwge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgLnNlbmQoJ0ZldGNoLmNvbnRpbnVlV2l0aEF1dGgnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IGV2ZW50LnJlcXVlc3RJZCxcbiAgICAgICAgICAgIGF1dGhDaGFsbGVuZ2VSZXNwb25zZTogeyByZXNwb25zZSwgdXNlcm5hbWUsIHBhc3N3b3JkIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgfVxuICAgIF9vblJlcXVlc3RQYXVzZWQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91c2VyUmVxdWVzdEludGVyY2VwdGlvbkVuYWJsZWQgJiZcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sUmVxdWVzdEludGVyY2VwdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudFxuICAgICAgICAgICAgICAgIC5zZW5kKCdGZXRjaC5jb250aW51ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBldmVudC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChkZWJ1Z0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBldmVudC5uZXR3b3JrSWQ7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdGlvbklkID0gZXZlbnQucmVxdWVzdElkO1xuICAgICAgICBpZiAoIXJlcXVlc3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0V2lsbEJlU2VudEV2ZW50ID0gdGhpcy5fcmVxdWVzdElkVG9SZXF1ZXN0V2lsbEJlU2VudEV2ZW50LmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAvLyByZWRpcmVjdCByZXF1ZXN0cyBoYXZlIHRoZSBzYW1lIGByZXF1ZXN0SWRgLFxuICAgICAgICBpZiAocmVxdWVzdFdpbGxCZVNlbnRFdmVudCAmJlxuICAgICAgICAgICAgKHJlcXVlc3RXaWxsQmVTZW50RXZlbnQucmVxdWVzdC51cmwgIT09IGV2ZW50LnJlcXVlc3QudXJsIHx8XG4gICAgICAgICAgICAgICAgcmVxdWVzdFdpbGxCZVNlbnRFdmVudC5yZXF1ZXN0Lm1ldGhvZCAhPT0gZXZlbnQucmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3RXaWxsQmVTZW50RXZlbnQuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICByZXF1ZXN0V2lsbEJlU2VudEV2ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFdpbGxCZVNlbnRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fb25SZXF1ZXN0KHJlcXVlc3RXaWxsQmVTZW50RXZlbnQsIGludGVyY2VwdGlvbklkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdFdpbGxCZVNlbnRFdmVudC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdFBhdXNlZEV2ZW50LnNldChyZXF1ZXN0SWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXF1ZXN0KGV2ZW50LCBpbnRlcmNlcHRpb25JZCkge1xuICAgICAgICBsZXQgcmVkaXJlY3RDaGFpbiA9IFtdO1xuICAgICAgICBpZiAoZXZlbnQucmVkaXJlY3RSZXNwb25zZSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdC5nZXQoZXZlbnQucmVxdWVzdElkKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvbm5lY3QgbGF0ZSB0byB0aGUgdGFyZ2V0LCB3ZSBjb3VsZCBoYXZlIG1pc3NlZCB0aGVcbiAgICAgICAgICAgIC8vIHJlcXVlc3RXaWxsQmVTZW50IGV2ZW50LlxuICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVSZXF1ZXN0UmVkaXJlY3QocmVxdWVzdCwgZXZlbnQucmVkaXJlY3RSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RDaGFpbiA9IHJlcXVlc3QuX3JlZGlyZWN0Q2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBldmVudC5mcmFtZUlkXG4gICAgICAgICAgICA/IHRoaXMuX2ZyYW1lTWFuYWdlci5mcmFtZShldmVudC5mcmFtZUlkKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEhUVFBSZXF1ZXN0KHRoaXMuX2NsaWVudCwgZnJhbWUsIGludGVyY2VwdGlvbklkLCB0aGlzLl91c2VyUmVxdWVzdEludGVyY2VwdGlvbkVuYWJsZWQsIGV2ZW50LCByZWRpcmVjdENoYWluKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkVG9SZXF1ZXN0LnNldChldmVudC5yZXF1ZXN0SWQsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLmVtaXQoTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlcXVlc3QsIHJlcXVlc3QpO1xuICAgIH1cbiAgICBfb25SZXF1ZXN0U2VydmVkRnJvbUNhY2hlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0SWRUb1JlcXVlc3QuZ2V0KGV2ZW50LnJlcXVlc3RJZCk7XG4gICAgICAgIGlmIChyZXF1ZXN0KVxuICAgICAgICAgICAgcmVxdWVzdC5fZnJvbU1lbW9yeUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KE5ldHdvcmtNYW5hZ2VyRW1pdHRlZEV2ZW50cy5SZXF1ZXN0U2VydmVkRnJvbUNhY2hlLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgX2hhbmRsZVJlcXVlc3RSZWRpcmVjdChyZXF1ZXN0LCByZXNwb25zZVBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgSFRUUFJlc3BvbnNlKHRoaXMuX2NsaWVudCwgcmVxdWVzdCwgcmVzcG9uc2VQYXlsb2FkKTtcbiAgICAgICAgcmVxdWVzdC5fcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcmVxdWVzdC5fcmVkaXJlY3RDaGFpbi5wdXNoKHJlcXVlc3QpO1xuICAgICAgICByZXNwb25zZS5fcmVzb2x2ZUJvZHkobmV3IEVycm9yKCdSZXNwb25zZSBib2R5IGlzIHVuYXZhaWxhYmxlIGZvciByZWRpcmVjdCByZXNwb25zZXMnKSk7XG4gICAgICAgIHRoaXMuX2ZvcmdldFJlcXVlc3QocmVxdWVzdCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmVtaXQoTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlc3BvbnNlLCByZXNwb25zZSk7XG4gICAgICAgIHRoaXMuZW1pdChOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVxdWVzdEZpbmlzaGVkLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgX29uUmVzcG9uc2VSZWNlaXZlZChldmVudCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdElkVG9SZXF1ZXN0LmdldChldmVudC5yZXF1ZXN0SWQpO1xuICAgICAgICAvLyBGaWxlVXBsb2FkIHNlbmRzIGEgcmVzcG9uc2Ugd2l0aG91dCBhIG1hdGNoaW5nIHJlcXVlc3QuXG4gICAgICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgSFRUUFJlc3BvbnNlKHRoaXMuX2NsaWVudCwgcmVxdWVzdCwgZXZlbnQucmVzcG9uc2UpO1xuICAgICAgICByZXF1ZXN0Ll9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLmVtaXQoTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlc3BvbnNlLCByZXNwb25zZSk7XG4gICAgfVxuICAgIF9mb3JnZXRSZXF1ZXN0KHJlcXVlc3QsIGV2ZW50cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXF1ZXN0Ll9yZXF1ZXN0SWQ7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdGlvbklkID0gcmVxdWVzdC5faW50ZXJjZXB0aW9uSWQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdGVkQXV0aGVudGljYXRpb25zLmRlbGV0ZShpbnRlcmNlcHRpb25JZCk7XG4gICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdFdpbGxCZVNlbnRFdmVudC5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdFBhdXNlZEV2ZW50LmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbkxvYWRpbmdGaW5pc2hlZChldmVudCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdElkVG9SZXF1ZXN0LmdldChldmVudC5yZXF1ZXN0SWQpO1xuICAgICAgICAvLyBGb3IgY2VydGFpbiByZXF1ZXN0SWRzIHdlIG5ldmVyIHJlY2VpdmUgcmVxdWVzdFdpbGxCZVNlbnQgZXZlbnQuXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9jcmJ1Zy5jb20vNzUwNDY5XG4gICAgICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVW5kZXIgY2VydGFpbiBjb25kaXRpb25zIHdlIG5ldmVyIGdldCB0aGUgTmV0d29yay5yZXNwb25zZVJlY2VpdmVkXG4gICAgICAgIC8vIGV2ZW50IGZyb20gcHJvdG9jb2wuIEBzZWUgaHR0cHM6Ly9jcmJ1Zy5jb20vODgzNDc1XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlKCkpXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlKCkuX3Jlc29sdmVCb2R5KG51bGwpO1xuICAgICAgICB0aGlzLl9mb3JnZXRSZXF1ZXN0KHJlcXVlc3QsIHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlcXVlc3RGaW5pc2hlZCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIF9vbkxvYWRpbmdGYWlsZWQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RJZFRvUmVxdWVzdC5nZXQoZXZlbnQucmVxdWVzdElkKTtcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gcmVxdWVzdElkcyB3ZSBuZXZlciByZWNlaXZlIHJlcXVlc3RXaWxsQmVTZW50IGV2ZW50LlxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vY3JidWcuY29tLzc1MDQ2OVxuICAgICAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlcXVlc3QuX2ZhaWx1cmVUZXh0ID0gZXZlbnQuZXJyb3JUZXh0O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2UoKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgcmVzcG9uc2UuX3Jlc29sdmVCb2R5KG51bGwpO1xuICAgICAgICB0aGlzLl9mb3JnZXRSZXF1ZXN0KHJlcXVlc3QsIHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlcXVlc3RGYWlsZWQsIHJlcXVlc3QpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldHdvcmtNYW5hZ2VyLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBwYXBlckZvcm1hdHMgPSB7XG4gICAgbGV0dGVyOiB7IHdpZHRoOiA4LjUsIGhlaWdodDogMTEgfSxcbiAgICBsZWdhbDogeyB3aWR0aDogOC41LCBoZWlnaHQ6IDE0IH0sXG4gICAgdGFibG9pZDogeyB3aWR0aDogMTEsIGhlaWdodDogMTcgfSxcbiAgICBsZWRnZXI6IHsgd2lkdGg6IDE3LCBoZWlnaHQ6IDExIH0sXG4gICAgYTA6IHsgd2lkdGg6IDMzLjEsIGhlaWdodDogNDYuOCB9LFxuICAgIGExOiB7IHdpZHRoOiAyMy40LCBoZWlnaHQ6IDMzLjEgfSxcbiAgICBhMjogeyB3aWR0aDogMTYuNTQsIGhlaWdodDogMjMuNCB9LFxuICAgIGEzOiB7IHdpZHRoOiAxMS43LCBoZWlnaHQ6IDE2LjU0IH0sXG4gICAgYTQ6IHsgd2lkdGg6IDguMjcsIGhlaWdodDogMTEuNyB9LFxuICAgIGE1OiB7IHdpZHRoOiA1LjgzLCBoZWlnaHQ6IDguMjcgfSxcbiAgICBhNjogeyB3aWR0aDogNC4xMywgaGVpZ2h0OiA1LjgzIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UERGT3B0aW9ucy5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uLCBDRFBTZXNzaW9uRW1pdHRlZEV2ZW50cywgfSBmcm9tICcuL0Nvbm5lY3Rpb24uanMnO1xuaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSAnLi9EaWFsb2cuanMnO1xuaW1wb3J0IHsgRW11bGF0aW9uTWFuYWdlciB9IGZyb20gJy4vRW11bGF0aW9uTWFuYWdlci5qcyc7XG5pbXBvcnQgeyBGcmFtZU1hbmFnZXIsIEZyYW1lTWFuYWdlckVtaXR0ZWRFdmVudHMsIH0gZnJvbSAnLi9GcmFtZU1hbmFnZXIuanMnO1xuaW1wb3J0IHsgS2V5Ym9hcmQsIE1vdXNlLCBUb3VjaHNjcmVlbiB9IGZyb20gJy4vSW5wdXQuanMnO1xuaW1wb3J0IHsgVHJhY2luZyB9IGZyb20gJy4vVHJhY2luZy5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIsIGRlYnVnRXJyb3IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBDb3ZlcmFnZSB9IGZyb20gJy4vQ292ZXJhZ2UuanMnO1xuaW1wb3J0IHsgV2ViV29ya2VyIH0gZnJvbSAnLi9XZWJXb3JrZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlSlNIYW5kbGUgfSBmcm9tICcuL0pTSGFuZGxlLmpzJztcbmltcG9ydCB7IE5ldHdvcmtNYW5hZ2VyRW1pdHRlZEV2ZW50cywgfSBmcm9tICcuL05ldHdvcmtNYW5hZ2VyLmpzJztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHkgfSBmcm9tICcuL0FjY2Vzc2liaWxpdHkuanMnO1xuaW1wb3J0IHsgVGltZW91dFNldHRpbmdzIH0gZnJvbSAnLi9UaW1lb3V0U2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgRmlsZUNob29zZXIgfSBmcm9tICcuL0ZpbGVDaG9vc2VyLmpzJztcbmltcG9ydCB7IENvbnNvbGVNZXNzYWdlIH0gZnJvbSAnLi9Db25zb2xlTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBwYXBlckZvcm1hdHMgfSBmcm9tICcuL1BERk9wdGlvbnMuanMnO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQuanMnO1xuY2xhc3MgU2NyZWVuc2hvdFRhc2tRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NoYWluID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHBvc3RUYXNrKHRhc2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2hhaW4udGhlbih0YXNrKTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSByZXN1bHQuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIFBhZ2UgcHJvdmlkZXMgbWV0aG9kcyB0byBpbnRlcmFjdCB3aXRoIGEgc2luZ2xlIHRhYiBvclxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9iYWNrZ3JvdW5kX3BhZ2VzIHwgZXh0ZW5zaW9uIGJhY2tncm91bmQgcGFnZX0gaW4gQ2hyb21pdW0uXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBPbmUgQnJvd3NlciBpbnN0YW5jZSBtaWdodCBoYXZlIG11bHRpcGxlIFBhZ2UgaW5zdGFuY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHBhZ2UsIG5hdmlnYXRlcyBpdCB0byBhIFVSTCwgYW5kIHRoZW4gKiBzYXZlcyBhIHNjcmVlbnNob3Q6XG4gKiBgYGBqc1xuICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gKlxuICogKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHB1cHBldGVlci5sYXVuY2goKTtcbiAqICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICogICBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vZXhhbXBsZS5jb20nKTtcbiAqICAgYXdhaXQgcGFnZS5zY3JlZW5zaG90KHtwYXRoOiAnc2NyZWVuc2hvdC5wbmcnfSk7XG4gKiAgIGF3YWl0IGJyb3dzZXIuY2xvc2UoKTtcbiAqIH0pKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgUGFnZSBjbGFzcyBleHRlbmRzIGZyb20gUHVwcGV0ZWVyJ3Mge0BsaW5rIEV2ZW50RW1pdHRlcn0gY2xhc3MgYW5kIHdpbGxcbiAqIGVtaXQgdmFyaW91cyBldmVudHMgd2hpY2ggYXJlIGRvY3VtZW50ZWQgaW4gdGhlIHtAbGluayBQYWdlRW1pdHRlZEV2ZW50c30gZW51bS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhpcyBleGFtcGxlIGxvZ3MgYSBtZXNzYWdlIGZvciBhIHNpbmdsZSBwYWdlIGBsb2FkYCBldmVudDpcbiAqIGBgYGpzXG4gKiBwYWdlLm9uY2UoJ2xvYWQnLCAoKSA9PiBjb25zb2xlLmxvZygnUGFnZSBsb2FkZWQhJykpO1xuICogYGBgXG4gKlxuICogVG8gdW5zdWJzY3JpYmUgZnJvbSBldmVudHMgdXNlIHRoZSBgb2ZmYCBtZXRob2Q6XG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIGxvZ1JlcXVlc3QoaW50ZXJjZXB0ZWRSZXF1ZXN0KSB7XG4gKiAgIGNvbnNvbGUubG9nKCdBIHJlcXVlc3Qgd2FzIG1hZGU6JywgaW50ZXJjZXB0ZWRSZXF1ZXN0LnVybCgpKTtcbiAqIH1cbiAqIHBhZ2Uub24oJ3JlcXVlc3QnLCBsb2dSZXF1ZXN0KTtcbiAqIC8vIFNvbWV0aW1lIGxhdGVyLi4uXG4gKiBwYWdlLm9mZigncmVxdWVzdCcsIGxvZ1JlcXVlc3QpO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHRhcmdldCwgaWdub3JlSFRUUFNFcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRTZXR0aW5ncyA9IG5ldyBUaW1lb3V0U2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5fcGFnZUJpbmRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9qYXZhc2NyaXB0RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3dvcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFRPRE86IGltcHJvdmUgdGhpcyB0eXBlZGVmIC0gaXQncyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBmaWxlIGNob29zZXIgb3JcbiAgICAgICAgLy8gc29tZXRoaW5nP1xuICAgICAgICB0aGlzLl9maWxlQ2hvb3NlckludGVyY2VwdG9ycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX2tleWJvYXJkID0gbmV3IEtleWJvYXJkKGNsaWVudCk7XG4gICAgICAgIHRoaXMuX21vdXNlID0gbmV3IE1vdXNlKGNsaWVudCwgdGhpcy5fa2V5Ym9hcmQpO1xuICAgICAgICB0aGlzLl90b3VjaHNjcmVlbiA9IG5ldyBUb3VjaHNjcmVlbihjbGllbnQsIHRoaXMuX2tleWJvYXJkKTtcbiAgICAgICAgdGhpcy5fYWNjZXNzaWJpbGl0eSA9IG5ldyBBY2Nlc3NpYmlsaXR5KGNsaWVudCk7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlciA9IG5ldyBGcmFtZU1hbmFnZXIoY2xpZW50LCB0aGlzLCBpZ25vcmVIVFRQU0Vycm9ycywgdGhpcy5fdGltZW91dFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5fZW11bGF0aW9uTWFuYWdlciA9IG5ldyBFbXVsYXRpb25NYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHRoaXMuX3RyYWNpbmcgPSBuZXcgVHJhY2luZyhjbGllbnQpO1xuICAgICAgICB0aGlzLl9jb3ZlcmFnZSA9IG5ldyBDb3ZlcmFnZShjbGllbnQpO1xuICAgICAgICB0aGlzLl9zY3JlZW5zaG90VGFza1F1ZXVlID0gbmV3IFNjcmVlbnNob3RUYXNrUXVldWUoKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICAgICAgICBjbGllbnQub24oJ1RhcmdldC5hdHRhY2hlZFRvVGFyZ2V0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0SW5mby50eXBlICE9PSAnd29ya2VyJyAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldEluZm8udHlwZSAhPT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBkZXRhY2ggZnJvbSBzZXJ2aWNlIHdvcmtlcnMsIHRoZXkgd2lsbCBuZXZlciBkaWUuXG4gICAgICAgICAgICAgICAgLy8gV2Ugc3RpbGwgd2FudCB0byBhdHRhY2ggdG8gd29ya2VycyBmb3IgZW1pdHRpbmcgZXZlbnRzLlxuICAgICAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gYXR0YWNoIHRvIGlmcmFtZXMgc28gc2Vzc2lvbnMgbWF5IGludGVyYWN0IHdpdGggdGhlbS5cbiAgICAgICAgICAgICAgICAvLyBXZSBkZXRhY2ggZnJvbSBhbGwgb3RoZXIgdHlwZXMgb3V0IG9mIGFuIGFidW5kYW5jZSBvZiBjYXV0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFzdGVyOmNvbnRlbnQvYnJvd3Nlci9kZXZ0b29scy9kZXZ0b29sc19hZ2VudF9ob3N0X2ltcGwuY2M/cT1mOmRldnRvb2xzJTIwLWY6b3V0JTIwJTIyOjprVHlwZVBhZ2UlNUIlNUQlMjImc3M9Y2hyb21pdW1cbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgYXZhaWxhYmxlIHR5cGVzLlxuICAgICAgICAgICAgICAgIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAuc2VuZCgnVGFyZ2V0LmRldGFjaEZyb21UYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogZXZlbnQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChkZWJ1Z0Vycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gQ29ubmVjdGlvbi5mcm9tU2Vzc2lvbihjbGllbnQpLnNlc3Npb24oZXZlbnQuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXZWJXb3JrZXIoc2Vzc2lvbiwgZXZlbnQudGFyZ2V0SW5mby51cmwsIHRoaXMuX2FkZENvbnNvbGVNZXNzYWdlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZUV4Y2VwdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlcnMuc2V0KGV2ZW50LnNlc3Npb25JZCwgd29ya2VyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIndvcmtlcmNyZWF0ZWRcIiAvKiBXb3JrZXJDcmVhdGVkICovLCB3b3JrZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xpZW50Lm9uKCdUYXJnZXQuZGV0YWNoZWRGcm9tVGFyZ2V0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLl93b3JrZXJzLmdldChldmVudC5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fd29ya2Vycy5kZWxldGUoZXZlbnQuc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIndvcmtlcmRlc3Ryb3llZFwiIC8qIFdvcmtlckRlc3Ryb3llZCAqLywgd29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlci5vbihGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkZyYW1lQXR0YWNoZWQsIChldmVudCkgPT4gdGhpcy5lbWl0KFwiZnJhbWVhdHRhY2hlZFwiIC8qIEZyYW1lQXR0YWNoZWQgKi8sIGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlci5vbihGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkZyYW1lRGV0YWNoZWQsIChldmVudCkgPT4gdGhpcy5lbWl0KFwiZnJhbWVkZXRhY2hlZFwiIC8qIEZyYW1lRGV0YWNoZWQgKi8sIGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlci5vbihGcmFtZU1hbmFnZXJFbWl0dGVkRXZlbnRzLkZyYW1lTmF2aWdhdGVkLCAoZXZlbnQpID0+IHRoaXMuZW1pdChcImZyYW1lbmF2aWdhdGVkXCIgLyogRnJhbWVOYXZpZ2F0ZWQgKi8sIGV2ZW50KSk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtNYW5hZ2VyID0gdGhpcy5fZnJhbWVNYW5hZ2VyLm5ldHdvcmtNYW5hZ2VyKCk7XG4gICAgICAgIG5ldHdvcmtNYW5hZ2VyLm9uKE5ldHdvcmtNYW5hZ2VyRW1pdHRlZEV2ZW50cy5SZXF1ZXN0LCAoZXZlbnQpID0+IHRoaXMuZW1pdChcInJlcXVlc3RcIiAvKiBSZXF1ZXN0ICovLCBldmVudCkpO1xuICAgICAgICBuZXR3b3JrTWFuYWdlci5vbihOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVxdWVzdFNlcnZlZEZyb21DYWNoZSwgKGV2ZW50KSA9PiB0aGlzLmVtaXQoXCJyZXF1ZXN0c2VydmVkZnJvbWNhY2hlXCIgLyogUmVxdWVzdFNlcnZlZEZyb21DYWNoZSAqLywgZXZlbnQpKTtcbiAgICAgICAgbmV0d29ya01hbmFnZXIub24oTmV0d29ya01hbmFnZXJFbWl0dGVkRXZlbnRzLlJlc3BvbnNlLCAoZXZlbnQpID0+IHRoaXMuZW1pdChcInJlc3BvbnNlXCIgLyogUmVzcG9uc2UgKi8sIGV2ZW50KSk7XG4gICAgICAgIG5ldHdvcmtNYW5hZ2VyLm9uKE5ldHdvcmtNYW5hZ2VyRW1pdHRlZEV2ZW50cy5SZXF1ZXN0RmFpbGVkLCAoZXZlbnQpID0+IHRoaXMuZW1pdChcInJlcXVlc3RmYWlsZWRcIiAvKiBSZXF1ZXN0RmFpbGVkICovLCBldmVudCkpO1xuICAgICAgICBuZXR3b3JrTWFuYWdlci5vbihOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVxdWVzdEZpbmlzaGVkLCAoZXZlbnQpID0+IHRoaXMuZW1pdChcInJlcXVlc3RmaW5pc2hlZFwiIC8qIFJlcXVlc3RGaW5pc2hlZCAqLywgZXZlbnQpKTtcbiAgICAgICAgdGhpcy5fZmlsZUNob29zZXJJbnRlcmNlcHRvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNsaWVudC5vbignUGFnZS5kb21Db250ZW50RXZlbnRGaXJlZCcsICgpID0+IHRoaXMuZW1pdChcImRvbWNvbnRlbnRsb2FkZWRcIiAvKiBET01Db250ZW50TG9hZGVkICovKSk7XG4gICAgICAgIGNsaWVudC5vbignUGFnZS5sb2FkRXZlbnRGaXJlZCcsICgpID0+IHRoaXMuZW1pdChcImxvYWRcIiAvKiBMb2FkICovKSk7XG4gICAgICAgIGNsaWVudC5vbignUnVudGltZS5jb25zb2xlQVBJQ2FsbGVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkNvbnNvbGVBUEkoZXZlbnQpKTtcbiAgICAgICAgY2xpZW50Lm9uKCdSdW50aW1lLmJpbmRpbmdDYWxsZWQnLCAoZXZlbnQpID0+IHRoaXMuX29uQmluZGluZ0NhbGxlZChldmVudCkpO1xuICAgICAgICBjbGllbnQub24oJ1BhZ2UuamF2YXNjcmlwdERpYWxvZ09wZW5pbmcnLCAoZXZlbnQpID0+IHRoaXMuX29uRGlhbG9nKGV2ZW50KSk7XG4gICAgICAgIGNsaWVudC5vbignUnVudGltZS5leGNlcHRpb25UaHJvd24nLCAoZXhjZXB0aW9uKSA9PiB0aGlzLl9oYW5kbGVFeGNlcHRpb24oZXhjZXB0aW9uLmV4Y2VwdGlvbkRldGFpbHMpKTtcbiAgICAgICAgY2xpZW50Lm9uKCdJbnNwZWN0b3IudGFyZ2V0Q3Jhc2hlZCcsICgpID0+IHRoaXMuX29uVGFyZ2V0Q3Jhc2hlZCgpKTtcbiAgICAgICAgY2xpZW50Lm9uKCdQZXJmb3JtYW5jZS5tZXRyaWNzJywgKGV2ZW50KSA9PiB0aGlzLl9lbWl0TWV0cmljcyhldmVudCkpO1xuICAgICAgICBjbGllbnQub24oJ0xvZy5lbnRyeUFkZGVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkxvZ0VudHJ5QWRkZWQoZXZlbnQpKTtcbiAgICAgICAgY2xpZW50Lm9uKCdQYWdlLmZpbGVDaG9vc2VyT3BlbmVkJywgKGV2ZW50KSA9PiB0aGlzLl9vbkZpbGVDaG9vc2VyKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5faXNDbG9zZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIiAvKiBDbG9zZSAqLyk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShjbGllbnQsIHRhcmdldCwgaWdub3JlSFRUUFNFcnJvcnMsIGRlZmF1bHRWaWV3cG9ydCkge1xuICAgICAgICBjb25zdCBwYWdlID0gbmV3IFBhZ2UoY2xpZW50LCB0YXJnZXQsIGlnbm9yZUhUVFBTRXJyb3JzKTtcbiAgICAgICAgYXdhaXQgcGFnZS5faW5pdGlhbGl6ZSgpO1xuICAgICAgICBpZiAoZGVmYXVsdFZpZXdwb3J0KVxuICAgICAgICAgICAgYXdhaXQgcGFnZS5zZXRWaWV3cG9ydChkZWZhdWx0Vmlld3BvcnQpO1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgX2luaXRpYWxpemUoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlci5pbml0aWFsaXplKCksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnVGFyZ2V0LnNldEF1dG9BdHRhY2gnLCB7XG4gICAgICAgICAgICAgICAgYXV0b0F0dGFjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3YWl0Rm9yRGVidWdnZXJPblN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUGVyZm9ybWFuY2UuZW5hYmxlJyksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnTG9nLmVuYWJsZScpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgX29uRmlsZUNob29zZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWxlQ2hvb3NlckludGVyY2VwdG9ycy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2ZyYW1lTWFuYWdlci5mcmFtZShldmVudC5mcmFtZUlkKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGZyYW1lLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGF3YWl0IGNvbnRleHQuX2Fkb3B0QmFja2VuZE5vZGVJZChldmVudC5iYWNrZW5kTm9kZUlkKTtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JzID0gQXJyYXkuZnJvbSh0aGlzLl9maWxlQ2hvb3NlckludGVyY2VwdG9ycyk7XG4gICAgICAgIHRoaXMuX2ZpbGVDaG9vc2VySW50ZXJjZXB0b3JzLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IGZpbGVDaG9vc2VyID0gbmV3IEZpbGVDaG9vc2VyKGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiBpbnRlcmNlcHRvcnMpXG4gICAgICAgICAgICBpbnRlcmNlcHRvci5jYWxsKG51bGwsIGZpbGVDaG9vc2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwYWdlIGhhcyBKYXZhU2NyaXB0IGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSmF2YVNjcmlwdEVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qYXZhc2NyaXB0RW5hYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIHBhZ2UgZXZlbnRzLlxuICAgICAqL1xuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIG1ldGhvZCBvbmx5IGV4aXN0cyB0byBkZWZpbmUgdGhlIHR5cGVzOyB3ZSBkZWxlZ2F0ZSB0aGUgaW1wbFxuICAgICAgICAvLyB0byBFdmVudEVtaXR0ZXIuXG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAvLyBOb3RlOiB0aGlzIG1ldGhvZCBvbmx5IGV4aXN0cyB0byBkZWZpbmUgdGhlIHR5cGVzOyB3ZSBkZWxlZ2F0ZSB0aGUgaW1wbFxuICAgICAgICAvLyB0byBFdmVudEVtaXR0ZXIuXG4gICAgICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgd2FpdGluZyBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgYWZ0ZXIgYSBwYWdlIHJlcXVlc3RzIGEgZmlsZSBwaWNrZXIuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvckZpbGVDaG9vc2VyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbGVDaG9vc2VySW50ZXJjZXB0b3JzLnNpemUpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5zZXRJbnRlcmNlcHRGaWxlQ2hvb3NlckRpYWxvZycsIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCkgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCh4KSA9PiAoY2FsbGJhY2sgPSB4KSk7XG4gICAgICAgIHRoaXMuX2ZpbGVDaG9vc2VySW50ZXJjZXB0b3JzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBoZWxwZXJcbiAgICAgICAgICAgIC53YWl0V2l0aFRpbWVvdXQocHJvbWlzZSwgJ3dhaXRpbmcgZm9yIGZpbGUgY2hvb3NlcicsIHRpbWVvdXQpXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9maWxlQ2hvb3NlckludGVyY2VwdG9ycy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYWdlJ3MgZ2VvbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENvbnNpZGVyIHVzaW5nIHtAbGluayBCcm93c2VyQ29udGV4dC5vdmVycmlkZVBlcm1pc3Npb25zfSB0byBncmFudFxuICAgICAqIHBlcm1pc3Npb25zIGZvciB0aGUgcGFnZSB0byByZWFkIGl0cyBnZW9sb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBhd2FpdCBwYWdlLnNldEdlb2xvY2F0aW9uKHtsYXRpdHVkZTogNTkuOTUsIGxvbmdpdHVkZTogMzAuMzE2Njd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZXRHZW9sb2NhdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWNjdXJhY3kgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobG9uZ2l0dWRlIDwgLTE4MCB8fCBsb25naXR1ZGUgPiAxODApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbG9uZ2l0dWRlIFwiJHtsb25naXR1ZGV9XCI6IHByZWNvbmRpdGlvbiAtMTgwIDw9IExPTkdJVFVERSA8PSAxODAgZmFpbGVkLmApO1xuICAgICAgICBpZiAobGF0aXR1ZGUgPCAtOTAgfHwgbGF0aXR1ZGUgPiA5MClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsYXRpdHVkZSBcIiR7bGF0aXR1ZGV9XCI6IHByZWNvbmRpdGlvbiAtOTAgPD0gTEFUSVRVREUgPD0gOTAgZmFpbGVkLmApO1xuICAgICAgICBpZiAoYWNjdXJhY3kgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFjY3VyYWN5IFwiJHthY2N1cmFjeX1cIjogcHJlY29uZGl0aW9uIDAgPD0gQUNDVVJBQ1kgZmFpbGVkLmApO1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRW11bGF0aW9uLnNldEdlb2xvY2F0aW9uT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgICAgIGFjY3VyYWN5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQSB0YXJnZXQgdGhpcyBwYWdlIHdhcyBjcmVhdGVkIGZyb20uXG4gICAgICovXG4gICAgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgYnJvd3NlciB0aGlzIHBhZ2UgYmVsb25ncyB0by5cbiAgICAgKi9cbiAgICBicm93c2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmJyb3dzZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIGJyb3dzZXIgY29udGV4dCB0aGF0IHRoZSBwYWdlIGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5icm93c2VyQ29udGV4dCgpO1xuICAgIH1cbiAgICBfb25UYXJnZXRDcmFzaGVkKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdQYWdlIGNyYXNoZWQhJykpO1xuICAgIH1cbiAgICBfb25Mb2dFbnRyeUFkZGVkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgbGV2ZWwsIHRleHQsIGFyZ3MsIHNvdXJjZSwgdXJsLCBsaW5lTnVtYmVyIH0gPSBldmVudC5lbnRyeTtcbiAgICAgICAgaWYgKGFyZ3MpXG4gICAgICAgICAgICBhcmdzLm1hcCgoYXJnKSA9PiBoZWxwZXIucmVsZWFzZU9iamVjdCh0aGlzLl9jbGllbnQsIGFyZykpO1xuICAgICAgICBpZiAoc291cmNlICE9PSAnd29ya2VyJylcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbnNvbGVcIiAvKiBDb25zb2xlICovLCBuZXcgQ29uc29sZU1lc3NhZ2UobGV2ZWwsIHRleHQsIFtdLCBbeyB1cmwsIGxpbmVOdW1iZXIgfV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2UncyBtYWluIGZyYW1lLlxuICAgICAqL1xuICAgIG1haW5GcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTWFuYWdlci5tYWluRnJhbWUoKTtcbiAgICB9XG4gICAgZ2V0IGtleWJvYXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5Ym9hcmQ7XG4gICAgfVxuICAgIGdldCB0b3VjaHNjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoc2NyZWVuO1xuICAgIH1cbiAgICBnZXQgY292ZXJhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3ZlcmFnZTtcbiAgICB9XG4gICAgZ2V0IHRyYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjaW5nO1xuICAgIH1cbiAgICBnZXQgYWNjZXNzaWJpbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjY2Vzc2liaWxpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBmcmFtZXMgYXR0YWNoZWQgdG8gdGhlIHBhZ2UuXG4gICAgICovXG4gICAgZnJhbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVNYW5hZ2VyLmZyYW1lcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhbGwgb2YgdGhlIGRlZGljYXRlZFxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX1dvcmtlcnNfQVBJIHwgV2ViV29ya2Vyc31cbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIHBhZ2UuXG4gICAgICovXG4gICAgd29ya2VycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fd29ya2Vycy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFdoZXRoZXIgdG8gZW5hYmxlIHJlcXVlc3QgaW50ZXJjZXB0aW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBY3RpdmF0aW5nIHJlcXVlc3QgaW50ZXJjZXB0aW9uIGVuYWJsZXMge0BsaW5rIEhUVFBSZXF1ZXN0LmFib3J0fSxcbiAgICAgKiB7QGxpbmsgSFRUUFJlcXVlc3QuY29udGludWV9IGFuZCB7QGxpbmsgSFRUUFJlcXVlc3QucmVzcG9uZH0gbWV0aG9kcy4gIFRoaXNcbiAgICAgKiBwcm92aWRlcyB0aGUgY2FwYWJpbGl0eSB0byBtb2RpZnkgbmV0d29yayByZXF1ZXN0cyB0aGF0IGFyZSBtYWRlIGJ5IGEgcGFnZS5cbiAgICAgKlxuICAgICAqIE9uY2UgcmVxdWVzdCBpbnRlcmNlcHRpb24gaXMgZW5hYmxlZCwgZXZlcnkgcmVxdWVzdCB3aWxsIHN0YWxsIHVubGVzcyBpdCdzXG4gICAgICogY29udGludWVkLCByZXNwb25kZWQgb3IgYWJvcnRlZDsgb3IgY29tcGxldGVkIHVzaW5nIHRoZSBicm93c2VyIGNhY2hlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBBbiBleGFtcGxlIG9mIGEgbmHDr3ZlIHJlcXVlc3QgaW50ZXJjZXB0b3IgdGhhdCBhYm9ydHMgYWxsIGltYWdlIHJlcXVlc3RzOlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcHVwcGV0ZWVyID0gcmVxdWlyZSgncHVwcGV0ZWVyJyk7XG4gICAgICogKGFzeW5jICgpID0+IHtcbiAgICAgKiAgIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKCk7XG4gICAgICogICBjb25zdCBwYWdlID0gYXdhaXQgYnJvd3Nlci5uZXdQYWdlKCk7XG4gICAgICogICBhd2FpdCBwYWdlLnNldFJlcXVlc3RJbnRlcmNlcHRpb24odHJ1ZSk7XG4gICAgICogICBwYWdlLm9uKCdyZXF1ZXN0JywgaW50ZXJjZXB0ZWRSZXF1ZXN0ID0+IHtcbiAgICAgKiAgICAgaWYgKGludGVyY2VwdGVkUmVxdWVzdC51cmwoKS5lbmRzV2l0aCgnLnBuZycpIHx8XG4gICAgICogICAgICAgICBpbnRlcmNlcHRlZFJlcXVlc3QudXJsKCkuZW5kc1dpdGgoJy5qcGcnKSlcbiAgICAgKiAgICAgICBpbnRlcmNlcHRlZFJlcXVlc3QuYWJvcnQoKTtcbiAgICAgKiAgICAgZWxzZVxuICAgICAqICAgICAgIGludGVyY2VwdGVkUmVxdWVzdC5jb250aW51ZSgpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiAgIGF3YWl0IHBhZ2UuZ290bygnaHR0cHM6Ly9leGFtcGxlLmNvbScpO1xuICAgICAqICAgYXdhaXQgYnJvd3Nlci5jbG9zZSgpO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2V0UmVxdWVzdEludGVyY2VwdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVNYW5hZ2VyLm5ldHdvcmtNYW5hZ2VyKCkuc2V0UmVxdWVzdEludGVyY2VwdGlvbih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBlbmFibGVkIC0gV2hlbiBgdHJ1ZWAsIGVuYWJsZXMgb2ZmbGluZSBtb2RlIGZvciB0aGUgcGFnZS5cbiAgICAgKi9cbiAgICBzZXRPZmZsaW5lTW9kZShlbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZU1hbmFnZXIubmV0d29ya01hbmFnZXIoKS5zZXRPZmZsaW5lTW9kZShlbmFibGVkKTtcbiAgICB9XG4gICAgZW11bGF0ZU5ldHdvcmtDb25kaXRpb25zKG5ldHdvcmtDb25kaXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZU1hbmFnZXJcbiAgICAgICAgICAgIC5uZXR3b3JrTWFuYWdlcigpXG4gICAgICAgICAgICAuZW11bGF0ZU5ldHdvcmtDb25kaXRpb25zKG5ldHdvcmtDb25kaXRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRpbWVvdXQgLSBNYXhpbXVtIG5hdmlnYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdE5hdmlnYXRpb25UaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dFNldHRpbmdzLnNldERlZmF1bHROYXZpZ2F0aW9uVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRpbWVvdXQgLSBNYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIHNldERlZmF1bHRUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dFNldHRpbmdzLnNldERlZmF1bHRUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aXRoaW4gdGhlIHBhZ2UuIElmIG5vIGVsZW1lbnQgbWF0Y2hlcyB0aGVcbiAgICAgKiBzZWxlY3RvciwgdGhlIHJldHVybiB2YWx1ZSByZXNvbHZlcyB0byBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgRnJhbWUuJCB8IFBhZ2UubWFpbkZyYW1lKCkuJChzZWxlY3RvcikgfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAtIEEgYHNlbGVjdG9yYCB0byBxdWVyeSBwYWdlIGZvclxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1NlbGVjdG9ycyB8IHNlbGVjdG9yfVxuICAgICAqIHRvIHF1ZXJ5IHBhZ2UgZm9yLlxuICAgICAqL1xuICAgIGFzeW5jICQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkZyYW1lKCkuJChzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIFBhZ2UuZXZhbHVhdGUgfCBwYWdlLmV2YWx1YXRlfSBhbmRcbiAgICAgKiBgcGFnZS5ldmFsdWF0ZUhhbmRsZWAgaXMgdGhhdCBgZXZhbHVhdGVIYW5kbGVgIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAqIHdyYXBwZWQgaW4gYW4gaW4tcGFnZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBwYWdlLmV2YWx1dGVIYW5kbGVgIHJldHVybnMgYSBQcm9taXNlLCB0aGVcbiAgICAgKiBmdW5jdGlvbiB3aWxsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHBhc3MgYSBzdHJpbmcgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIChhbHRob3VnaCBmdW5jdGlvbnMgYXJlXG4gICAgICogcmVjb21tZW5kZWQgYXMgdGhleSBhcmUgZWFzaWVyIHRvIGRlYnVnIGFuZCB1c2Ugd2l0aCBUeXBlU2NyaXB0KTpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYUhhbmRsZSA9IGF3YWl0IHBhZ2UuZXZhbHVhdGVIYW5kbGUoJ2RvY3VtZW50JylcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICoge0BsaW5rIEpTSGFuZGxlfSBpbnN0YW5jZXMgY2FuIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlIGBwYWdlRnVuY3Rpb25gOlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGFIYW5kbGUgPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlKCgpID0+IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIGNvbnN0IHJlc3VsdEhhbmRsZSA9IGF3YWl0IHBhZ2UuZXZhbHVhdGVIYW5kbGUoYm9keSA9PiBib2R5LmlubmVySFRNTCwgYUhhbmRsZSk7XG4gICAgICogY29uc29sZS5sb2coYXdhaXQgcmVzdWx0SGFuZGxlLmpzb25WYWx1ZSgpKTtcbiAgICAgKiBhd2FpdCByZXN1bHRIYW5kbGUuZGlzcG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTW9zdCBvZiB0aGUgdGltZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB7QGxpbmsgSlNIYW5kbGV9LFxuICAgICAqIGJ1dCBpZiBgcGFnZUZ1bmN0aW9uYCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQsXG4gICAgICogeW91IGluc3RlYWQgZ2V0IGFuIHtAbGluayBFbGVtZW50SGFuZGxlfSBiYWNrOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBidXR0b24gPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlKCgpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpKTtcbiAgICAgKiAvLyBjYW4gY2FsbCBgY2xpY2tgIGJlY2F1c2UgYGJ1dHRvbmAgaXMgYW4gYEVsZW1lbnRIYW5kbGVgXG4gICAgICogYXdhaXQgYnV0dG9uLmNsaWNrKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgVHlwZVNjcmlwdCBkZWZpbml0aW9ucyBhc3N1bWUgdGhhdCBgZXZhbHVhdGVIYW5kbGVgIHJldHVybnNcbiAgICAgKiAgYSBgSlNIYW5kbGVgLCBidXQgaWYgeW91IGtub3cgaXQncyBnb2luZyB0byByZXR1cm4gYW5cbiAgICAgKiBgRWxlbWVudEhhbmRsZWAsIHBhc3MgaXQgYXMgdGhlIGdlbmVyaWMgYXJndW1lbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBidXR0b24gPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlPEVsZW1lbnRIYW5kbGU+KC4uLik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUZ1bmN0aW9uIC0gYSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aXRoaW4gdGhlIHBhZ2VcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHBhZ2VGdW5jdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlSGFuZGxlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5tYWluRnJhbWUoKS5leGVjdXRpb25Db250ZXh0KCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmV2YWx1YXRlSGFuZGxlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGl0ZXJhdGVzIHRoZSBKYXZhU2NyaXB0IGhlYXAgYW5kIGZpbmRzIGFsbCBvYmplY3RzIHdpdGggdGhlXG4gICAgICogZ2l2ZW4gcHJvdG90eXBlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIENyZWF0ZSBhIE1hcCBvYmplY3RcbiAgICAgKiBhd2FpdCBwYWdlLmV2YWx1YXRlKCgpID0+IHdpbmRvdy5tYXAgPSBuZXcgTWFwKCkpO1xuICAgICAqIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgTWFwIG9iamVjdCBwcm90b3R5cGVcbiAgICAgKiBjb25zdCBtYXBQcm90b3R5cGUgPSBhd2FpdCBwYWdlLmV2YWx1YXRlSGFuZGxlKCgpID0+IE1hcC5wcm90b3R5cGUpO1xuICAgICAqIC8vIFF1ZXJ5IGFsbCBtYXAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXlcbiAgICAgKiBjb25zdCBtYXBJbnN0YW5jZXMgPSBhd2FpdCBwYWdlLnF1ZXJ5T2JqZWN0cyhtYXBQcm90b3R5cGUpO1xuICAgICAqIC8vIENvdW50IGFtb3VudCBvZiBtYXAgb2JqZWN0cyBpbiBoZWFwXG4gICAgICogY29uc3QgY291bnQgPSBhd2FpdCBwYWdlLmV2YWx1YXRlKG1hcHMgPT4gbWFwcy5sZW5ndGgsIG1hcEluc3RhbmNlcyk7XG4gICAgICogYXdhaXQgbWFwSW5zdGFuY2VzLmRpc3Bvc2UoKTtcbiAgICAgKiBhd2FpdCBtYXBQcm90b3R5cGUuZGlzcG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBwcm90b3R5cGVIYW5kbGUgLSBhIGhhbmRsZSB0byB0aGUgb2JqZWN0IHByb3RvdHlwZS5cbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeU9iamVjdHMocHJvdG90eXBlSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLm1haW5GcmFtZSgpLmV4ZWN1dGlvbkNvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlPYmplY3RzKHByb3RvdHlwZUhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJ1bnMgYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpdGhpbiB0aGUgcGFnZSBhbmQgcGFzc2VzIHRoZVxuICAgICAqIHJlc3VsdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIElmIG5vIGVsZW1lbnQgaXMgZm91bmQgbWF0Y2hpbmcgYHNlbGVjdG9yYCwgdGhlIG1ldGhvZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogSWYgYHBhZ2VGdW5jdGlvbmAgcmV0dXJucyBhIHByb21pc2UgYCRldmFsYCB3aWxsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvXG4gICAgICogcmVzb2x2ZSBhbmQgdGhlbiByZXR1cm4gaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHNlYXJjaFZhbHVlID0gYXdhaXQgcGFnZS4kZXZhbCgnI3NlYXJjaCcsIGVsID0+IGVsLnZhbHVlKTtcbiAgICAgKiBjb25zdCBwcmVsb2FkSHJlZiA9IGF3YWl0IHBhZ2UuJGV2YWwoJ2xpbmtbcmVsPXByZWxvYWRdJywgZWwgPT4gZWwuaHJlZik7XG4gICAgICogY29uc3QgaHRtbCA9IGF3YWl0IHBhZ2UuJGV2YWwoJy5tYWluLWNvbnRhaW5lcicsIGVsID0+IGVsLm91dGVySFRNTCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtYXkgaGF2ZSB0byBwcm92aWRlIGFuIGV4cGxpY2l0IHR5cGUgdG8gdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgb2YgdGhlIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgdHlwZWQgYXMgYEVsZW1lbnRgLCBidXQgeW91IG1heSBuZWVkIHRvIHByb3ZpZGUgYSBtb3JlXG4gICAgICogc3BlY2lmaWMgc3ViLXR5cGU6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gaWYgeW91IGRvbid0IHByb3ZpZGUgSFRNTElucHV0RWxlbWVudCBoZXJlLCBUUyB3aWxsIGVycm9yXG4gICAgICogLy8gYXMgYHZhbHVlYCBpcyBub3Qgb24gYEVsZW1lbnRgXG4gICAgICogY29uc3Qgc2VhcmNoVmFsdWUgPSBhd2FpdCBwYWdlLiRldmFsKCcjc2VhcmNoJywgKGVsOiBIVE1MSW5wdXRFbGVtZW50KSA9PiBlbC52YWx1ZSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgY29tcGlsZXIgc2hvdWxkIGJlIGFibGUgdG8gaW5mZXIgdGhlIHJldHVybiB0eXBlXG4gICAgICogZnJvbSB0aGUgYHBhZ2VGdW5jdGlvbmAgeW91IHByb3ZpZGUuIElmIGl0IGlzIHVuYWJsZSB0bywgeW91IGNhbiB1c2UgdGhlIGdlbmVyaWNcbiAgICAgKiB0eXBlIHRvIHRlbGwgdGhlIGNvbXBpbGVyIHdoYXQgcmV0dXJuIHR5cGUgeW91IGV4cGVjdCBmcm9tIGAkZXZhbGA6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gVGhlIGNvbXBpbGVyIGNhbiBpbmZlciB0aGUgcmV0dXJuIHR5cGUgaW4gdGhpcyBjYXNlLCBidXQgaWYgaXQgY2FuJ3RcbiAgICAgKiAvLyBvciBpZiB5b3Ugd2FudCB0byBiZSBtb3JlIGV4cGxpY2l0LCBwcm92aWRlIGl0IGFzIHRoZSBnZW5lcmljIHR5cGUuXG4gICAgICogY29uc3Qgc2VhcmNoVmFsdWUgPSBhd2FpdCBwYWdlLiRldmFsPHN0cmluZz4oXG4gICAgICogICcjc2VhcmNoJywgKGVsOiBIVE1MSW5wdXRFbGVtZW50KSA9PiBlbC52YWx1ZVxuICAgICAqICk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3IgLSB0aGVcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnMgfCBzZWxlY3Rvcn1cbiAgICAgKiB0byBxdWVyeSBmb3JcbiAgICAgKiBAcGFyYW0gcGFnZUZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGJlIGV2YWx1YXRlZCBpbiB0aGUgcGFnZSBjb250ZXh0LlxuICAgICAqIFdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHQgb2YgYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpYCBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRocm91Z2ggdG8gYHBhZ2VGdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgYHBhZ2VGdW5jdGlvbmAuIElmIGl0IHJldHVybnMgYW4gZWxlbWVudCBpdFxuICAgICAqIGlzIHdyYXBwZWQgaW4gYW4ge0BsaW5rIEVsZW1lbnRIYW5kbGV9LCBlbHNlIHRoZSByYXcgdmFsdWUgaXRzZWxmIGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgYXN5bmMgJGV2YWwoc2VsZWN0b3IsIHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS4kZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcnVucyBgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlgIHdpdGhpblxuICAgICAqIHRoZSBwYWdlIGFuZCBwYXNzZXMgdGhlIHJlc3VsdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIElmIGBwYWdlRnVuY3Rpb25gIHJldHVybnMgYSBwcm9taXNlIGAkJGV2YWxgIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG9cbiAgICAgKiByZXNvbHZlIGFuZCB0aGVuIHJldHVybiBpdHMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gZ2V0IHRoZSBhbW91bnQgb2YgZGl2cyBvbiB0aGUgcGFnZVxuICAgICAqIGNvbnN0IGRpdkNvdW50ID0gYXdhaXQgcGFnZS4kJGV2YWwoJ2RpdicsIGRpdnMgPT4gZGl2cy5sZW5ndGgpO1xuICAgICAqXG4gICAgICogLy8gZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYWxsIHRoZSBgLm9wdGlvbnNgIGVsZW1lbnRzOlxuICAgICAqIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBwYWdlLiQkZXZhbCgnZGl2ID4gc3Bhbi5vcHRpb25zJywgb3B0aW9ucyA9PiB7XG4gICAgICogICByZXR1cm4gb3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi50ZXh0Q29udGVudClcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG1heSBoYXZlIHRvIHByb3ZpZGUgYW4gZXhwbGljaXQgdHlwZSB0byB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudCBvZiB0aGUgYHBhZ2VGdW5jdGlvbmAuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyB0eXBlZCBhcyBgRWxlbWVudFtdYCwgYnV0IHlvdSBtYXkgbmVlZCB0byBwcm92aWRlIGEgbW9yZVxuICAgICAqIHNwZWNpZmljIHN1Yi10eXBlOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIGlmIHlvdSBkb24ndCBwcm92aWRlIEhUTUxJbnB1dEVsZW1lbnQgaGVyZSwgVFMgd2lsbCBlcnJvclxuICAgICAqIC8vIGFzIGB2YWx1ZWAgaXMgbm90IG9uIGBFbGVtZW50YFxuICAgICAqIGF3YWl0IHBhZ2UuJCRldmFsKCdpbnB1dCcsIChlbGVtZW50czogSFRNTElucHV0RWxlbWVudFtdKSA9PiB7XG4gICAgICogICByZXR1cm4gZWxlbWVudHMubWFwKGUgPT4gZS52YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgY29tcGlsZXIgc2hvdWxkIGJlIGFibGUgdG8gaW5mZXIgdGhlIHJldHVybiB0eXBlXG4gICAgICogZnJvbSB0aGUgYHBhZ2VGdW5jdGlvbmAgeW91IHByb3ZpZGUuIElmIGl0IGlzIHVuYWJsZSB0bywgeW91IGNhbiB1c2UgdGhlIGdlbmVyaWNcbiAgICAgKiB0eXBlIHRvIHRlbGwgdGhlIGNvbXBpbGVyIHdoYXQgcmV0dXJuIHR5cGUgeW91IGV4cGVjdCBmcm9tIGAkJGV2YWxgOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIFRoZSBjb21waWxlciBjYW4gaW5mZXIgdGhlIHJldHVybiB0eXBlIGluIHRoaXMgY2FzZSwgYnV0IGlmIGl0IGNhbid0XG4gICAgICogLy8gb3IgaWYgeW91IHdhbnQgdG8gYmUgbW9yZSBleHBsaWNpdCwgcHJvdmlkZSBpdCBhcyB0aGUgZ2VuZXJpYyB0eXBlLlxuICAgICAqIGNvbnN0IGFsbElucHV0VmFsdWVzID0gYXdhaXQgcGFnZS4kJGV2YWw8c3RyaW5nW10+KFxuICAgICAqICAnaW5wdXQnLCAoZWxlbWVudHM6IEhUTUxJbnB1dEVsZW1lbnRbXSkgPT4gZWxlbWVudHMubWFwKGUgPT4gZS50ZXh0Q29udGVudClcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIC0gdGhlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfU2VsZWN0b3JzIHwgc2VsZWN0b3J9XG4gICAgICogdG8gcXVlcnkgZm9yXG4gICAgICogQHBhcmFtIHBhZ2VGdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byBiZSBldmFsdWF0ZWQgaW4gdGhlIHBhZ2UgY29udGV4dC4gV2lsbFxuICAgICAqIGJlIHBhc3NlZCB0aGUgcmVzdWx0IG9mIGBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKWBcbiAgICAgKiBhcyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0aHJvdWdoIHRvIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBwYWdlRnVuY3Rpb25gLiBJZiBpdCByZXR1cm5zIGFuIGVsZW1lbnQgaXRcbiAgICAgKiBpcyB3cmFwcGVkIGluIGFuIHtAbGluayBFbGVtZW50SGFuZGxlfSwgZWxzZSB0aGUgcmF3IHZhbHVlIGl0c2VsZiBpc1xuICAgICAqIHJldHVybmVkLlxuICAgICAqL1xuICAgIGFzeW5jICQkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLiQkZXZhbChzZWxlY3RvciwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgJCQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkZyYW1lKCkuJCQoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBhc3luYyAkeChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLiR4KGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBubyBVUkxzIGFyZSBzcGVjaWZpZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgY29va2llcyBmb3IgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAqIFVSTC4gSWYgVVJMcyBhcmUgc3BlY2lmaWVkLCBvbmx5IGNvb2tpZXMgZm9yIHRob3NlIFVSTHMgYXJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGNvb2tpZXMoLi4udXJscykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvb2tpZXMgPSAoYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ05ldHdvcmsuZ2V0Q29va2llcycsIHtcbiAgICAgICAgICAgIHVybHM6IHVybHMubGVuZ3RoID8gdXJscyA6IFt0aGlzLnVybCgpXSxcbiAgICAgICAgfSkpLmNvb2tpZXM7XG4gICAgICAgIGNvbnN0IHVuc3VwcG9ydGVkQ29va2llQXR0cmlidXRlcyA9IFsncHJpb3JpdHknXTtcbiAgICAgICAgY29uc3QgZmlsdGVyVW5zdXBwb3J0ZWRBdHRyaWJ1dGVzID0gKGNvb2tpZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHVuc3VwcG9ydGVkQ29va2llQXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICBkZWxldGUgY29va2llW2F0dHJdO1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ29va2llcy5tYXAoZmlsdGVyVW5zdXBwb3J0ZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlQ29va2llKC4uLmNvb2tpZXMpIHtcbiAgICAgICAgY29uc3QgcGFnZVVSTCA9IHRoaXMudXJsKCk7XG4gICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBjb29raWUpO1xuICAgICAgICAgICAgaWYgKCFjb29raWUudXJsICYmIHBhZ2VVUkwuc3RhcnRzV2l0aCgnaHR0cCcpKVxuICAgICAgICAgICAgICAgIGl0ZW0udXJsID0gcGFnZVVSTDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdOZXR3b3JrLmRlbGV0ZUNvb2tpZXMnLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRDb29raWUoLi4uY29va2llcykge1xuICAgICAgICBjb25zdCBwYWdlVVJMID0gdGhpcy51cmwoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRzV2l0aEhUVFAgPSBwYWdlVVJMLnN0YXJ0c1dpdGgoJ2h0dHAnKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBjb29raWVzLm1hcCgoY29va2llKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgY29va2llKTtcbiAgICAgICAgICAgIGlmICghaXRlbS51cmwgJiYgc3RhcnRzV2l0aEhUVFApXG4gICAgICAgICAgICAgICAgaXRlbS51cmwgPSBwYWdlVVJMO1xuICAgICAgICAgICAgYXNzZXJ0KGl0ZW0udXJsICE9PSAnYWJvdXQ6YmxhbmsnLCBgQmxhbmsgcGFnZSBjYW4gbm90IGhhdmUgY29va2llIFwiJHtpdGVtLm5hbWV9XCJgKTtcbiAgICAgICAgICAgIGFzc2VydCghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoLmNhbGwoaXRlbS51cmwgfHwgJycsICdkYXRhOicpLCBgRGF0YSBVUkwgcGFnZSBjYW4gbm90IGhhdmUgY29va2llIFwiJHtpdGVtLm5hbWV9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVDb29raWUoLi4uaXRlbXMpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ05ldHdvcmsuc2V0Q29va2llcycsIHsgY29va2llczogaXRlbXMgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZFNjcmlwdFRhZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLmFkZFNjcmlwdFRhZyhvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkU3R5bGVUYWcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS5hZGRTdHlsZVRhZyhvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwb3NlRnVuY3Rpb24obmFtZSwgcHVwcGV0ZWVyRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhZ2VCaW5kaW5ncy5oYXMobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgcGFnZSBiaW5kaW5nIHdpdGggbmFtZSAke25hbWV9OiB3aW5kb3dbJyR7bmFtZX0nXSBhbHJlYWR5IGV4aXN0cyFgKTtcbiAgICAgICAgdGhpcy5fcGFnZUJpbmRpbmdzLnNldChuYW1lLCBwdXBwZXRlZXJGdW5jdGlvbik7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBoZWxwZXIucGFnZUJpbmRpbmdJbml0U3RyaW5nKCdleHBvc2VkRnVuJywgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdSdW50aW1lLmFkZEJpbmRpbmcnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLmFkZFNjcmlwdFRvRXZhbHVhdGVPbk5ld0RvY3VtZW50Jywge1xuICAgICAgICAgICAgc291cmNlOiBleHByZXNzaW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5mcmFtZXMoKS5tYXAoKGZyYW1lKSA9PiBmcmFtZS5ldmFsdWF0ZShleHByZXNzaW9uKS5jYXRjaChkZWJ1Z0Vycm9yKSkpO1xuICAgIH1cbiAgICBhc3luYyBhdXRoZW50aWNhdGUoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTWFuYWdlci5uZXR3b3JrTWFuYWdlcigpLmF1dGhlbnRpY2F0ZShjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGFzeW5jIHNldEV4dHJhSFRUUEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVNYW5hZ2VyLm5ldHdvcmtNYW5hZ2VyKCkuc2V0RXh0cmFIVFRQSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0VXNlckFnZW50KHVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVNYW5hZ2VyLm5ldHdvcmtNYW5hZ2VyKCkuc2V0VXNlckFnZW50KHVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGFzeW5jIG1ldHJpY3MoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BlcmZvcm1hbmNlLmdldE1ldHJpY3MnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkTWV0cmljc09iamVjdChyZXNwb25zZS5tZXRyaWNzKTtcbiAgICB9XG4gICAgX2VtaXRNZXRyaWNzKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1ldHJpY3NcIiAvKiBNZXRyaWNzICovLCB7XG4gICAgICAgICAgICB0aXRsZTogZXZlbnQudGl0bGUsXG4gICAgICAgICAgICBtZXRyaWNzOiB0aGlzLl9idWlsZE1ldHJpY3NPYmplY3QoZXZlbnQubWV0cmljcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYnVpbGRNZXRyaWNzT2JqZWN0KG1ldHJpY3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbWV0cmljIG9mIG1ldHJpY3MgfHwgW10pIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRNZXRyaWNzLmhhcyhtZXRyaWMubmFtZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W21ldHJpYy5uYW1lXSA9IG1ldHJpYy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfaGFuZGxlRXhjZXB0aW9uKGV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGhlbHBlci5nZXRFeGNlcHRpb25NZXNzYWdlKGV4Y2VwdGlvbkRldGFpbHMpO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVyci5zdGFjayA9ICcnOyAvLyBEb24ndCByZXBvcnQgY2xpZW50c2lkZSBlcnJvciB3aXRoIGEgbm9kZSBzdGFjayBhdHRhY2hlZFxuICAgICAgICB0aGlzLmVtaXQoXCJwYWdlZXJyb3JcIiAvKiBQYWdlRXJyb3IgKi8sIGVycik7XG4gICAgfVxuICAgIGFzeW5jIF9vbkNvbnNvbGVBUEkoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmV4ZWN1dGlvbkNvbnRleHRJZCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRGV2VG9vbHMgcHJvdG9jb2wgc3RvcmVzIHRoZSBsYXN0IDEwMDAgY29uc29sZSBtZXNzYWdlcy4gVGhlc2VcbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzIGFyZSBhbHdheXMgcmVwb3J0ZWQgZXZlbiBmb3IgcmVtb3ZlZCBleGVjdXRpb24gY29udGV4dHMuIEluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UsIHRoZXkgYXJlIG1hcmtlZCB3aXRoIGV4ZWN1dGlvbkNvbnRleHRJZCA9IDAgYW5kIGFyZVxuICAgICAgICAgICAgLy8gcmVwb3J0ZWQgdXBvbiBlbmFibGluZyBSdW50aW1lIGFnZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGVzZSBtZXNzYWdlcyBzaW5jZTpcbiAgICAgICAgICAgIC8vIC0gdGhlcmUncyBubyBleGVjdXRpb24gY29udGV4dCB3ZSBjYW4gdXNlIHRvIG9wZXJhdGUgd2l0aCBtZXNzYWdlXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50c1xuICAgICAgICAgICAgLy8gLSB0aGVzZSBtZXNzYWdlcyBhcmUgcmVwb3J0ZWQgYmVmb3JlIFB1cHBldGVlciBjbGllbnRzIGNhbiBzdWJzY3JpYmVcbiAgICAgICAgICAgIC8vICAgdG8gdGhlICdjb25zb2xlJ1xuICAgICAgICAgICAgLy8gICBwYWdlIGV2ZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3B1cHBldGVlci9wdXBwZXRlZXIvaXNzdWVzLzM4NjVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fZnJhbWVNYW5hZ2VyLmV4ZWN1dGlvbkNvbnRleHRCeUlkKGV2ZW50LmV4ZWN1dGlvbkNvbnRleHRJZCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGV2ZW50LmFyZ3MubWFwKChhcmcpID0+IGNyZWF0ZUpTSGFuZGxlKGNvbnRleHQsIGFyZykpO1xuICAgICAgICB0aGlzLl9hZGRDb25zb2xlTWVzc2FnZShldmVudC50eXBlLCB2YWx1ZXMsIGV2ZW50LnN0YWNrVHJhY2UpO1xuICAgIH1cbiAgICBhc3luYyBfb25CaW5kaW5nQ2FsbGVkKGV2ZW50KSB7XG4gICAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gVGhlIGJpbmRpbmcgd2FzIGVpdGhlciBjYWxsZWQgYnkgc29tZXRoaW5nIGluIHRoZSBwYWdlIG9yIGl0IHdhc1xuICAgICAgICAgICAgLy8gY2FsbGVkIGJlZm9yZSBvdXIgd3JhcHBlciB3YXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlLCBuYW1lLCBzZXEsIGFyZ3MgfSA9IHBheWxvYWQ7XG4gICAgICAgIGlmICh0eXBlICE9PSAnZXhwb3NlZEZ1bicgfHwgIXRoaXMuX3BhZ2VCaW5kaW5ncy5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3BhZ2VCaW5kaW5ncy5nZXQobmFtZSkoLi4uYXJncyk7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gaGVscGVyLnBhZ2VCaW5kaW5nRGVsaXZlclJlc3VsdFN0cmluZyhuYW1lLCBzZXEsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gaGVscGVyLnBhZ2VCaW5kaW5nRGVsaXZlckVycm9yU3RyaW5nKG5hbWUsIHNlcSwgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBoZWxwZXIucGFnZUJpbmRpbmdEZWxpdmVyRXJyb3JWYWx1ZVN0cmluZyhuYW1lLCBzZXEsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGllbnRcbiAgICAgICAgICAgIC5zZW5kKCdSdW50aW1lLmV2YWx1YXRlJywge1xuICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIGNvbnRleHRJZDogZXZlbnQuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGRlYnVnRXJyb3IpO1xuICAgIH1cbiAgICBfYWRkQ29uc29sZU1lc3NhZ2UodHlwZSwgYXJncywgc3RhY2tUcmFjZSkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJDb3VudChcImNvbnNvbGVcIiAvKiBDb25zb2xlICovKSkge1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKChhcmcpID0+IGFyZy5kaXNwb3NlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlT2JqZWN0ID0gYXJnLl9yZW1vdGVPYmplY3Q7XG4gICAgICAgICAgICBpZiAocmVtb3RlT2JqZWN0Lm9iamVjdElkKVxuICAgICAgICAgICAgICAgIHRleHRUb2tlbnMucHVzaChhcmcudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGV4dFRva2Vucy5wdXNoKGhlbHBlci52YWx1ZUZyb21SZW1vdGVPYmplY3QocmVtb3RlT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhY2tUcmFjZUxvY2F0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoc3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsRnJhbWUgb2Ygc3RhY2tUcmFjZS5jYWxsRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tUcmFjZUxvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjYWxsRnJhbWUudXJsLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBjYWxsRnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjYWxsRnJhbWUuY29sdW1uTnVtYmVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgQ29uc29sZU1lc3NhZ2UodHlwZSwgdGV4dFRva2Vucy5qb2luKCcgJyksIGFyZ3MsIHN0YWNrVHJhY2VMb2NhdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25zb2xlXCIgLyogQ29uc29sZSAqLywgbWVzc2FnZSk7XG4gICAgfVxuICAgIF9vbkRpYWxvZyhldmVudCkge1xuICAgICAgICBsZXQgZGlhbG9nVHlwZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHZhbGlkRGlhbG9nVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgICdhbGVydCcsXG4gICAgICAgICAgICAnY29uZmlybScsXG4gICAgICAgICAgICAncHJvbXB0JyxcbiAgICAgICAgICAgICdiZWZvcmV1bmxvYWQnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHZhbGlkRGlhbG9nVHlwZXMuaGFzKGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgICBkaWFsb2dUeXBlID0gZXZlbnQudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZGlhbG9nVHlwZSwgJ1Vua25vd24gamF2YXNjcmlwdCBkaWFsb2cgdHlwZTogJyArIGV2ZW50LnR5cGUpO1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBuZXcgRGlhbG9nKHRoaXMuX2NsaWVudCwgZGlhbG9nVHlwZSwgZXZlbnQubWVzc2FnZSwgZXZlbnQuZGVmYXVsdFByb21wdCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRpYWxvZ1wiIC8qIERpYWxvZyAqLywgZGlhbG9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGRlZmF1bHQgd2hpdGUgYmFja2dyb3VuZFxuICAgICAqL1xuICAgIGFzeW5jIF9yZXNldERlZmF1bHRCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdFbXVsYXRpb24uc2V0RGVmYXVsdEJhY2tncm91bmRDb2xvck92ZXJyaWRlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIGRlZmF1bHQgd2hpdGUgYmFja2dyb3VuZFxuICAgICAqL1xuICAgIGFzeW5jIF9zZXRUcmFuc3BhcmVudEJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXREZWZhdWx0QmFja2dyb3VuZENvbG9yT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICBjb2xvcjogeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLnVybCgpO1xuICAgIH1cbiAgICBhc3luYyBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZnJhbWVNYW5hZ2VyLm1haW5GcmFtZSgpLmNvbnRlbnQoKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0Q29udGVudChodG1sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZnJhbWVNYW5hZ2VyLm1haW5GcmFtZSgpLnNldENvbnRlbnQoaHRtbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdvdG8odXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2ZyYW1lTWFuYWdlci5tYWluRnJhbWUoKS5nb3RvKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlbG9hZChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMud2FpdEZvck5hdmlnYXRpb24ob3B0aW9ucyksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5yZWxvYWQnKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JOYXZpZ2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZnJhbWVNYW5hZ2VyLm1haW5GcmFtZSgpLndhaXRGb3JOYXZpZ2F0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBfc2Vzc2lvbkNsb3NlUHJvbWlzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNjb25uZWN0UHJvbWlzZSlcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHRoaXMuX2NsaWVudC5vbmNlKENEUFNlc3Npb25FbWl0dGVkRXZlbnRzLkRpc2Nvbm5lY3RlZCwgKCkgPT4gZnVsZmlsbChuZXcgRXJyb3IoJ1RhcmdldCBjbG9zZWQnKSkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yUmVxdWVzdCh1cmxPclByZWRpY2F0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCkgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBoZWxwZXIud2FpdEZvckV2ZW50KHRoaXMuX2ZyYW1lTWFuYWdlci5uZXR3b3JrTWFuYWdlcigpLCBOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVxdWVzdCwgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChoZWxwZXIuaXNTdHJpbmcodXJsT3JQcmVkaWNhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxPclByZWRpY2F0ZSA9PT0gcmVxdWVzdC51cmwoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsT3JQcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdXJsT3JQcmVkaWNhdGUocmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRpbWVvdXQsIHRoaXMuX3Nlc3Npb25DbG9zZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JSZXNwb25zZSh1cmxPclByZWRpY2F0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCkgfSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBoZWxwZXIud2FpdEZvckV2ZW50KHRoaXMuX2ZyYW1lTWFuYWdlci5uZXR3b3JrTWFuYWdlcigpLCBOZXR3b3JrTWFuYWdlckVtaXR0ZWRFdmVudHMuUmVzcG9uc2UsIGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGhlbHBlci5pc1N0cmluZyh1cmxPclByZWRpY2F0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE9yUHJlZGljYXRlID09PSByZXNwb25zZS51cmwoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsT3JQcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGF3YWl0IHVybE9yUHJlZGljYXRlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRpbWVvdXQsIHRoaXMuX3Nlc3Npb25DbG9zZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIGdvQmFjayhvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dvKC0xLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ29Gb3J3YXJkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ28oKzEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfZ28oZGVsdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLmdldE5hdmlnYXRpb25IaXN0b3J5Jyk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuY3VycmVudEluZGV4ICsgZGVsdGFdO1xuICAgICAgICBpZiAoIWVudHJ5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMud2FpdEZvck5hdmlnYXRpb24ob3B0aW9ucyksXG4gICAgICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5uYXZpZ2F0ZVRvSGlzdG9yeUVudHJ5JywgeyBlbnRyeUlkOiBlbnRyeS5pZCB9KSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIGFzeW5jIGJyaW5nVG9Gcm9udCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuYnJpbmdUb0Zyb250Jyk7XG4gICAgfVxuICAgIGFzeW5jIGVtdWxhdGUob3B0aW9ucykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KG9wdGlvbnMudmlld3BvcnQpLFxuICAgICAgICAgICAgdGhpcy5zZXRVc2VyQWdlbnQob3B0aW9ucy51c2VyQWdlbnQpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0SmF2YVNjcmlwdEVuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICBpZiAodGhpcy5famF2YXNjcmlwdEVuYWJsZWQgPT09IGVuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2phdmFzY3JpcHRFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXRTY3JpcHRFeGVjdXRpb25EaXNhYmxlZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAhZW5hYmxlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldEJ5cGFzc0NTUChlbmFibGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLnNldEJ5cGFzc0NTUCcsIHsgZW5hYmxlZCB9KTtcbiAgICB9XG4gICAgYXN5bmMgZW11bGF0ZU1lZGlhVHlwZSh0eXBlKSB7XG4gICAgICAgIGFzc2VydCh0eXBlID09PSAnc2NyZWVuJyB8fCB0eXBlID09PSAncHJpbnQnIHx8IHR5cGUgPT09IG51bGwsICdVbnN1cHBvcnRlZCBtZWRpYSB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdFbXVsYXRpb24uc2V0RW11bGF0ZWRNZWRpYScsIHtcbiAgICAgICAgICAgIG1lZGlhOiB0eXBlIHx8ICcnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZW11bGF0ZU1lZGlhRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKGZlYXR1cmVzID09PSBudWxsKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXRFbXVsYXRlZE1lZGlhJywgeyBmZWF0dXJlczogbnVsbCB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5ldmVyeSgobWVkaWFGZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1lZGlhRmVhdHVyZS5uYW1lO1xuICAgICAgICAgICAgICAgIGFzc2VydCgvXig/OnByZWZlcnMtKD86Y29sb3Itc2NoZW1lfHJlZHVjZWQtbW90aW9uKXxjb2xvci1nYW11dCkkLy50ZXN0KG5hbWUpLCAnVW5zdXBwb3J0ZWQgbWVkaWEgZmVhdHVyZTogJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRW11bGF0aW9uLnNldEVtdWxhdGVkTWVkaWEnLCB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZW11bGF0ZVRpbWV6b25lKHRpbWV6b25lSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdFbXVsYXRpb24uc2V0VGltZXpvbmVPdmVycmlkZScsIHtcbiAgICAgICAgICAgICAgICB0aW1lem9uZUlkOiB0aW1lem9uZUlkIHx8ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnSW52YWxpZCB0aW1lem9uZScpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0aW1lem9uZSBJRDogJHt0aW1lem9uZUlkfWApO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW11bGF0ZXMgdGhlIGlkbGUgc3RhdGUuXG4gICAgICogSWYgbm8gYXJndW1lbnRzIHNldCwgY2xlYXJzIGlkbGUgc3RhdGUgZW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHNldCBpZGxlIGVtdWxhdGlvblxuICAgICAqIGF3YWl0IHBhZ2UuZW11bGF0ZUlkbGVTdGF0ZSh7aXNVc2VyQWN0aXZlOiB0cnVlLCBpc1NjcmVlblVubG9ja2VkOiBmYWxzZX0pO1xuICAgICAqXG4gICAgICogLy8gZG8gc29tZSBjaGVja3MgaGVyZVxuICAgICAqIC4uLlxuICAgICAqXG4gICAgICogLy8gY2xlYXIgaWRsZSBlbXVsYXRpb25cbiAgICAgKiBhd2FpdCBwYWdlLmVtdWxhdGVJZGxlU3RhdGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVycmlkZXMgLSBNb2NrIGlkbGUgc3RhdGUuIElmIG5vdCBzZXQsIGNsZWFycyBpZGxlIG92ZXJyaWRlc1xuICAgICAqIEBwYXJhbSBpc1VzZXJBY3RpdmUgLSBNb2NrIGlzVXNlckFjdGl2ZVxuICAgICAqIEBwYXJhbSBpc1NjcmVlblVubG9ja2VkIC0gTW9jayBpc1NjcmVlblVubG9ja2VkXG4gICAgICovXG4gICAgYXN5bmMgZW11bGF0ZUlkbGVTdGF0ZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXRJZGxlT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgaXNVc2VyQWN0aXZlOiBvdmVycmlkZXMuaXNVc2VyQWN0aXZlLFxuICAgICAgICAgICAgICAgIGlzU2NyZWVuVW5sb2NrZWQ6IG92ZXJyaWRlcy5pc1NjcmVlblVubG9ja2VkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRW11bGF0aW9uLmNsZWFySWRsZU92ZXJyaWRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltdWxhdGVzIHRoZSBnaXZlbiB2aXNpb24gZGVmaWNpZW5jeSBvbiB0aGUgcGFnZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwdXBwZXRlZXIgPSByZXF1aXJlKCdwdXBwZXRlZXInKTtcbiAgICAgKlxuICAgICAqIChhc3luYyAoKSA9PiB7XG4gICAgICogICBjb25zdCBicm93c2VyID0gYXdhaXQgcHVwcGV0ZWVyLmxhdW5jaCgpO1xuICAgICAqICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAqICAgYXdhaXQgcGFnZS5nb3RvKCdodHRwczovL3Y4LmRldi9ibG9nLzEwLXllYXJzJyk7XG4gICAgICpcbiAgICAgKiAgIGF3YWl0IHBhZ2UuZW11bGF0ZVZpc2lvbkRlZmljaWVuY3koJ2FjaHJvbWF0b3BzaWEnKTtcbiAgICAgKiAgIGF3YWl0IHBhZ2Uuc2NyZWVuc2hvdCh7IHBhdGg6ICdhY2hyb21hdG9wc2lhLnBuZycgfSk7XG4gICAgICpcbiAgICAgKiAgIGF3YWl0IHBhZ2UuZW11bGF0ZVZpc2lvbkRlZmljaWVuY3koJ2RldXRlcmFub3BpYScpO1xuICAgICAqICAgYXdhaXQgcGFnZS5zY3JlZW5zaG90KHsgcGF0aDogJ2RldXRlcmFub3BpYS5wbmcnIH0pO1xuICAgICAqXG4gICAgICogICBhd2FpdCBwYWdlLmVtdWxhdGVWaXNpb25EZWZpY2llbmN5KCdibHVycmVkVmlzaW9uJyk7XG4gICAgICogICBhd2FpdCBwYWdlLnNjcmVlbnNob3QoeyBwYXRoOiAnYmx1cnJlZC12aXNpb24ucG5nJyB9KTtcbiAgICAgKlxuICAgICAqICAgYXdhaXQgYnJvd3Nlci5jbG9zZSgpO1xuICAgICAqIH0pKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIGRlZmljaWVuY3kgdG8gc2ltdWxhdGUsIG9yIGAnbm9uZSdgIHRvIHJlc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGVtdWxhdGVWaXNpb25EZWZpY2llbmN5KHR5cGUpIHtcbiAgICAgICAgY29uc3QgdmlzaW9uRGVmaWNpZW5jaWVzID0gbmV3IFNldChbXG4gICAgICAgICAgICAnbm9uZScsXG4gICAgICAgICAgICAnYWNocm9tYXRvcHNpYScsXG4gICAgICAgICAgICAnYmx1cnJlZFZpc2lvbicsXG4gICAgICAgICAgICAnZGV1dGVyYW5vcGlhJyxcbiAgICAgICAgICAgICdwcm90YW5vcGlhJyxcbiAgICAgICAgICAgICd0cml0YW5vcGlhJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQoIXR5cGUgfHwgdmlzaW9uRGVmaWNpZW5jaWVzLmhhcyh0eXBlKSwgYFVuc3VwcG9ydGVkIHZpc2lvbiBkZWZpY2llbmN5OiAke3R5cGV9YCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnRW11bGF0aW9uLnNldEVtdWxhdGVkVmlzaW9uRGVmaWNpZW5jeScsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdub25lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgY29uc3QgbmVlZHNSZWxvYWQgPSBhd2FpdCB0aGlzLl9lbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVWaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGlmIChuZWVkc1JlbG9hZClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIHZpZXdwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBFdmFsdWF0ZXMgYSBmdW5jdGlvbiBpbiB0aGUgcGFnZSdzIGNvbnRleHQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYHBhZ2UuZXZhbHV0ZUhhbmRsZWAgcmV0dXJucyBhIFByb21pc2UsIHRoZVxuICAgICAqIGZ1bmN0aW9uIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZyYW1lLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgKiAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoOCAqIDcpO1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIHByaW50cyBcIjU2XCJcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gKGFsdGhvdWdoIGZ1bmN0aW9ucyBhcmVcbiAgICAgKiByZWNvbW1lbmRlZCBhcyB0aGV5IGFyZSBlYXNpZXIgdG8gZGVidWcgYW5kIHVzZSB3aXRoIFR5cGVTY3JpcHQpOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBhSGFuZGxlID0gYXdhaXQgcGFnZS5ldmFsdWF0ZSgnMSArIDInKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvIGdldCB0aGUgYmVzdCBUeXBlU2NyaXB0IGV4cGVyaWVuY2UsIHlvdSBzaG91bGQgcGFzcyBpbiBhcyB0aGVcbiAgICAgKiBnZW5lcmljIHRoZSB0eXBlIG9mIGBwYWdlRnVuY3Rpb25gOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYUhhbmRsZSA9IGF3YWl0IHBhZ2UuZXZhbHVhdGU8KCkgPT4gbnVtYmVyPigoKSA9PiAyKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGxpbmsgRWxlbWVudEhhbmRsZX0gaW5zdGFuY2VzIChpbmNsdWRpbmcge0BsaW5rIEpTSGFuZGxlfXMpIGNhbiBiZSBwYXNzZWRcbiAgICAgKiBhcyBhcmd1bWVudHMgdG8gdGhlIGBwYWdlRnVuY3Rpb25gOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYm9keUhhbmRsZSA9IGF3YWl0IHBhZ2UuJCgnYm9keScpO1xuICAgICAqIGNvbnN0IGh0bWwgPSBhd2FpdCBwYWdlLmV2YWx1YXRlKGJvZHkgPT4gYm9keS5pbm5lckhUTUwsIGJvZHlIYW5kbGUpO1xuICAgICAqIGF3YWl0IGJvZHlIYW5kbGUuZGlzcG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2VGdW5jdGlvbiAtIGEgZnVuY3Rpb24gdGhhdCBpcyBydW4gd2l0aGluIHRoZSBwYWdlXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBwYWdlRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgb2YgYHBhZ2VGdW5jdGlvbmAuXG4gICAgICovXG4gICAgYXN5bmMgZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZU1hbmFnZXIubWFpbkZyYW1lKCkuZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVPbk5ld0RvY3VtZW50KHBhZ2VGdW5jdGlvbiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBoZWxwZXIuZXZhbHVhdGlvblN0cmluZyhwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpO1xuICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQuc2VuZCgnUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudCcsIHtcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldENhY2hlRW5hYmxlZChlbmFibGVkID0gdHJ1ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9mcmFtZU1hbmFnZXIubmV0d29ya01hbmFnZXIoKS5zZXRDYWNoZUVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICAgIGFzeW5jIHNjcmVlbnNob3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBzY3JlZW5zaG90VHlwZSA9IG51bGw7XG4gICAgICAgIC8vIG9wdGlvbnMudHlwZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW5mZXJyaW5nIHRoZSB0eXBlIGZyb20gb3B0aW9ucy5wYXRoXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgbWF5IGJlIGEgMC1sZW5ndGggZmlsZSB3aXRoIG5vIGV4dGVuc2lvbiBjcmVhdGVkIGJlZm9yZWhhbmRcbiAgICAgICAgLy8gKGkuZS4gYXMgYSB0ZW1wIGZpbGUpLlxuICAgICAgICBpZiAob3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBhc3NlcnQob3B0aW9ucy50eXBlID09PSAncG5nJyB8fCBvcHRpb25zLnR5cGUgPT09ICdqcGVnJywgJ1Vua25vd24gb3B0aW9ucy50eXBlIHZhbHVlOiAnICsgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgIHNjcmVlbnNob3RUeXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBmaWxlUGF0aFxuICAgICAgICAgICAgICAgIC5zbGljZShmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpICsgMSlcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24gPT09ICdwbmcnKVxuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RUeXBlID0gJ3BuZyc7XG4gICAgICAgICAgICBlbHNlIGlmIChleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnKVxuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RUeXBlID0gJ2pwZWcnO1xuICAgICAgICAgICAgYXNzZXJ0KHNjcmVlbnNob3RUeXBlLCBgVW5zdXBwb3J0ZWQgc2NyZWVuc2hvdCB0eXBlIGZvciBleHRlbnNpb24gXFxgLiR7ZXh0ZW5zaW9ufVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NyZWVuc2hvdFR5cGUpXG4gICAgICAgICAgICBzY3JlZW5zaG90VHlwZSA9ICdwbmcnO1xuICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5KSB7XG4gICAgICAgICAgICBhc3NlcnQoc2NyZWVuc2hvdFR5cGUgPT09ICdqcGVnJywgJ29wdGlvbnMucXVhbGl0eSBpcyB1bnN1cHBvcnRlZCBmb3IgdGhlICcgK1xuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RUeXBlICtcbiAgICAgICAgICAgICAgICAnIHNjcmVlbnNob3RzJyk7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIG9wdGlvbnMucXVhbGl0eSA9PT0gJ251bWJlcicsICdFeHBlY3RlZCBvcHRpb25zLnF1YWxpdHkgdG8gYmUgYSBudW1iZXIgYnV0IGZvdW5kICcgK1xuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgYXNzZXJ0KE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5xdWFsaXR5KSwgJ0V4cGVjdGVkIG9wdGlvbnMucXVhbGl0eSB0byBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgICAgICBhc3NlcnQob3B0aW9ucy5xdWFsaXR5ID49IDAgJiYgb3B0aW9ucy5xdWFsaXR5IDw9IDEwMCwgJ0V4cGVjdGVkIG9wdGlvbnMucXVhbGl0eSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEwMCAoaW5jbHVzaXZlKSwgZ290ICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KCFvcHRpb25zLmNsaXAgfHwgIW9wdGlvbnMuZnVsbFBhZ2UsICdvcHRpb25zLmNsaXAgYW5kIG9wdGlvbnMuZnVsbFBhZ2UgYXJlIGV4Y2x1c2l2ZScpO1xuICAgICAgICBpZiAob3B0aW9ucy5jbGlwKSB7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIG9wdGlvbnMuY2xpcC54ID09PSAnbnVtYmVyJywgJ0V4cGVjdGVkIG9wdGlvbnMuY2xpcC54IHRvIGJlIGEgbnVtYmVyIGJ1dCBmb3VuZCAnICtcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jbGlwLngpO1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBvcHRpb25zLmNsaXAueSA9PT0gJ251bWJlcicsICdFeHBlY3RlZCBvcHRpb25zLmNsaXAueSB0byBiZSBhIG51bWJlciBidXQgZm91bmQgJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2xpcC55KTtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2Ygb3B0aW9ucy5jbGlwLndpZHRoID09PSAnbnVtYmVyJywgJ0V4cGVjdGVkIG9wdGlvbnMuY2xpcC53aWR0aCB0byBiZSBhIG51bWJlciBidXQgZm91bmQgJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2xpcC53aWR0aCk7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIG9wdGlvbnMuY2xpcC5oZWlnaHQgPT09ICdudW1iZXInLCAnRXhwZWN0ZWQgb3B0aW9ucy5jbGlwLmhlaWdodCB0byBiZSBhIG51bWJlciBidXQgZm91bmQgJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2xpcC5oZWlnaHQpO1xuICAgICAgICAgICAgYXNzZXJ0KG9wdGlvbnMuY2xpcC53aWR0aCAhPT0gMCwgJ0V4cGVjdGVkIG9wdGlvbnMuY2xpcC53aWR0aCBub3QgdG8gYmUgMC4nKTtcbiAgICAgICAgICAgIGFzc2VydChvcHRpb25zLmNsaXAuaGVpZ2h0ICE9PSAwLCAnRXhwZWN0ZWQgb3B0aW9ucy5jbGlwLmhlaWdodCBub3QgdG8gYmUgMC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2NyZWVuc2hvdFRhc2tRdWV1ZS5wb3N0VGFzaygoKSA9PiB0aGlzLl9zY3JlZW5zaG90VGFzayhzY3JlZW5zaG90VHlwZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBfc2NyZWVuc2hvdFRhc2soZm9ybWF0LCBvcHRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdUYXJnZXQuYWN0aXZhdGVUYXJnZXQnLCB7XG4gICAgICAgICAgICB0YXJnZXRJZDogdGhpcy5fdGFyZ2V0Ll90YXJnZXRJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjbGlwID0gb3B0aW9ucy5jbGlwID8gcHJvY2Vzc0NsaXAob3B0aW9ucy5jbGlwKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgY2FwdHVyZUJleW9uZFZpZXdwb3J0ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY2FwdHVyZUJleW9uZFZpZXdwb3J0ID1cbiAgICAgICAgICAgIHR5cGVvZiBjYXB0dXJlQmV5b25kVmlld3BvcnQgPT09ICdib29sZWFuJyA/IGNhcHR1cmVCZXlvbmRWaWV3cG9ydCA6IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zLmZ1bGxQYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuZ2V0TGF5b3V0TWV0cmljcycpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwobWV0cmljcy5jb250ZW50U2l6ZS53aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwobWV0cmljcy5jb250ZW50U2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGNsaXAgZm9yIGZ1bGwgcGFnZS5cbiAgICAgICAgICAgIGNsaXAgPSB7IHg6IDAsIHk6IDAsIHdpZHRoLCBoZWlnaHQsIHNjYWxlOiAxIH07XG4gICAgICAgICAgICBpZiAoIWNhcHR1cmVCZXlvbmRWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNNb2JpbGUgPSBmYWxzZSwgZGV2aWNlU2NhbGVGYWN0b3IgPSAxLCBpc0xhbmRzY2FwZSA9IGZhbHNlLCB9ID0gdGhpcy5fdmlld3BvcnQgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuT3JpZW50YXRpb24gPSBpc0xhbmRzY2FwZVxuICAgICAgICAgICAgICAgICAgICA/IHsgYW5nbGU6IDkwLCB0eXBlOiAnbGFuZHNjYXBlUHJpbWFyeScgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgYW5nbGU6IDAsIHR5cGU6ICdwb3J0cmFpdFByaW1hcnknIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ0VtdWxhdGlvbi5zZXREZXZpY2VNZXRyaWNzT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vYmlsZTogaXNNb2JpbGUsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZVNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5PcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRTZXREZWZhdWx0QmFja2dyb3VuZCA9IG9wdGlvbnMub21pdEJhY2tncm91bmQgJiYgZm9ybWF0ID09PSAncG5nJztcbiAgICAgICAgaWYgKHNob3VsZFNldERlZmF1bHRCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRUcmFuc3BhcmVudEJhY2tncm91bmRDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLmNhcHR1cmVTY3JlZW5zaG90Jywge1xuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgcXVhbGl0eTogb3B0aW9ucy5xdWFsaXR5LFxuICAgICAgICAgICAgY2xpcCxcbiAgICAgICAgICAgIGNhcHR1cmVCZXlvbmRWaWV3cG9ydCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRTZXREZWZhdWx0QmFja2dyb3VuZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVzZXREZWZhdWx0QmFja2dyb3VuZENvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbFBhZ2UgJiYgdGhpcy5fdmlld3BvcnQpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldFZpZXdwb3J0KHRoaXMuX3ZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2Jhc2U2NCdcbiAgICAgICAgICAgID8gcmVzdWx0LmRhdGFcbiAgICAgICAgICAgIDogQnVmZmVyLmZyb20ocmVzdWx0LmRhdGEsICdiYXNlNjQnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjcmVlbnNob3RzIGNhbiBvbmx5IGJlIHdyaXR0ZW4gdG8gYSBmaWxlIHBhdGggaW4gYSBOb2RlIGVudmlyb25tZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnMgPSBhd2FpdCBoZWxwZXIuaW1wb3J0RlNNb2R1bGUoKTtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShvcHRpb25zLnBhdGgsIGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NsaXAoY2xpcCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoY2xpcC54KTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKGNsaXAueSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoY2xpcC53aWR0aCArIGNsaXAueCAtIHgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChjbGlwLmhlaWdodCArIGNsaXAueSAtIHkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGU6IDEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZWVzIGEgUERGIG9mIHRoZSBwYWdlIHdpdGggdGhlIGBwcmludGAgQ1NTIG1lZGlhIHR5cGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIElNUE9SVEFOVDogUERGIGdlbmVyYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lIGhlYWRsZXNzIG1vZGUuXG4gICAgICpcbiAgICAgKiBUbyBnZW5lcmF0ZSBhIFBERiB3aXRoIHRoZSBgc2NyZWVuYCBtZWRpYSB0eXBlLCBjYWxsXG4gICAgICoge0BsaW5rIFBhZ2UuZW11bGF0ZU1lZGlhVHlwZSB8IGBwYWdlLmVtdWxhdGVNZWRpYVR5cGUoJ3NjcmVlbicpYH0gYmVmb3JlXG4gICAgICogY2FsbGluZyBgcGFnZS5wZGYoKWAuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgcGFnZS5wZGYoKWAgZ2VuZXJhdGVzIGEgcGRmIHdpdGggbW9kaWZpZWQgY29sb3JzIGZvciBwcmludGluZy5cbiAgICAgKiBVc2UgdGhlXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy8td2Via2l0LXByaW50LWNvbG9yLWFkanVzdCB8IGAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdGB9XG4gICAgICogcHJvcGVydHkgdG8gZm9yY2UgcmVuZGVyaW5nIG9mIGV4YWN0IGNvbG9ycy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBQREYuXG4gICAgICovXG4gICAgYXN5bmMgcGRmKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHNjYWxlID0gMSwgZGlzcGxheUhlYWRlckZvb3RlciA9IGZhbHNlLCBoZWFkZXJUZW1wbGF0ZSA9ICcnLCBmb290ZXJUZW1wbGF0ZSA9ICcnLCBwcmludEJhY2tncm91bmQgPSBmYWxzZSwgbGFuZHNjYXBlID0gZmFsc2UsIHBhZ2VSYW5nZXMgPSAnJywgcHJlZmVyQ1NTUGFnZVNpemUgPSBmYWxzZSwgbWFyZ2luID0ge30sIHBhdGggPSBudWxsLCBvbWl0QmFja2dyb3VuZCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHBhcGVyV2lkdGggPSA4LjU7XG4gICAgICAgIGxldCBwYXBlckhlaWdodCA9IDExO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHBhcGVyRm9ybWF0c1tvcHRpb25zLmZvcm1hdC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGFzc2VydChmb3JtYXQsICdVbmtub3duIHBhcGVyIGZvcm1hdDogJyArIG9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgICAgIHBhcGVyV2lkdGggPSBmb3JtYXQud2lkdGg7XG4gICAgICAgICAgICBwYXBlckhlaWdodCA9IGZvcm1hdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXBlcldpZHRoID0gY29udmVydFByaW50UGFyYW1ldGVyVG9JbmNoZXMob3B0aW9ucy53aWR0aCkgfHwgcGFwZXJXaWR0aDtcbiAgICAgICAgICAgIHBhcGVySGVpZ2h0ID1cbiAgICAgICAgICAgICAgICBjb252ZXJ0UHJpbnRQYXJhbWV0ZXJUb0luY2hlcyhvcHRpb25zLmhlaWdodCkgfHwgcGFwZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFyZ2luVG9wID0gY29udmVydFByaW50UGFyYW1ldGVyVG9JbmNoZXMobWFyZ2luLnRvcCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWFyZ2luTGVmdCA9IGNvbnZlcnRQcmludFBhcmFtZXRlclRvSW5jaGVzKG1hcmdpbi5sZWZ0KSB8fCAwO1xuICAgICAgICBjb25zdCBtYXJnaW5Cb3R0b20gPSBjb252ZXJ0UHJpbnRQYXJhbWV0ZXJUb0luY2hlcyhtYXJnaW4uYm90dG9tKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXJnaW5SaWdodCA9IGNvbnZlcnRQcmludFBhcmFtZXRlclRvSW5jaGVzKG1hcmdpbi5yaWdodCkgfHwgMDtcbiAgICAgICAgaWYgKG9taXRCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRUcmFuc3BhcmVudEJhY2tncm91bmRDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdQYWdlLnByaW50VG9QREYnLCB7XG4gICAgICAgICAgICB0cmFuc2Zlck1vZGU6ICdSZXR1cm5Bc1N0cmVhbScsXG4gICAgICAgICAgICBsYW5kc2NhcGUsXG4gICAgICAgICAgICBkaXNwbGF5SGVhZGVyRm9vdGVyLFxuICAgICAgICAgICAgaGVhZGVyVGVtcGxhdGUsXG4gICAgICAgICAgICBmb290ZXJUZW1wbGF0ZSxcbiAgICAgICAgICAgIHByaW50QmFja2dyb3VuZCxcbiAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgcGFwZXJXaWR0aCxcbiAgICAgICAgICAgIHBhcGVySGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luVG9wLFxuICAgICAgICAgICAgbWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgbWFyZ2luTGVmdCxcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgcGFnZVJhbmdlcyxcbiAgICAgICAgICAgIHByZWZlckNTU1BhZ2VTaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9taXRCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZXNldERlZmF1bHRCYWNrZ3JvdW5kQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgaGVscGVyLnJlYWRQcm90b2NvbFN0cmVhbSh0aGlzLl9jbGllbnQsIHJlc3VsdC5zdHJlYW0sIHBhdGgpO1xuICAgIH1cbiAgICBhc3luYyB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkZyYW1lKCkudGl0bGUoKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2Uob3B0aW9ucyA9IHsgcnVuQmVmb3JlVW5sb2FkOiB1bmRlZmluZWQgfSkge1xuICAgICAgICBhc3NlcnQoISF0aGlzLl9jbGllbnQuX2Nvbm5lY3Rpb24sICdQcm90b2NvbCBlcnJvcjogQ29ubmVjdGlvbiBjbG9zZWQuIE1vc3QgbGlrZWx5IHRoZSBwYWdlIGhhcyBiZWVuIGNsb3NlZC4nKTtcbiAgICAgICAgY29uc3QgcnVuQmVmb3JlVW5sb2FkID0gISFvcHRpb25zLnJ1bkJlZm9yZVVubG9hZDtcbiAgICAgICAgaWYgKHJ1bkJlZm9yZVVubG9hZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50LnNlbmQoJ1BhZ2UuY2xvc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5fY29ubmVjdGlvbi5zZW5kKCdUYXJnZXQuY2xvc2VUYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHRoaXMuX3RhcmdldC5fdGFyZ2V0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3RhcmdldC5faXNDbG9zZWRQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICBnZXQgbW91c2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VzZTtcbiAgICB9XG4gICAgY2xpY2soc2VsZWN0b3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS5jbGljayhzZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZvY3VzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLmZvY3VzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgaG92ZXIoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkZyYW1lKCkuaG92ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBzZWxlY3Qoc2VsZWN0b3IsIC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS5zZWxlY3Qoc2VsZWN0b3IsIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIHRhcChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS50YXAoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB0eXBlKHNlbGVjdG9yLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLnR5cGUoc2VsZWN0b3IsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYmVoYXZlcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gdGhlIGZpcnN0IHBhcmFtZXRlci4gSWYgaXQncyBhXG4gICAgICogYHN0cmluZ2AsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGBzZWxlY3RvcmAgb3IgYHhwYXRoYCAoaWYgdGhlIHN0cmluZ1xuICAgICAqIHN0YXJ0cyB3aXRoIGAvL2ApLiBUaGlzIG1ldGhvZCB0aGVuIGlzIGEgc2hvcnRjdXQgZm9yXG4gICAgICoge0BsaW5rIFBhZ2Uud2FpdEZvclNlbGVjdG9yfSBvciB7QGxpbmsgUGFnZS53YWl0Rm9yWFBhdGh9LlxuICAgICAqXG4gICAgICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gdGhpcyBtZXRob2QgaXMgYSBzaG9ydGN1dCBmb3JcbiAgICAgKiB7QGxpbmsgUGFnZS53YWl0Rm9yRnVuY3Rpb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgYG51bWJlcmAsIGl0J3MgdHJlYXRlZCBhcyBhIHRpbWVvdXQgaW5cbiAgICAgKiBtaWxsaXNlY29uZHMgYW5kIHRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgYWZ0ZXIgdGhlXG4gICAgICogdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3Rvck9yRnVuY3Rpb25PclRpbWVvdXQgLSBhIHNlbGVjdG9yLCBwcmVkaWNhdGUgb3IgdGltZW91dCB0b1xuICAgICAqIHdhaXQgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9uYWwgd2FpdGluZyBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gYXJndW1lbnRzIHRvIHBhc3MgdG8gYHBhZ2VGdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBEb24ndCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIHRoZSBtb3JlIGV4cGxpY2l0XG4gICAgICogbWV0aG9kcyBhdmFpbGFibGU6IHtAbGluayBQYWdlLndhaXRGb3JTZWxlY3Rvcn0sXG4gICAgICoge0BsaW5rIFBhZ2Uud2FpdEZvclhQYXRofSwge0BsaW5rIFBhZ2Uud2FpdEZvckZ1bmN0aW9ufSBvclxuICAgICAqIHtAbGluayBQYWdlLndhaXRGb3JUaW1lb3V0fS5cbiAgICAgKi9cbiAgICB3YWl0Rm9yKHNlbGVjdG9yT3JGdW5jdGlvbk9yVGltZW91dCwgb3B0aW9ucyA9IHt9LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5GcmFtZSgpLndhaXRGb3Ioc2VsZWN0b3JPckZ1bmN0aW9uT3JUaW1lb3V0LCBvcHRpb25zLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHlvdXIgc2NyaXB0IHRvIHdhaXQgZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEl0J3MgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIG5vdCB3YWl0IGZvciBhIG51bWJlciBvZiBzZWNvbmRzLCBidXQgaW5zdGVhZFxuICAgICAqIHVzZSB7QGxpbmsgUGFnZS53YWl0Rm9yU2VsZWN0b3J9LCB7QGxpbmsgUGFnZS53YWl0Rm9yWFBhdGh9IG9yXG4gICAgICoge0BsaW5rIFBhZ2Uud2FpdEZvckZ1bmN0aW9ufSB0byB3YWl0IGZvciBleGFjdGx5IHRoZSBjb25kaXRpb25zIHlvdSB3YW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIFdhaXQgZm9yIDEgc2Vjb25kOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogYXdhaXQgcGFnZS53YWl0Rm9yVGltZW91dCgxMDAwKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICAgICAqL1xuICAgIHdhaXRGb3JUaW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS53YWl0Rm9yVGltZW91dChtaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICB3YWl0Rm9yU2VsZWN0b3Ioc2VsZWN0b3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS53YWl0Rm9yU2VsZWN0b3Ioc2VsZWN0b3IsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB3YWl0Rm9yWFBhdGgoeHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluRnJhbWUoKS53YWl0Rm9yWFBhdGgoeHBhdGgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB3YWl0Rm9yRnVuY3Rpb24ocGFnZUZ1bmN0aW9uLCBvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkZyYW1lKCkud2FpdEZvckZ1bmN0aW9uKHBhZ2VGdW5jdGlvbiwgb3B0aW9ucywgLi4uYXJncyk7XG4gICAgfVxufVxuY29uc3Qgc3VwcG9ydGVkTWV0cmljcyA9IG5ldyBTZXQoW1xuICAgICdUaW1lc3RhbXAnLFxuICAgICdEb2N1bWVudHMnLFxuICAgICdGcmFtZXMnLFxuICAgICdKU0V2ZW50TGlzdGVuZXJzJyxcbiAgICAnTm9kZXMnLFxuICAgICdMYXlvdXRDb3VudCcsXG4gICAgJ1JlY2FsY1N0eWxlQ291bnQnLFxuICAgICdMYXlvdXREdXJhdGlvbicsXG4gICAgJ1JlY2FsY1N0eWxlRHVyYXRpb24nLFxuICAgICdTY3JpcHREdXJhdGlvbicsXG4gICAgJ1Rhc2tEdXJhdGlvbicsXG4gICAgJ0pTSGVhcFVzZWRTaXplJyxcbiAgICAnSlNIZWFwVG90YWxTaXplJyxcbl0pO1xuY29uc3QgdW5pdFRvUGl4ZWxzID0ge1xuICAgIHB4OiAxLFxuICAgIGluOiA5NixcbiAgICBjbTogMzcuOCxcbiAgICBtbTogMy43OCxcbn07XG5mdW5jdGlvbiBjb252ZXJ0UHJpbnRQYXJhbWV0ZXJUb0luY2hlcyhwYXJhbWV0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IHBpeGVscztcbiAgICBpZiAoaGVscGVyLmlzTnVtYmVyKHBhcmFtZXRlcikpIHtcbiAgICAgICAgLy8gVHJlYXQgbnVtYmVycyBhcyBwaXhlbCB2YWx1ZXMgdG8gYmUgYWxpZ25lZCB3aXRoIHBoYW50b20ncyBwYXBlclNpemUuXG4gICAgICAgIHBpeGVscyA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBwYXJhbWV0ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlbHBlci5pc1N0cmluZyhwYXJhbWV0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gcGFyYW1ldGVyO1xuICAgICAgICBsZXQgdW5pdCA9IHRleHQuc3Vic3RyaW5nKHRleHQubGVuZ3RoIC0gMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHZhbHVlVGV4dCA9ICcnO1xuICAgICAgICBpZiAodW5pdFRvUGl4ZWxzLmhhc093blByb3BlcnR5KHVuaXQpKSB7XG4gICAgICAgICAgICB2YWx1ZVRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiB1bmtub3duIHVuaXQgdHJ5IHRvIHBhcnNlIHRoZSB3aG9sZSBwYXJhbWV0ZXIgYXMgbnVtYmVyIG9mIHBpeGVscy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHBoYW50b20ncyBwYXBlclNpemUgYmVoYXZpb3IuXG4gICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgICAgIHZhbHVlVGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIodmFsdWVUZXh0KTtcbiAgICAgICAgYXNzZXJ0KCFpc05hTih2YWx1ZSksICdGYWlsZWQgdG8gcGFyc2UgcGFyYW1ldGVyIHZhbHVlOiAnICsgdGV4dCk7XG4gICAgICAgIHBpeGVscyA9IHZhbHVlICogdW5pdFRvUGl4ZWxzW3VuaXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWdlLnBkZigpIENhbm5vdCBoYW5kbGUgcGFyYW1ldGVyIHR5cGU6ICcgKyB0eXBlb2YgcGFyYW1ldGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpeGVscyAvIDk2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFnZS5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBwdXBwZXRlZXJFcnJvcnMgfSBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBkZXZpY2VzTWFwIH0gZnJvbSAnLi9EZXZpY2VEZXNjcmlwdG9ycy5qcyc7XG5pbXBvcnQgeyByZWdpc3RlckN1c3RvbVF1ZXJ5SGFuZGxlciwgdW5yZWdpc3RlckN1c3RvbVF1ZXJ5SGFuZGxlciwgY3VzdG9tUXVlcnlIYW5kbGVyTmFtZXMsIGNsZWFyQ3VzdG9tUXVlcnlIYW5kbGVycywgfSBmcm9tICcuL1F1ZXJ5SGFuZGxlci5qcyc7XG5pbXBvcnQgeyBjb25uZWN0VG9Ccm93c2VyIH0gZnJvbSAnLi9Ccm93c2VyQ29ubmVjdG9yLmpzJztcbmltcG9ydCB7IG5ldHdvcmtDb25kaXRpb25zLCB9IGZyb20gJy4vTmV0d29ya0NvbmRpdGlvbnMuanMnO1xuLyoqXG4gKiBUaGUgbWFpbiBQdXBwZXRlZXIgY2xhc3MuXG4gKlxuICogSU1QT1JUQU5UOiBpZiB5b3UgYXJlIHVzaW5nIFB1cHBldGVlciBpbiBhIE5vZGUgZW52aXJvbm1lbnQsIHlvdSB3aWxsIGdldCBhblxuICogaW5zdGFuY2Ugb2Yge0BsaW5rIFB1cHBldGVlck5vZGV9IHdoZW4geW91IGltcG9ydCBvciByZXF1aXJlIGBwdXBwZXRlZXJgLlxuICogVGhhdCBjbGFzcyBleHRlbmRzIGBQdXBwZXRlZXJgLCBzbyBoYXMgYWxsIHRoZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cgYXNcbiAqIHdlbGwgYXMgYWxsIHRoYXQgYXJlIGRlZmluZWQgb24ge0BsaW5rIFB1cHBldGVlck5vZGV9LlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUHVwcGV0ZWVyIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkUHJvZHVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1B1cHBldGVlckNvcmUgPSBzZXR0aW5ncy5pc1B1cHBldGVlckNvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGF0dGFjaGVzIFB1cHBldGVlciB0byBhbiBleGlzdGluZyBicm93c2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gU2V0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zIHRvIHNldCBvbiB0aGUgYnJvd3Nlci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGJyb3dzZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0VG9Ccm93c2VyKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEEgbGlzdCBvZiBkZXZpY2VzIHRvIGJlIHVzZWQgd2l0aCBgcGFnZS5lbXVsYXRlKG9wdGlvbnMpYC4gQWN0dWFsIGxpc3Qgb2YgZGV2aWNlcyBjYW4gYmUgZm91bmQgaW4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wdXBwZXRlZXIvcHVwcGV0ZWVyL2Jsb2IvbWFpbi9zcmMvY29tbW9uL0RldmljZURlc2NyaXB0b3JzLnRzIHwgc3JjL2NvbW1vbi9EZXZpY2VEZXNjcmlwdG9ycy50c30uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBwdXBwZXRlZXIgPSByZXF1aXJlKCdwdXBwZXRlZXInKTtcbiAgICAgKiBjb25zdCBpUGhvbmUgPSBwdXBwZXRlZXIuZGV2aWNlc1snaVBob25lIDYnXTtcbiAgICAgKlxuICAgICAqIChhc3luYyAoKSA9PiB7XG4gICAgICogICBjb25zdCBicm93c2VyID0gYXdhaXQgcHVwcGV0ZWVyLmxhdW5jaCgpO1xuICAgICAqICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAqICAgYXdhaXQgcGFnZS5lbXVsYXRlKGlQaG9uZSk7XG4gICAgICogICBhd2FpdCBwYWdlLmdvdG8oJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20nKTtcbiAgICAgKiAgIC8vIG90aGVyIGFjdGlvbnMuLi5cbiAgICAgKiAgIGF3YWl0IGJyb3dzZXIuY2xvc2UoKTtcbiAgICAgKiB9KSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IGRldmljZXMoKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VzTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogUHVwcGV0ZWVyIG1ldGhvZHMgbWlnaHQgdGhyb3cgZXJyb3JzIGlmIHRoZXkgYXJlIHVuYWJsZSB0byBmdWxmaWxsIGEgcmVxdWVzdC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYHBhZ2Uud2FpdEZvclNlbGVjdG9yKHNlbGVjdG9yWywgb3B0aW9uc10pYCBtaWdodCBmYWlsIGlmXG4gICAgICogdGhlIHNlbGVjdG9yIGRvZXNuJ3QgbWF0Y2ggYW55IG5vZGVzIGR1cmluZyB0aGUgZ2l2ZW4gdGltZWZyYW1lLlxuICAgICAqXG4gICAgICogRm9yIGNlcnRhaW4gdHlwZXMgb2YgZXJyb3JzIFB1cHBldGVlciB1c2VzIHNwZWNpZmljIGVycm9yIGNsYXNzZXMuXG4gICAgICogVGhlc2UgY2xhc3NlcyBhcmUgYXZhaWxhYmxlIHZpYSBgcHVwcGV0ZWVyLmVycm9yc2AuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEFuIGV4YW1wbGUgb2YgaGFuZGxpbmcgYSB0aW1lb3V0IGVycm9yOlxuICAgICAqIGBgYGpzXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGF3YWl0IHBhZ2Uud2FpdEZvclNlbGVjdG9yKCcuZm9vJyk7XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgaWYgKGUgaW5zdGFuY2VvZiBwdXBwZXRlZXIuZXJyb3JzLlRpbWVvdXRFcnJvcikge1xuICAgICAqICAgICAvLyBEbyBzb21ldGhpbmcgaWYgdGhpcyBpcyBhIHRpbWVvdXQuXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiBwdXBwZXRlZXJFcnJvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgbmV0d29yayBjb25kaXRpb25zIHRvIGJlIHVzZWQgd2l0aCBgcGFnZS5lbXVsYXRlTmV0d29ya0NvbmRpdGlvbnMobmV0d29ya0NvbmRpdGlvbnMpYC4gQWN0dWFsIGxpc3Qgb2YgcHJlZGVmaW5lZCBjb25kaXRpb25zIGNhbiBiZSBmb3VuZCBpbiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3B1cHBldGVlci9wdXBwZXRlZXIvYmxvYi9tYWluL3NyYy9jb21tb24vTmV0d29ya0NvbmRpdGlvbnMudHMgfCBzcmMvY29tbW9uL05ldHdvcmtDb25kaXRpb25zLnRzfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHB1cHBldGVlciA9IHJlcXVpcmUoJ3B1cHBldGVlcicpO1xuICAgICAqIGNvbnN0IHNsb3czRyA9IHB1cHBldGVlci5uZXR3b3JrQ29uZGl0aW9uc1snU2xvdyAzRyddO1xuICAgICAqXG4gICAgICogKGFzeW5jICgpID0+IHtcbiAgICAgKiAgIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwdXBwZXRlZXIubGF1bmNoKCk7XG4gICAgICogICBjb25zdCBwYWdlID0gYXdhaXQgYnJvd3Nlci5uZXdQYWdlKCk7XG4gICAgICogICBhd2FpdCBwYWdlLmVtdWxhdGVOZXR3b3JrQ29uZGl0aW9ucyhzbG93M0cpO1xuICAgICAqICAgYXdhaXQgcGFnZS5nb3RvKCdodHRwczovL3d3dy5nb29nbGUuY29tJyk7XG4gICAgICogICAvLyBvdGhlciBhY3Rpb25zLi4uXG4gICAgICogICBhd2FpdCBicm93c2VyLmNsb3NlKCk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBuZXR3b3JrQ29uZGl0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtDb25kaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB7QGxpbmsgQ3VzdG9tUXVlcnlIYW5kbGVyIHwgY3VzdG9tIHF1ZXJ5IGhhbmRsZXJ9LiBBZnRlclxuICAgICAqIHJlZ2lzdHJhdGlvbiwgdGhlIGhhbmRsZXIgY2FuIGJlIHVzZWQgZXZlcnl3aGVyZSB3aGVyZSBhIHNlbGVjdG9yIGlzXG4gICAgICogZXhwZWN0ZWQgYnkgcHJlcGVuZGluZyB0aGUgc2VsZWN0aW9uIHN0cmluZyB3aXRoIGA8bmFtZT4vYC4gVGhlIG5hbWUgaXNcbiAgICAgKiBvbmx5IGFsbG93ZWQgdG8gY29uc2lzdCBvZiBsb3dlci0gYW5kIHVwcGVyIGNhc2UgbGF0aW4gbGV0dGVycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIHB1cHBldGVlci5yZWdpc3RlckN1c3RvbVF1ZXJ5SGFuZGxlcigndGV4dCcsIHsg4oCmIH0pO1xuICAgICAqIGNvbnN0IGFIYW5kbGUgPSBhd2FpdCBwYWdlLiQoJ3RleHQv4oCmJyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSB0aGF0IHRoZSBjdXN0b20gcXVlcnkgaGFuZGxlciB3aWxsIGJlIHJlZ2lzdGVyZWQgdW5kZXIuXG4gICAgICogQHBhcmFtIHF1ZXJ5SGFuZGxlciAtIFRoZSB7QGxpbmsgQ3VzdG9tUXVlcnlIYW5kbGVyIHwgY3VzdG9tIHF1ZXJ5IGhhbmRsZXJ9IHRvXG4gICAgICogcmVnaXN0ZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJDdXN0b21RdWVyeUhhbmRsZXIobmFtZSwgcXVlcnlIYW5kbGVyKSB7XG4gICAgICAgIHJlZ2lzdGVyQ3VzdG9tUXVlcnlIYW5kbGVyKG5hbWUsIHF1ZXJ5SGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5IGhhbmRsZXIgdG8gdW5yZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJDdXN0b21RdWVyeUhhbmRsZXIobmFtZSkge1xuICAgICAgICB1bnJlZ2lzdGVyQ3VzdG9tUXVlcnlIYW5kbGVyKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgd2l0aCB0aGUgbmFtZXMgb2YgYWxsIHJlZ2lzdGVyZWQgY3VzdG9tIHF1ZXJ5IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGN1c3RvbVF1ZXJ5SGFuZGxlck5hbWVzKCkge1xuICAgICAgICByZXR1cm4gY3VzdG9tUXVlcnlIYW5kbGVyTmFtZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCByZWdpc3RlcmVkIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGNsZWFyQ3VzdG9tUXVlcnlIYW5kbGVycygpIHtcbiAgICAgICAgY2xlYXJDdXN0b21RdWVyeUhhbmRsZXJzKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVwcGV0ZWVyLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGFyaWFIYW5kbGVyIH0gZnJvbSAnLi9BcmlhUXVlcnlIYW5kbGVyLmpzJztcbmZ1bmN0aW9uIG1ha2VRdWVyeUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGNvbnN0IGludGVybmFsSGFuZGxlciA9IHt9O1xuICAgIGlmIChoYW5kbGVyLnF1ZXJ5T25lKSB7XG4gICAgICAgIGludGVybmFsSGFuZGxlci5xdWVyeU9uZSA9IGFzeW5jIChlbGVtZW50LCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QganNIYW5kbGUgPSBhd2FpdCBlbGVtZW50LmV2YWx1YXRlSGFuZGxlKGhhbmRsZXIucXVlcnlPbmUsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRIYW5kbGUgPSBqc0hhbmRsZS5hc0VsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50SGFuZGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50SGFuZGxlO1xuICAgICAgICAgICAgYXdhaXQganNIYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGludGVybmFsSGFuZGxlci53YWl0Rm9yID0gKGRvbVdvcmxkLCBzZWxlY3Rvciwgb3B0aW9ucykgPT4gZG9tV29ybGQud2FpdEZvclNlbGVjdG9ySW5QYWdlKGhhbmRsZXIucXVlcnlPbmUsIHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZXIucXVlcnlBbGwpIHtcbiAgICAgICAgaW50ZXJuYWxIYW5kbGVyLnF1ZXJ5QWxsID0gYXN5bmMgKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBqc0hhbmRsZSA9IGF3YWl0IGVsZW1lbnQuZXZhbHVhdGVIYW5kbGUoaGFuZGxlci5xdWVyeUFsbCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IGpzSGFuZGxlLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIGF3YWl0IGpzSGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudEhhbmRsZSA9IHByb3BlcnR5LmFzRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50SGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIGludGVybmFsSGFuZGxlci5xdWVyeUFsbEFycmF5ID0gYXN5bmMgKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRIYW5kbGUgPSBhd2FpdCBlbGVtZW50LmV2YWx1YXRlSGFuZGxlKGhhbmRsZXIucXVlcnlBbGwsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5SGFuZGxlID0gYXdhaXQgcmVzdWx0SGFuZGxlLmV2YWx1YXRlSGFuZGxlKChyZXMpID0+IEFycmF5LmZyb20ocmVzKSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlIYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpbnRlcm5hbEhhbmRsZXI7XG59XG5jb25zdCBfZGVmYXVsdEhhbmRsZXIgPSBtYWtlUXVlcnlIYW5kbGVyKHtcbiAgICBxdWVyeU9uZTogKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgIHF1ZXJ5QWxsOiAoZWxlbWVudCwgc2VsZWN0b3IpID0+IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksXG59KTtcbmNvbnN0IHBpZXJjZUhhbmRsZXIgPSBtYWtlUXVlcnlIYW5kbGVyKHtcbiAgICBxdWVyeU9uZTogKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IChyb290KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihyb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBpdGVyLmN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaChjdXJyZW50Tm9kZS5zaGFkb3dSb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiBjdXJyZW50Tm9kZS5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKCFmb3VuZCAmJiBpdGVyLm5leHROb2RlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcbiAgICBxdWVyeUFsbDogKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjb2xsZWN0ID0gKHJvb3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGl0ZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdChjdXJyZW50Tm9kZS5zaGFkb3dSb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpdGVyLm5leHROb2RlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxufSk7XG5jb25zdCBfYnVpbHRJbkhhbmRsZXJzID0gbmV3IE1hcChbXG4gICAgWydhcmlhJywgYXJpYUhhbmRsZXJdLFxuICAgIFsncGllcmNlJywgcGllcmNlSGFuZGxlcl0sXG5dKTtcbmNvbnN0IF9xdWVyeUhhbmRsZXJzID0gbmV3IE1hcChfYnVpbHRJbkhhbmRsZXJzKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckN1c3RvbVF1ZXJ5SGFuZGxlcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKF9xdWVyeUhhbmRsZXJzLmdldChuYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGN1c3RvbSBxdWVyeSBoYW5kbGVyIG5hbWVkIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgY29uc3QgaXNWYWxpZE5hbWUgPSAvXlthLXpBLVpdKyQvLnRlc3QobmFtZSk7XG4gICAgaWYgKCFpc1ZhbGlkTmFtZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXN0b20gcXVlcnkgaGFuZGxlciBuYW1lcyBtYXkgb25seSBjb250YWluIFthLXpBLVpdYCk7XG4gICAgY29uc3QgaW50ZXJuYWxIYW5kbGVyID0gbWFrZVF1ZXJ5SGFuZGxlcihoYW5kbGVyKTtcbiAgICBfcXVlcnlIYW5kbGVycy5zZXQobmFtZSwgaW50ZXJuYWxIYW5kbGVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJlZ2lzdGVyQ3VzdG9tUXVlcnlIYW5kbGVyKG5hbWUpIHtcbiAgICBpZiAoX3F1ZXJ5SGFuZGxlcnMuaGFzKG5hbWUpICYmICFfYnVpbHRJbkhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICBfcXVlcnlIYW5kbGVycy5kZWxldGUobmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbVF1ZXJ5SGFuZGxlck5hbWVzKCkge1xuICAgIHJldHVybiBbLi4uX3F1ZXJ5SGFuZGxlcnMua2V5cygpXS5maWx0ZXIoKG5hbWUpID0+ICFfYnVpbHRJbkhhbmRsZXJzLmhhcyhuYW1lKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDdXN0b21RdWVyeUhhbmRsZXJzKCkge1xuICAgIGN1c3RvbVF1ZXJ5SGFuZGxlck5hbWVzKCkuZm9yRWFjaCh1bnJlZ2lzdGVyQ3VzdG9tUXVlcnlIYW5kbGVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeUhhbmRsZXJBbmRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGhhc0N1c3RvbVF1ZXJ5SGFuZGxlciA9IC9eW2EtekEtWl0rXFwvLy50ZXN0KHNlbGVjdG9yKTtcbiAgICBpZiAoIWhhc0N1c3RvbVF1ZXJ5SGFuZGxlcilcbiAgICAgICAgcmV0dXJuIHsgdXBkYXRlZFNlbGVjdG9yOiBzZWxlY3RvciwgcXVlcnlIYW5kbGVyOiBfZGVmYXVsdEhhbmRsZXIgfTtcbiAgICBjb25zdCBpbmRleCA9IHNlbGVjdG9yLmluZGV4T2YoJy8nKTtcbiAgICBjb25zdCBuYW1lID0gc2VsZWN0b3Iuc2xpY2UoMCwgaW5kZXgpO1xuICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgY29uc3QgcXVlcnlIYW5kbGVyID0gX3F1ZXJ5SGFuZGxlcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcXVlcnlIYW5kbGVyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXJ5IHNldCB0byB1c2UgXCIke25hbWV9XCIsIGJ1dCBubyBxdWVyeSBoYW5kbGVyIG9mIHRoYXQgbmFtZSB3YXMgZm91bmRgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGVkU2VsZWN0b3IsXG4gICAgICAgIHF1ZXJ5SGFuZGxlcixcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlIYW5kbGVyLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIFNlY3VyaXR5RGV0YWlscyBjbGFzcyByZXByZXNlbnRzIHRoZSBzZWN1cml0eSBkZXRhaWxzIG9mIGFcbiAqIHJlc3BvbnNlIHRoYXQgd2FzIHJlY2VpdmVkIG92ZXIgYSBzZWN1cmUgY29ubmVjdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWN1cml0eURldGFpbHMge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlY3VyaXR5UGF5bG9hZCkge1xuICAgICAgICB0aGlzLl9zdWJqZWN0TmFtZSA9IHNlY3VyaXR5UGF5bG9hZC5zdWJqZWN0TmFtZTtcbiAgICAgICAgdGhpcy5faXNzdWVyID0gc2VjdXJpdHlQYXlsb2FkLmlzc3VlcjtcbiAgICAgICAgdGhpcy5fdmFsaWRGcm9tID0gc2VjdXJpdHlQYXlsb2FkLnZhbGlkRnJvbTtcbiAgICAgICAgdGhpcy5fdmFsaWRUbyA9IHNlY3VyaXR5UGF5bG9hZC52YWxpZFRvO1xuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHNlY3VyaXR5UGF5bG9hZC5wcm90b2NvbDtcbiAgICAgICAgdGhpcy5fc2FuTGlzdCA9IHNlY3VyaXR5UGF5bG9hZC5zYW5MaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgaXNzdWVyIG9mIHRoZSBjZXJ0aWZpY2F0ZS5cbiAgICAgKi9cbiAgICBpc3N1ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc3N1ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml4X3RpbWUgfCBVbml4IHRpbWVzdGFtcH1cbiAgICAgKiBtYXJraW5nIHRoZSBzdGFydCBvZiB0aGUgY2VydGlmaWNhdGUncyB2YWxpZGl0eS5cbiAgICAgKi9cbiAgICB2YWxpZEZyb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZEZyb207XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml4X3RpbWUgfCBVbml4IHRpbWVzdGFtcH1cbiAgICAgKiBtYXJraW5nIHRoZSBlbmQgb2YgdGhlIGNlcnRpZmljYXRlJ3MgdmFsaWRpdHkuXG4gICAgICovXG4gICAgdmFsaWRUbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkVG87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBzZWN1cml0eSBwcm90b2NvbCBiZWluZyB1c2VkLCBlLmcuIFwiVExTIDEuMlwiLlxuICAgICAqL1xuICAgIHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBzdWJqZWN0IHRvIHdoaWNoIHRoZSBjZXJ0aWZpY2F0ZSB3YXMgaXNzdWVkLlxuICAgICAqL1xuICAgIHN1YmplY3ROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdWJqZWN0X0FsdGVybmF0aXZlX05hbWUgfCBzdWJqZWN0IGFsdGVybmF0aXZlIG5hbWVzIChTQU5zKX0gb2YgdGhlIGNlcnRpZmljYXRlLlxuICAgICAqL1xuICAgIHN1YmplY3RBbHRlcm5hdGl2ZU5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2FuTGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWN1cml0eURldGFpbHMuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vUGFnZS5qcyc7XG5pbXBvcnQgeyBXZWJXb3JrZXIgfSBmcm9tICcuL1dlYldvcmtlci5qcyc7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SW5mbywgYnJvd3NlckNvbnRleHQsIHNlc3Npb25GYWN0b3J5LCBpZ25vcmVIVFRQU0Vycm9ycywgZGVmYXVsdFZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEluZm8gPSB0YXJnZXRJbmZvO1xuICAgICAgICB0aGlzLl9icm93c2VyQ29udGV4dCA9IGJyb3dzZXJDb250ZXh0O1xuICAgICAgICB0aGlzLl90YXJnZXRJZCA9IHRhcmdldEluZm8udGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuX3Nlc3Npb25GYWN0b3J5ID0gc2Vzc2lvbkZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2lnbm9yZUhUVFBTRXJyb3JzID0gaWdub3JlSFRUUFNFcnJvcnM7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWaWV3cG9ydCA9IGRlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgLyoqIEB0eXBlIHs/UHJvbWlzZTwhUHVwcGV0ZWVyLlBhZ2U+fSAqL1xuICAgICAgICB0aGlzLl9wYWdlUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8qKiBAdHlwZSB7P1Byb21pc2U8IVdlYldvcmtlcj59ICovXG4gICAgICAgIHRoaXMuX3dvcmtlclByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4gKHRoaXMuX2luaXRpYWxpemVkQ2FsbGJhY2sgPSBmdWxmaWxsKSkudGhlbihhc3luYyAoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzdWNjZXNzKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5lciA9IHRoaXMub3BlbmVyKCk7XG4gICAgICAgICAgICBpZiAoIW9wZW5lciB8fCAhb3BlbmVyLl9wYWdlUHJvbWlzZSB8fCB0aGlzLnR5cGUoKSAhPT0gJ3BhZ2UnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb3BlbmVyUGFnZSA9IGF3YWl0IG9wZW5lci5fcGFnZVByb21pc2U7XG4gICAgICAgICAgICBpZiAoIW9wZW5lclBhZ2UubGlzdGVuZXJDb3VudChcInBvcHVwXCIgLyogUG9wdXAgKi8pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcG9wdXBQYWdlID0gYXdhaXQgdGhpcy5wYWdlKCk7XG4gICAgICAgICAgICBvcGVuZXJQYWdlLmVtaXQoXCJwb3B1cFwiIC8qIFBvcHVwICovLCBwb3B1cFBhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVsZmlsbCkgPT4gKHRoaXMuX2Nsb3NlZENhbGxiYWNrID0gZnVsZmlsbCkpO1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID1cbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEluZm8udHlwZSAhPT0gJ3BhZ2UnIHx8IHRoaXMuX3RhcmdldEluZm8udXJsICE9PSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZENhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ2hyb21lIERldnRvb2xzIFByb3RvY29sIHNlc3Npb24gYXR0YWNoZWQgdG8gdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkZhY3RvcnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhcmdldCBpcyBub3Qgb2YgdHlwZSBgXCJwYWdlXCJgIG9yIGBcImJhY2tncm91bmRfcGFnZVwiYCwgcmV0dXJucyBgbnVsbGAuXG4gICAgICovXG4gICAgYXN5bmMgcGFnZSgpIHtcbiAgICAgICAgaWYgKCh0aGlzLl90YXJnZXRJbmZvLnR5cGUgPT09ICdwYWdlJyB8fFxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0SW5mby50eXBlID09PSAnYmFja2dyb3VuZF9wYWdlJyB8fFxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0SW5mby50eXBlID09PSAnd2VidmlldycpICYmXG4gICAgICAgICAgICAhdGhpcy5fcGFnZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VQcm9taXNlID0gdGhpcy5fc2Vzc2lvbkZhY3RvcnkoKS50aGVuKChjbGllbnQpID0+IFBhZ2UuY3JlYXRlKGNsaWVudCwgdGhpcywgdGhpcy5faWdub3JlSFRUUFNFcnJvcnMsIHRoaXMuX2RlZmF1bHRWaWV3cG9ydCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhcmdldCBpcyBub3Qgb2YgdHlwZSBgXCJzZXJ2aWNlX3dvcmtlclwiYCBvciBgXCJzaGFyZWRfd29ya2VyXCJgLCByZXR1cm5zIGBudWxsYC5cbiAgICAgKi9cbiAgICBhc3luYyB3b3JrZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRJbmZvLnR5cGUgIT09ICdzZXJ2aWNlX3dvcmtlcicgJiZcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEluZm8udHlwZSAhPT0gJ3NoYXJlZF93b3JrZXInKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gVE9ETyhlaW5iaW5kZXIpOiBNYWtlIHdvcmtlcnMgc2VuZCB0aGVpciBjb25zb2xlIGxvZ3MuXG4gICAgICAgICAgICB0aGlzLl93b3JrZXJQcm9taXNlID0gdGhpcy5fc2Vzc2lvbkZhY3RvcnkoKS50aGVuKChjbGllbnQpID0+IG5ldyBXZWJXb3JrZXIoY2xpZW50LCB0aGlzLl90YXJnZXRJbmZvLnVybCwgKCkgPT4geyB9IC8qIGNvbnNvbGVBUElDYWxsZWQgKi8sICgpID0+IHsgfSAvKiBleGNlcHRpb25UaHJvd24gKi8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyUHJvbWlzZTtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0SW5mby51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgd2hhdCBraW5kIG9mIHRhcmdldCB0aGlzIGlzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL2JhY2tncm91bmRfcGFnZXMgfCBkb2NzfSBmb3IgbW9yZSBpbmZvIGFib3V0IGJhY2tncm91bmQgcGFnZXMuXG4gICAgICovXG4gICAgdHlwZSgpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3RhcmdldEluZm8udHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYWdlJyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gJ2JhY2tncm91bmRfcGFnZScgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzZXJ2aWNlX3dvcmtlcicgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzaGFyZWRfd29ya2VyJyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gJ2Jyb3dzZXInIHx8XG4gICAgICAgICAgICB0eXBlID09PSAnd2VidmlldycpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnJvd3NlciB0aGUgdGFyZ2V0IGJlbG9uZ3MgdG8uXG4gICAgICovXG4gICAgYnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb3dzZXJDb250ZXh0LmJyb3dzZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBicm93c2VyIGNvbnRleHQgdGhlIHRhcmdldCBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIGJyb3dzZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnJvd3NlckNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGFyZ2V0IHRoYXQgb3BlbmVkIHRoaXMgdGFyZ2V0LiBUb3AtbGV2ZWwgdGFyZ2V0cyByZXR1cm4gYG51bGxgLlxuICAgICAqL1xuICAgIG9wZW5lcigpIHtcbiAgICAgICAgY29uc3QgeyBvcGVuZXJJZCB9ID0gdGhpcy5fdGFyZ2V0SW5mbztcbiAgICAgICAgaWYgKCFvcGVuZXJJZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyKCkuX3RhcmdldHMuZ2V0KG9wZW5lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3RhcmdldEluZm9DaGFuZ2VkKHRhcmdldEluZm8pIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0SW5mbyA9IHRhcmdldEluZm87XG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCAmJlxuICAgICAgICAgICAgKHRoaXMuX3RhcmdldEluZm8udHlwZSAhPT0gJ3BhZ2UnIHx8IHRoaXMuX3RhcmdldEluZm8udXJsICE9PSAnJykpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWRDYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhcmdldC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSAzMDAwMDtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lb3V0U2V0dGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmF1bHROYXZpZ2F0aW9uVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHNldERlZmF1bHRUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBzZXREZWZhdWx0TmF2aWdhdGlvblRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0TmF2aWdhdGlvblRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBuYXZpZ2F0aW9uVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHROYXZpZ2F0aW9uVGltZW91dCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0TmF2aWdhdGlvblRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLl9kZWZhdWx0VGltZW91dCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfVElNRU9VVDtcbiAgICB9XG4gICAgdGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRUaW1lb3V0ICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gREVGQVVMVF9USU1FT1VUO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVvdXRTZXR0aW5ncy5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBoZWxwZXIgfSBmcm9tICcuL2hlbHBlci5qcyc7XG4vKipcbiAqIFRoZSBUcmFjaW5nIGNsYXNzIGV4cG9zZXMgdGhlIHRyYWNpbmcgYXVkaXQgaW50ZXJmYWNlLlxuICogQHJlbWFya3NcbiAqIFlvdSBjYW4gdXNlIGB0cmFjaW5nLnN0YXJ0YCBhbmQgYHRyYWNpbmcuc3RvcGAgdG8gY3JlYXRlIGEgdHJhY2UgZmlsZVxuICogd2hpY2ggY2FuIGJlIG9wZW5lZCBpbiBDaHJvbWUgRGV2VG9vbHMgb3Ige0BsaW5rIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL3RpbWVsaW5lLXZpZXdlci8gfCB0aW1lbGluZSB2aWV3ZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYXdhaXQgcGFnZS50cmFjaW5nLnN0YXJ0KHtwYXRoOiAndHJhY2UuanNvbid9KTtcbiAqIGF3YWl0IHBhZ2UuZ290bygnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbScpO1xuICogYXdhaXQgcGFnZS50cmFjaW5nLnN0b3AoKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNpbmcge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9ICcnO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIHRyYWNlIGZvciB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogT25seSBvbmUgdHJhY2UgY2FuIGJlIGFjdGl2ZSBhdCBhIHRpbWUgcGVyIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBgVHJhY2luZ09wdGlvbnNgLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuX3JlY29yZGluZywgJ0Nhbm5vdCBzdGFydCByZWNvcmRpbmcgdHJhY2Ugd2hpbGUgYWxyZWFkeSByZWNvcmRpbmcgdHJhY2UuJyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDYXRlZ29yaWVzID0gW1xuICAgICAgICAgICAgJy0qJyxcbiAgICAgICAgICAgICdkZXZ0b29scy50aW1lbGluZScsXG4gICAgICAgICAgICAndjguZXhlY3V0ZScsXG4gICAgICAgICAgICAnZGlzYWJsZWQtYnktZGVmYXVsdC1kZXZ0b29scy50aW1lbGluZScsXG4gICAgICAgICAgICAnZGlzYWJsZWQtYnktZGVmYXVsdC1kZXZ0b29scy50aW1lbGluZS5mcmFtZScsXG4gICAgICAgICAgICAndG9wbGV2ZWwnLFxuICAgICAgICAgICAgJ2JsaW5rLmNvbnNvbGUnLFxuICAgICAgICAgICAgJ2JsaW5rLnVzZXJfdGltaW5nJyxcbiAgICAgICAgICAgICdsYXRlbmN5SW5mbycsXG4gICAgICAgICAgICAnZGlzYWJsZWQtYnktZGVmYXVsdC1kZXZ0b29scy50aW1lbGluZS5zdGFjaycsXG4gICAgICAgICAgICAnZGlzYWJsZWQtYnktZGVmYXVsdC12OC5jcHVfcHJvZmlsZXInLFxuICAgICAgICAgICAgJ2Rpc2FibGVkLWJ5LWRlZmF1bHQtdjguY3B1X3Byb2ZpbGVyLmhpcmVzJyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyBwYXRoID0gbnVsbCwgc2NyZWVuc2hvdHMgPSBmYWxzZSwgY2F0ZWdvcmllcyA9IGRlZmF1bHRDYXRlZ29yaWVzLCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNjcmVlbnNob3RzKVxuICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKCdkaXNhYmxlZC1ieS1kZWZhdWx0LWRldnRvb2xzLnNjcmVlbnNob3QnKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX3JlY29yZGluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdUcmFjaW5nLnN0YXJ0Jywge1xuICAgICAgICAgICAgdHJhbnNmZXJNb2RlOiAnUmV0dXJuQXNTdHJlYW0nLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcy5qb2luKCcsJyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhIHRyYWNlIHN0YXJ0ZWQgd2l0aCB0aGUgYHN0YXJ0YCBtZXRob2QuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBidWZmZXIgd2l0aCB0cmFjZSBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIGxldCBmdWxmaWxsO1xuICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICBjb25zdCBjb250ZW50UHJvbWlzZSA9IG5ldyBQcm9taXNlKCh4LCB5KSA9PiB7XG4gICAgICAgICAgICBmdWxmaWxsID0geDtcbiAgICAgICAgICAgIHJlamVjdCA9IHk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jbGllbnQub25jZSgnVHJhY2luZy50cmFjaW5nQ29tcGxldGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGhlbHBlclxuICAgICAgICAgICAgICAgIC5yZWFkUHJvdG9jb2xTdHJlYW0odGhpcy5fY2xpZW50LCBldmVudC5zdHJlYW0sIHRoaXMuX3BhdGgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVsZmlsbCwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5zZW5kKCdUcmFjaW5nLmVuZCcpO1xuICAgICAgICB0aGlzLl9yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRQcm9taXNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYWNpbmcuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3Qga2V5RGVmaW5pdGlvbnMgPSB7XG4gICAgJzAnOiB7IGtleUNvZGU6IDQ4LCBrZXk6ICcwJywgY29kZTogJ0RpZ2l0MCcgfSxcbiAgICAnMSc6IHsga2V5Q29kZTogNDksIGtleTogJzEnLCBjb2RlOiAnRGlnaXQxJyB9LFxuICAgICcyJzogeyBrZXlDb2RlOiA1MCwga2V5OiAnMicsIGNvZGU6ICdEaWdpdDInIH0sXG4gICAgJzMnOiB7IGtleUNvZGU6IDUxLCBrZXk6ICczJywgY29kZTogJ0RpZ2l0MycgfSxcbiAgICAnNCc6IHsga2V5Q29kZTogNTIsIGtleTogJzQnLCBjb2RlOiAnRGlnaXQ0JyB9LFxuICAgICc1JzogeyBrZXlDb2RlOiA1Mywga2V5OiAnNScsIGNvZGU6ICdEaWdpdDUnIH0sXG4gICAgJzYnOiB7IGtleUNvZGU6IDU0LCBrZXk6ICc2JywgY29kZTogJ0RpZ2l0NicgfSxcbiAgICAnNyc6IHsga2V5Q29kZTogNTUsIGtleTogJzcnLCBjb2RlOiAnRGlnaXQ3JyB9LFxuICAgICc4JzogeyBrZXlDb2RlOiA1Niwga2V5OiAnOCcsIGNvZGU6ICdEaWdpdDgnIH0sXG4gICAgJzknOiB7IGtleUNvZGU6IDU3LCBrZXk6ICc5JywgY29kZTogJ0RpZ2l0OScgfSxcbiAgICBQb3dlcjogeyBrZXk6ICdQb3dlcicsIGNvZGU6ICdQb3dlcicgfSxcbiAgICBFamVjdDogeyBrZXk6ICdFamVjdCcsIGNvZGU6ICdFamVjdCcgfSxcbiAgICBBYm9ydDogeyBrZXlDb2RlOiAzLCBjb2RlOiAnQWJvcnQnLCBrZXk6ICdDYW5jZWwnIH0sXG4gICAgSGVscDogeyBrZXlDb2RlOiA2LCBjb2RlOiAnSGVscCcsIGtleTogJ0hlbHAnIH0sXG4gICAgQmFja3NwYWNlOiB7IGtleUNvZGU6IDgsIGNvZGU6ICdCYWNrc3BhY2UnLCBrZXk6ICdCYWNrc3BhY2UnIH0sXG4gICAgVGFiOiB7IGtleUNvZGU6IDksIGNvZGU6ICdUYWInLCBrZXk6ICdUYWInIH0sXG4gICAgTnVtcGFkNToge1xuICAgICAgICBrZXlDb2RlOiAxMixcbiAgICAgICAgc2hpZnRLZXlDb2RlOiAxMDEsXG4gICAgICAgIGtleTogJ0NsZWFyJyxcbiAgICAgICAgY29kZTogJ051bXBhZDUnLFxuICAgICAgICBzaGlmdEtleTogJzUnLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIE51bXBhZEVudGVyOiB7XG4gICAgICAgIGtleUNvZGU6IDEzLFxuICAgICAgICBjb2RlOiAnTnVtcGFkRW50ZXInLFxuICAgICAgICBrZXk6ICdFbnRlcicsXG4gICAgICAgIHRleHQ6ICdcXHInLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIEVudGVyOiB7IGtleUNvZGU6IDEzLCBjb2RlOiAnRW50ZXInLCBrZXk6ICdFbnRlcicsIHRleHQ6ICdcXHInIH0sXG4gICAgJ1xccic6IHsga2V5Q29kZTogMTMsIGNvZGU6ICdFbnRlcicsIGtleTogJ0VudGVyJywgdGV4dDogJ1xccicgfSxcbiAgICAnXFxuJzogeyBrZXlDb2RlOiAxMywgY29kZTogJ0VudGVyJywga2V5OiAnRW50ZXInLCB0ZXh0OiAnXFxyJyB9LFxuICAgIFNoaWZ0TGVmdDogeyBrZXlDb2RlOiAxNiwgY29kZTogJ1NoaWZ0TGVmdCcsIGtleTogJ1NoaWZ0JywgbG9jYXRpb246IDEgfSxcbiAgICBTaGlmdFJpZ2h0OiB7IGtleUNvZGU6IDE2LCBjb2RlOiAnU2hpZnRSaWdodCcsIGtleTogJ1NoaWZ0JywgbG9jYXRpb246IDIgfSxcbiAgICBDb250cm9sTGVmdDoge1xuICAgICAgICBrZXlDb2RlOiAxNyxcbiAgICAgICAgY29kZTogJ0NvbnRyb2xMZWZ0JyxcbiAgICAgICAga2V5OiAnQ29udHJvbCcsXG4gICAgICAgIGxvY2F0aW9uOiAxLFxuICAgIH0sXG4gICAgQ29udHJvbFJpZ2h0OiB7XG4gICAgICAgIGtleUNvZGU6IDE3LFxuICAgICAgICBjb2RlOiAnQ29udHJvbFJpZ2h0JyxcbiAgICAgICAga2V5OiAnQ29udHJvbCcsXG4gICAgICAgIGxvY2F0aW9uOiAyLFxuICAgIH0sXG4gICAgQWx0TGVmdDogeyBrZXlDb2RlOiAxOCwgY29kZTogJ0FsdExlZnQnLCBrZXk6ICdBbHQnLCBsb2NhdGlvbjogMSB9LFxuICAgIEFsdFJpZ2h0OiB7IGtleUNvZGU6IDE4LCBjb2RlOiAnQWx0UmlnaHQnLCBrZXk6ICdBbHQnLCBsb2NhdGlvbjogMiB9LFxuICAgIFBhdXNlOiB7IGtleUNvZGU6IDE5LCBjb2RlOiAnUGF1c2UnLCBrZXk6ICdQYXVzZScgfSxcbiAgICBDYXBzTG9jazogeyBrZXlDb2RlOiAyMCwgY29kZTogJ0NhcHNMb2NrJywga2V5OiAnQ2Fwc0xvY2snIH0sXG4gICAgRXNjYXBlOiB7IGtleUNvZGU6IDI3LCBjb2RlOiAnRXNjYXBlJywga2V5OiAnRXNjYXBlJyB9LFxuICAgIENvbnZlcnQ6IHsga2V5Q29kZTogMjgsIGNvZGU6ICdDb252ZXJ0Jywga2V5OiAnQ29udmVydCcgfSxcbiAgICBOb25Db252ZXJ0OiB7IGtleUNvZGU6IDI5LCBjb2RlOiAnTm9uQ29udmVydCcsIGtleTogJ05vbkNvbnZlcnQnIH0sXG4gICAgU3BhY2U6IHsga2V5Q29kZTogMzIsIGNvZGU6ICdTcGFjZScsIGtleTogJyAnIH0sXG4gICAgTnVtcGFkOToge1xuICAgICAgICBrZXlDb2RlOiAzMyxcbiAgICAgICAgc2hpZnRLZXlDb2RlOiAxMDUsXG4gICAgICAgIGtleTogJ1BhZ2VVcCcsXG4gICAgICAgIGNvZGU6ICdOdW1wYWQ5JyxcbiAgICAgICAgc2hpZnRLZXk6ICc5JyxcbiAgICAgICAgbG9jYXRpb246IDMsXG4gICAgfSxcbiAgICBQYWdlVXA6IHsga2V5Q29kZTogMzMsIGNvZGU6ICdQYWdlVXAnLCBrZXk6ICdQYWdlVXAnIH0sXG4gICAgTnVtcGFkMzoge1xuICAgICAgICBrZXlDb2RlOiAzNCxcbiAgICAgICAgc2hpZnRLZXlDb2RlOiA5OSxcbiAgICAgICAga2V5OiAnUGFnZURvd24nLFxuICAgICAgICBjb2RlOiAnTnVtcGFkMycsXG4gICAgICAgIHNoaWZ0S2V5OiAnMycsXG4gICAgICAgIGxvY2F0aW9uOiAzLFxuICAgIH0sXG4gICAgUGFnZURvd246IHsga2V5Q29kZTogMzQsIGNvZGU6ICdQYWdlRG93bicsIGtleTogJ1BhZ2VEb3duJyB9LFxuICAgIEVuZDogeyBrZXlDb2RlOiAzNSwgY29kZTogJ0VuZCcsIGtleTogJ0VuZCcgfSxcbiAgICBOdW1wYWQxOiB7XG4gICAgICAgIGtleUNvZGU6IDM1LFxuICAgICAgICBzaGlmdEtleUNvZGU6IDk3LFxuICAgICAgICBrZXk6ICdFbmQnLFxuICAgICAgICBjb2RlOiAnTnVtcGFkMScsXG4gICAgICAgIHNoaWZ0S2V5OiAnMScsXG4gICAgICAgIGxvY2F0aW9uOiAzLFxuICAgIH0sXG4gICAgSG9tZTogeyBrZXlDb2RlOiAzNiwgY29kZTogJ0hvbWUnLCBrZXk6ICdIb21lJyB9LFxuICAgIE51bXBhZDc6IHtcbiAgICAgICAga2V5Q29kZTogMzYsXG4gICAgICAgIHNoaWZ0S2V5Q29kZTogMTAzLFxuICAgICAgICBrZXk6ICdIb21lJyxcbiAgICAgICAgY29kZTogJ051bXBhZDcnLFxuICAgICAgICBzaGlmdEtleTogJzcnLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIEFycm93TGVmdDogeyBrZXlDb2RlOiAzNywgY29kZTogJ0Fycm93TGVmdCcsIGtleTogJ0Fycm93TGVmdCcgfSxcbiAgICBOdW1wYWQ0OiB7XG4gICAgICAgIGtleUNvZGU6IDM3LFxuICAgICAgICBzaGlmdEtleUNvZGU6IDEwMCxcbiAgICAgICAga2V5OiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgY29kZTogJ051bXBhZDQnLFxuICAgICAgICBzaGlmdEtleTogJzQnLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIE51bXBhZDg6IHtcbiAgICAgICAga2V5Q29kZTogMzgsXG4gICAgICAgIHNoaWZ0S2V5Q29kZTogMTA0LFxuICAgICAgICBrZXk6ICdBcnJvd1VwJyxcbiAgICAgICAgY29kZTogJ051bXBhZDgnLFxuICAgICAgICBzaGlmdEtleTogJzgnLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIEFycm93VXA6IHsga2V5Q29kZTogMzgsIGNvZGU6ICdBcnJvd1VwJywga2V5OiAnQXJyb3dVcCcgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IGtleUNvZGU6IDM5LCBjb2RlOiAnQXJyb3dSaWdodCcsIGtleTogJ0Fycm93UmlnaHQnIH0sXG4gICAgTnVtcGFkNjoge1xuICAgICAgICBrZXlDb2RlOiAzOSxcbiAgICAgICAgc2hpZnRLZXlDb2RlOiAxMDIsXG4gICAgICAgIGtleTogJ0Fycm93UmlnaHQnLFxuICAgICAgICBjb2RlOiAnTnVtcGFkNicsXG4gICAgICAgIHNoaWZ0S2V5OiAnNicsXG4gICAgICAgIGxvY2F0aW9uOiAzLFxuICAgIH0sXG4gICAgTnVtcGFkMjoge1xuICAgICAgICBrZXlDb2RlOiA0MCxcbiAgICAgICAgc2hpZnRLZXlDb2RlOiA5OCxcbiAgICAgICAga2V5OiAnQXJyb3dEb3duJyxcbiAgICAgICAgY29kZTogJ051bXBhZDInLFxuICAgICAgICBzaGlmdEtleTogJzInLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIEFycm93RG93bjogeyBrZXlDb2RlOiA0MCwgY29kZTogJ0Fycm93RG93bicsIGtleTogJ0Fycm93RG93bicgfSxcbiAgICBTZWxlY3Q6IHsga2V5Q29kZTogNDEsIGNvZGU6ICdTZWxlY3QnLCBrZXk6ICdTZWxlY3QnIH0sXG4gICAgT3BlbjogeyBrZXlDb2RlOiA0MywgY29kZTogJ09wZW4nLCBrZXk6ICdFeGVjdXRlJyB9LFxuICAgIFByaW50U2NyZWVuOiB7IGtleUNvZGU6IDQ0LCBjb2RlOiAnUHJpbnRTY3JlZW4nLCBrZXk6ICdQcmludFNjcmVlbicgfSxcbiAgICBJbnNlcnQ6IHsga2V5Q29kZTogNDUsIGNvZGU6ICdJbnNlcnQnLCBrZXk6ICdJbnNlcnQnIH0sXG4gICAgTnVtcGFkMDoge1xuICAgICAgICBrZXlDb2RlOiA0NSxcbiAgICAgICAgc2hpZnRLZXlDb2RlOiA5NixcbiAgICAgICAga2V5OiAnSW5zZXJ0JyxcbiAgICAgICAgY29kZTogJ051bXBhZDAnLFxuICAgICAgICBzaGlmdEtleTogJzAnLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIERlbGV0ZTogeyBrZXlDb2RlOiA0NiwgY29kZTogJ0RlbGV0ZScsIGtleTogJ0RlbGV0ZScgfSxcbiAgICBOdW1wYWREZWNpbWFsOiB7XG4gICAgICAgIGtleUNvZGU6IDQ2LFxuICAgICAgICBzaGlmdEtleUNvZGU6IDExMCxcbiAgICAgICAgY29kZTogJ051bXBhZERlY2ltYWwnLFxuICAgICAgICBrZXk6ICdcXHUwMDAwJyxcbiAgICAgICAgc2hpZnRLZXk6ICcuJyxcbiAgICAgICAgbG9jYXRpb246IDMsXG4gICAgfSxcbiAgICBEaWdpdDA6IHsga2V5Q29kZTogNDgsIGNvZGU6ICdEaWdpdDAnLCBzaGlmdEtleTogJyknLCBrZXk6ICcwJyB9LFxuICAgIERpZ2l0MTogeyBrZXlDb2RlOiA0OSwgY29kZTogJ0RpZ2l0MScsIHNoaWZ0S2V5OiAnIScsIGtleTogJzEnIH0sXG4gICAgRGlnaXQyOiB7IGtleUNvZGU6IDUwLCBjb2RlOiAnRGlnaXQyJywgc2hpZnRLZXk6ICdAJywga2V5OiAnMicgfSxcbiAgICBEaWdpdDM6IHsga2V5Q29kZTogNTEsIGNvZGU6ICdEaWdpdDMnLCBzaGlmdEtleTogJyMnLCBrZXk6ICczJyB9LFxuICAgIERpZ2l0NDogeyBrZXlDb2RlOiA1MiwgY29kZTogJ0RpZ2l0NCcsIHNoaWZ0S2V5OiAnJCcsIGtleTogJzQnIH0sXG4gICAgRGlnaXQ1OiB7IGtleUNvZGU6IDUzLCBjb2RlOiAnRGlnaXQ1Jywgc2hpZnRLZXk6ICclJywga2V5OiAnNScgfSxcbiAgICBEaWdpdDY6IHsga2V5Q29kZTogNTQsIGNvZGU6ICdEaWdpdDYnLCBzaGlmdEtleTogJ14nLCBrZXk6ICc2JyB9LFxuICAgIERpZ2l0NzogeyBrZXlDb2RlOiA1NSwgY29kZTogJ0RpZ2l0NycsIHNoaWZ0S2V5OiAnJicsIGtleTogJzcnIH0sXG4gICAgRGlnaXQ4OiB7IGtleUNvZGU6IDU2LCBjb2RlOiAnRGlnaXQ4Jywgc2hpZnRLZXk6ICcqJywga2V5OiAnOCcgfSxcbiAgICBEaWdpdDk6IHsga2V5Q29kZTogNTcsIGNvZGU6ICdEaWdpdDknLCBzaGlmdEtleTogJygnLCBrZXk6ICc5JyB9LFxuICAgIEtleUE6IHsga2V5Q29kZTogNjUsIGNvZGU6ICdLZXlBJywgc2hpZnRLZXk6ICdBJywga2V5OiAnYScgfSxcbiAgICBLZXlCOiB7IGtleUNvZGU6IDY2LCBjb2RlOiAnS2V5QicsIHNoaWZ0S2V5OiAnQicsIGtleTogJ2InIH0sXG4gICAgS2V5QzogeyBrZXlDb2RlOiA2NywgY29kZTogJ0tleUMnLCBzaGlmdEtleTogJ0MnLCBrZXk6ICdjJyB9LFxuICAgIEtleUQ6IHsga2V5Q29kZTogNjgsIGNvZGU6ICdLZXlEJywgc2hpZnRLZXk6ICdEJywga2V5OiAnZCcgfSxcbiAgICBLZXlFOiB7IGtleUNvZGU6IDY5LCBjb2RlOiAnS2V5RScsIHNoaWZ0S2V5OiAnRScsIGtleTogJ2UnIH0sXG4gICAgS2V5RjogeyBrZXlDb2RlOiA3MCwgY29kZTogJ0tleUYnLCBzaGlmdEtleTogJ0YnLCBrZXk6ICdmJyB9LFxuICAgIEtleUc6IHsga2V5Q29kZTogNzEsIGNvZGU6ICdLZXlHJywgc2hpZnRLZXk6ICdHJywga2V5OiAnZycgfSxcbiAgICBLZXlIOiB7IGtleUNvZGU6IDcyLCBjb2RlOiAnS2V5SCcsIHNoaWZ0S2V5OiAnSCcsIGtleTogJ2gnIH0sXG4gICAgS2V5STogeyBrZXlDb2RlOiA3MywgY29kZTogJ0tleUknLCBzaGlmdEtleTogJ0knLCBrZXk6ICdpJyB9LFxuICAgIEtleUo6IHsga2V5Q29kZTogNzQsIGNvZGU6ICdLZXlKJywgc2hpZnRLZXk6ICdKJywga2V5OiAnaicgfSxcbiAgICBLZXlLOiB7IGtleUNvZGU6IDc1LCBjb2RlOiAnS2V5SycsIHNoaWZ0S2V5OiAnSycsIGtleTogJ2snIH0sXG4gICAgS2V5TDogeyBrZXlDb2RlOiA3NiwgY29kZTogJ0tleUwnLCBzaGlmdEtleTogJ0wnLCBrZXk6ICdsJyB9LFxuICAgIEtleU06IHsga2V5Q29kZTogNzcsIGNvZGU6ICdLZXlNJywgc2hpZnRLZXk6ICdNJywga2V5OiAnbScgfSxcbiAgICBLZXlOOiB7IGtleUNvZGU6IDc4LCBjb2RlOiAnS2V5TicsIHNoaWZ0S2V5OiAnTicsIGtleTogJ24nIH0sXG4gICAgS2V5TzogeyBrZXlDb2RlOiA3OSwgY29kZTogJ0tleU8nLCBzaGlmdEtleTogJ08nLCBrZXk6ICdvJyB9LFxuICAgIEtleVA6IHsga2V5Q29kZTogODAsIGNvZGU6ICdLZXlQJywgc2hpZnRLZXk6ICdQJywga2V5OiAncCcgfSxcbiAgICBLZXlROiB7IGtleUNvZGU6IDgxLCBjb2RlOiAnS2V5UScsIHNoaWZ0S2V5OiAnUScsIGtleTogJ3EnIH0sXG4gICAgS2V5UjogeyBrZXlDb2RlOiA4MiwgY29kZTogJ0tleVInLCBzaGlmdEtleTogJ1InLCBrZXk6ICdyJyB9LFxuICAgIEtleVM6IHsga2V5Q29kZTogODMsIGNvZGU6ICdLZXlTJywgc2hpZnRLZXk6ICdTJywga2V5OiAncycgfSxcbiAgICBLZXlUOiB7IGtleUNvZGU6IDg0LCBjb2RlOiAnS2V5VCcsIHNoaWZ0S2V5OiAnVCcsIGtleTogJ3QnIH0sXG4gICAgS2V5VTogeyBrZXlDb2RlOiA4NSwgY29kZTogJ0tleVUnLCBzaGlmdEtleTogJ1UnLCBrZXk6ICd1JyB9LFxuICAgIEtleVY6IHsga2V5Q29kZTogODYsIGNvZGU6ICdLZXlWJywgc2hpZnRLZXk6ICdWJywga2V5OiAndicgfSxcbiAgICBLZXlXOiB7IGtleUNvZGU6IDg3LCBjb2RlOiAnS2V5VycsIHNoaWZ0S2V5OiAnVycsIGtleTogJ3cnIH0sXG4gICAgS2V5WDogeyBrZXlDb2RlOiA4OCwgY29kZTogJ0tleVgnLCBzaGlmdEtleTogJ1gnLCBrZXk6ICd4JyB9LFxuICAgIEtleVk6IHsga2V5Q29kZTogODksIGNvZGU6ICdLZXlZJywgc2hpZnRLZXk6ICdZJywga2V5OiAneScgfSxcbiAgICBLZXlaOiB7IGtleUNvZGU6IDkwLCBjb2RlOiAnS2V5WicsIHNoaWZ0S2V5OiAnWicsIGtleTogJ3onIH0sXG4gICAgTWV0YUxlZnQ6IHsga2V5Q29kZTogOTEsIGNvZGU6ICdNZXRhTGVmdCcsIGtleTogJ01ldGEnLCBsb2NhdGlvbjogMSB9LFxuICAgIE1ldGFSaWdodDogeyBrZXlDb2RlOiA5MiwgY29kZTogJ01ldGFSaWdodCcsIGtleTogJ01ldGEnLCBsb2NhdGlvbjogMiB9LFxuICAgIENvbnRleHRNZW51OiB7IGtleUNvZGU6IDkzLCBjb2RlOiAnQ29udGV4dE1lbnUnLCBrZXk6ICdDb250ZXh0TWVudScgfSxcbiAgICBOdW1wYWRNdWx0aXBseToge1xuICAgICAgICBrZXlDb2RlOiAxMDYsXG4gICAgICAgIGNvZGU6ICdOdW1wYWRNdWx0aXBseScsXG4gICAgICAgIGtleTogJyonLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIE51bXBhZEFkZDogeyBrZXlDb2RlOiAxMDcsIGNvZGU6ICdOdW1wYWRBZGQnLCBrZXk6ICcrJywgbG9jYXRpb246IDMgfSxcbiAgICBOdW1wYWRTdWJ0cmFjdDoge1xuICAgICAgICBrZXlDb2RlOiAxMDksXG4gICAgICAgIGNvZGU6ICdOdW1wYWRTdWJ0cmFjdCcsXG4gICAgICAgIGtleTogJy0nLFxuICAgICAgICBsb2NhdGlvbjogMyxcbiAgICB9LFxuICAgIE51bXBhZERpdmlkZTogeyBrZXlDb2RlOiAxMTEsIGNvZGU6ICdOdW1wYWREaXZpZGUnLCBrZXk6ICcvJywgbG9jYXRpb246IDMgfSxcbiAgICBGMTogeyBrZXlDb2RlOiAxMTIsIGNvZGU6ICdGMScsIGtleTogJ0YxJyB9LFxuICAgIEYyOiB7IGtleUNvZGU6IDExMywgY29kZTogJ0YyJywga2V5OiAnRjInIH0sXG4gICAgRjM6IHsga2V5Q29kZTogMTE0LCBjb2RlOiAnRjMnLCBrZXk6ICdGMycgfSxcbiAgICBGNDogeyBrZXlDb2RlOiAxMTUsIGNvZGU6ICdGNCcsIGtleTogJ0Y0JyB9LFxuICAgIEY1OiB7IGtleUNvZGU6IDExNiwgY29kZTogJ0Y1Jywga2V5OiAnRjUnIH0sXG4gICAgRjY6IHsga2V5Q29kZTogMTE3LCBjb2RlOiAnRjYnLCBrZXk6ICdGNicgfSxcbiAgICBGNzogeyBrZXlDb2RlOiAxMTgsIGNvZGU6ICdGNycsIGtleTogJ0Y3JyB9LFxuICAgIEY4OiB7IGtleUNvZGU6IDExOSwgY29kZTogJ0Y4Jywga2V5OiAnRjgnIH0sXG4gICAgRjk6IHsga2V5Q29kZTogMTIwLCBjb2RlOiAnRjknLCBrZXk6ICdGOScgfSxcbiAgICBGMTA6IHsga2V5Q29kZTogMTIxLCBjb2RlOiAnRjEwJywga2V5OiAnRjEwJyB9LFxuICAgIEYxMTogeyBrZXlDb2RlOiAxMjIsIGNvZGU6ICdGMTEnLCBrZXk6ICdGMTEnIH0sXG4gICAgRjEyOiB7IGtleUNvZGU6IDEyMywgY29kZTogJ0YxMicsIGtleTogJ0YxMicgfSxcbiAgICBGMTM6IHsga2V5Q29kZTogMTI0LCBjb2RlOiAnRjEzJywga2V5OiAnRjEzJyB9LFxuICAgIEYxNDogeyBrZXlDb2RlOiAxMjUsIGNvZGU6ICdGMTQnLCBrZXk6ICdGMTQnIH0sXG4gICAgRjE1OiB7IGtleUNvZGU6IDEyNiwgY29kZTogJ0YxNScsIGtleTogJ0YxNScgfSxcbiAgICBGMTY6IHsga2V5Q29kZTogMTI3LCBjb2RlOiAnRjE2Jywga2V5OiAnRjE2JyB9LFxuICAgIEYxNzogeyBrZXlDb2RlOiAxMjgsIGNvZGU6ICdGMTcnLCBrZXk6ICdGMTcnIH0sXG4gICAgRjE4OiB7IGtleUNvZGU6IDEyOSwgY29kZTogJ0YxOCcsIGtleTogJ0YxOCcgfSxcbiAgICBGMTk6IHsga2V5Q29kZTogMTMwLCBjb2RlOiAnRjE5Jywga2V5OiAnRjE5JyB9LFxuICAgIEYyMDogeyBrZXlDb2RlOiAxMzEsIGNvZGU6ICdGMjAnLCBrZXk6ICdGMjAnIH0sXG4gICAgRjIxOiB7IGtleUNvZGU6IDEzMiwgY29kZTogJ0YyMScsIGtleTogJ0YyMScgfSxcbiAgICBGMjI6IHsga2V5Q29kZTogMTMzLCBjb2RlOiAnRjIyJywga2V5OiAnRjIyJyB9LFxuICAgIEYyMzogeyBrZXlDb2RlOiAxMzQsIGNvZGU6ICdGMjMnLCBrZXk6ICdGMjMnIH0sXG4gICAgRjI0OiB7IGtleUNvZGU6IDEzNSwgY29kZTogJ0YyNCcsIGtleTogJ0YyNCcgfSxcbiAgICBOdW1Mb2NrOiB7IGtleUNvZGU6IDE0NCwgY29kZTogJ051bUxvY2snLCBrZXk6ICdOdW1Mb2NrJyB9LFxuICAgIFNjcm9sbExvY2s6IHsga2V5Q29kZTogMTQ1LCBjb2RlOiAnU2Nyb2xsTG9jaycsIGtleTogJ1Njcm9sbExvY2snIH0sXG4gICAgQXVkaW9Wb2x1bWVNdXRlOiB7XG4gICAgICAgIGtleUNvZGU6IDE3MyxcbiAgICAgICAgY29kZTogJ0F1ZGlvVm9sdW1lTXV0ZScsXG4gICAgICAgIGtleTogJ0F1ZGlvVm9sdW1lTXV0ZScsXG4gICAgfSxcbiAgICBBdWRpb1ZvbHVtZURvd246IHtcbiAgICAgICAga2V5Q29kZTogMTc0LFxuICAgICAgICBjb2RlOiAnQXVkaW9Wb2x1bWVEb3duJyxcbiAgICAgICAga2V5OiAnQXVkaW9Wb2x1bWVEb3duJyxcbiAgICB9LFxuICAgIEF1ZGlvVm9sdW1lVXA6IHsga2V5Q29kZTogMTc1LCBjb2RlOiAnQXVkaW9Wb2x1bWVVcCcsIGtleTogJ0F1ZGlvVm9sdW1lVXAnIH0sXG4gICAgTWVkaWFUcmFja05leHQ6IHtcbiAgICAgICAga2V5Q29kZTogMTc2LFxuICAgICAgICBjb2RlOiAnTWVkaWFUcmFja05leHQnLFxuICAgICAgICBrZXk6ICdNZWRpYVRyYWNrTmV4dCcsXG4gICAgfSxcbiAgICBNZWRpYVRyYWNrUHJldmlvdXM6IHtcbiAgICAgICAga2V5Q29kZTogMTc3LFxuICAgICAgICBjb2RlOiAnTWVkaWFUcmFja1ByZXZpb3VzJyxcbiAgICAgICAga2V5OiAnTWVkaWFUcmFja1ByZXZpb3VzJyxcbiAgICB9LFxuICAgIE1lZGlhU3RvcDogeyBrZXlDb2RlOiAxNzgsIGNvZGU6ICdNZWRpYVN0b3AnLCBrZXk6ICdNZWRpYVN0b3AnIH0sXG4gICAgTWVkaWFQbGF5UGF1c2U6IHtcbiAgICAgICAga2V5Q29kZTogMTc5LFxuICAgICAgICBjb2RlOiAnTWVkaWFQbGF5UGF1c2UnLFxuICAgICAgICBrZXk6ICdNZWRpYVBsYXlQYXVzZScsXG4gICAgfSxcbiAgICBTZW1pY29sb246IHsga2V5Q29kZTogMTg2LCBjb2RlOiAnU2VtaWNvbG9uJywgc2hpZnRLZXk6ICc6Jywga2V5OiAnOycgfSxcbiAgICBFcXVhbDogeyBrZXlDb2RlOiAxODcsIGNvZGU6ICdFcXVhbCcsIHNoaWZ0S2V5OiAnKycsIGtleTogJz0nIH0sXG4gICAgTnVtcGFkRXF1YWw6IHsga2V5Q29kZTogMTg3LCBjb2RlOiAnTnVtcGFkRXF1YWwnLCBrZXk6ICc9JywgbG9jYXRpb246IDMgfSxcbiAgICBDb21tYTogeyBrZXlDb2RlOiAxODgsIGNvZGU6ICdDb21tYScsIHNoaWZ0S2V5OiAnPCcsIGtleTogJywnIH0sXG4gICAgTWludXM6IHsga2V5Q29kZTogMTg5LCBjb2RlOiAnTWludXMnLCBzaGlmdEtleTogJ18nLCBrZXk6ICctJyB9LFxuICAgIFBlcmlvZDogeyBrZXlDb2RlOiAxOTAsIGNvZGU6ICdQZXJpb2QnLCBzaGlmdEtleTogJz4nLCBrZXk6ICcuJyB9LFxuICAgIFNsYXNoOiB7IGtleUNvZGU6IDE5MSwgY29kZTogJ1NsYXNoJywgc2hpZnRLZXk6ICc/Jywga2V5OiAnLycgfSxcbiAgICBCYWNrcXVvdGU6IHsga2V5Q29kZTogMTkyLCBjb2RlOiAnQmFja3F1b3RlJywgc2hpZnRLZXk6ICd+Jywga2V5OiAnYCcgfSxcbiAgICBCcmFja2V0TGVmdDogeyBrZXlDb2RlOiAyMTksIGNvZGU6ICdCcmFja2V0TGVmdCcsIHNoaWZ0S2V5OiAneycsIGtleTogJ1snIH0sXG4gICAgQmFja3NsYXNoOiB7IGtleUNvZGU6IDIyMCwgY29kZTogJ0JhY2tzbGFzaCcsIHNoaWZ0S2V5OiAnfCcsIGtleTogJ1xcXFwnIH0sXG4gICAgQnJhY2tldFJpZ2h0OiB7IGtleUNvZGU6IDIyMSwgY29kZTogJ0JyYWNrZXRSaWdodCcsIHNoaWZ0S2V5OiAnfScsIGtleTogJ10nIH0sXG4gICAgUXVvdGU6IHsga2V5Q29kZTogMjIyLCBjb2RlOiAnUXVvdGUnLCBzaGlmdEtleTogJ1wiJywga2V5OiBcIidcIiB9LFxuICAgIEFsdEdyYXBoOiB7IGtleUNvZGU6IDIyNSwgY29kZTogJ0FsdEdyYXBoJywga2V5OiAnQWx0R3JhcGgnIH0sXG4gICAgUHJvcHM6IHsga2V5Q29kZTogMjQ3LCBjb2RlOiAnUHJvcHMnLCBrZXk6ICdDclNlbCcgfSxcbiAgICBDYW5jZWw6IHsga2V5Q29kZTogMywga2V5OiAnQ2FuY2VsJywgY29kZTogJ0Fib3J0JyB9LFxuICAgIENsZWFyOiB7IGtleUNvZGU6IDEyLCBrZXk6ICdDbGVhcicsIGNvZGU6ICdOdW1wYWQ1JywgbG9jYXRpb246IDMgfSxcbiAgICBTaGlmdDogeyBrZXlDb2RlOiAxNiwga2V5OiAnU2hpZnQnLCBjb2RlOiAnU2hpZnRMZWZ0JywgbG9jYXRpb246IDEgfSxcbiAgICBDb250cm9sOiB7IGtleUNvZGU6IDE3LCBrZXk6ICdDb250cm9sJywgY29kZTogJ0NvbnRyb2xMZWZ0JywgbG9jYXRpb246IDEgfSxcbiAgICBBbHQ6IHsga2V5Q29kZTogMTgsIGtleTogJ0FsdCcsIGNvZGU6ICdBbHRMZWZ0JywgbG9jYXRpb246IDEgfSxcbiAgICBBY2NlcHQ6IHsga2V5Q29kZTogMzAsIGtleTogJ0FjY2VwdCcgfSxcbiAgICBNb2RlQ2hhbmdlOiB7IGtleUNvZGU6IDMxLCBrZXk6ICdNb2RlQ2hhbmdlJyB9LFxuICAgICcgJzogeyBrZXlDb2RlOiAzMiwga2V5OiAnICcsIGNvZGU6ICdTcGFjZScgfSxcbiAgICBQcmludDogeyBrZXlDb2RlOiA0Miwga2V5OiAnUHJpbnQnIH0sXG4gICAgRXhlY3V0ZTogeyBrZXlDb2RlOiA0Mywga2V5OiAnRXhlY3V0ZScsIGNvZGU6ICdPcGVuJyB9LFxuICAgICdcXHUwMDAwJzogeyBrZXlDb2RlOiA0Niwga2V5OiAnXFx1MDAwMCcsIGNvZGU6ICdOdW1wYWREZWNpbWFsJywgbG9jYXRpb246IDMgfSxcbiAgICBhOiB7IGtleUNvZGU6IDY1LCBrZXk6ICdhJywgY29kZTogJ0tleUEnIH0sXG4gICAgYjogeyBrZXlDb2RlOiA2Niwga2V5OiAnYicsIGNvZGU6ICdLZXlCJyB9LFxuICAgIGM6IHsga2V5Q29kZTogNjcsIGtleTogJ2MnLCBjb2RlOiAnS2V5QycgfSxcbiAgICBkOiB7IGtleUNvZGU6IDY4LCBrZXk6ICdkJywgY29kZTogJ0tleUQnIH0sXG4gICAgZTogeyBrZXlDb2RlOiA2OSwga2V5OiAnZScsIGNvZGU6ICdLZXlFJyB9LFxuICAgIGY6IHsga2V5Q29kZTogNzAsIGtleTogJ2YnLCBjb2RlOiAnS2V5RicgfSxcbiAgICBnOiB7IGtleUNvZGU6IDcxLCBrZXk6ICdnJywgY29kZTogJ0tleUcnIH0sXG4gICAgaDogeyBrZXlDb2RlOiA3Miwga2V5OiAnaCcsIGNvZGU6ICdLZXlIJyB9LFxuICAgIGk6IHsga2V5Q29kZTogNzMsIGtleTogJ2knLCBjb2RlOiAnS2V5SScgfSxcbiAgICBqOiB7IGtleUNvZGU6IDc0LCBrZXk6ICdqJywgY29kZTogJ0tleUonIH0sXG4gICAgazogeyBrZXlDb2RlOiA3NSwga2V5OiAnaycsIGNvZGU6ICdLZXlLJyB9LFxuICAgIGw6IHsga2V5Q29kZTogNzYsIGtleTogJ2wnLCBjb2RlOiAnS2V5TCcgfSxcbiAgICBtOiB7IGtleUNvZGU6IDc3LCBrZXk6ICdtJywgY29kZTogJ0tleU0nIH0sXG4gICAgbjogeyBrZXlDb2RlOiA3OCwga2V5OiAnbicsIGNvZGU6ICdLZXlOJyB9LFxuICAgIG86IHsga2V5Q29kZTogNzksIGtleTogJ28nLCBjb2RlOiAnS2V5TycgfSxcbiAgICBwOiB7IGtleUNvZGU6IDgwLCBrZXk6ICdwJywgY29kZTogJ0tleVAnIH0sXG4gICAgcTogeyBrZXlDb2RlOiA4MSwga2V5OiAncScsIGNvZGU6ICdLZXlRJyB9LFxuICAgIHI6IHsga2V5Q29kZTogODIsIGtleTogJ3InLCBjb2RlOiAnS2V5UicgfSxcbiAgICBzOiB7IGtleUNvZGU6IDgzLCBrZXk6ICdzJywgY29kZTogJ0tleVMnIH0sXG4gICAgdDogeyBrZXlDb2RlOiA4NCwga2V5OiAndCcsIGNvZGU6ICdLZXlUJyB9LFxuICAgIHU6IHsga2V5Q29kZTogODUsIGtleTogJ3UnLCBjb2RlOiAnS2V5VScgfSxcbiAgICB2OiB7IGtleUNvZGU6IDg2LCBrZXk6ICd2JywgY29kZTogJ0tleVYnIH0sXG4gICAgdzogeyBrZXlDb2RlOiA4Nywga2V5OiAndycsIGNvZGU6ICdLZXlXJyB9LFxuICAgIHg6IHsga2V5Q29kZTogODgsIGtleTogJ3gnLCBjb2RlOiAnS2V5WCcgfSxcbiAgICB5OiB7IGtleUNvZGU6IDg5LCBrZXk6ICd5JywgY29kZTogJ0tleVknIH0sXG4gICAgejogeyBrZXlDb2RlOiA5MCwga2V5OiAneicsIGNvZGU6ICdLZXlaJyB9LFxuICAgIE1ldGE6IHsga2V5Q29kZTogOTEsIGtleTogJ01ldGEnLCBjb2RlOiAnTWV0YUxlZnQnLCBsb2NhdGlvbjogMSB9LFxuICAgICcqJzogeyBrZXlDb2RlOiAxMDYsIGtleTogJyonLCBjb2RlOiAnTnVtcGFkTXVsdGlwbHknLCBsb2NhdGlvbjogMyB9LFxuICAgICcrJzogeyBrZXlDb2RlOiAxMDcsIGtleTogJysnLCBjb2RlOiAnTnVtcGFkQWRkJywgbG9jYXRpb246IDMgfSxcbiAgICAnLSc6IHsga2V5Q29kZTogMTA5LCBrZXk6ICctJywgY29kZTogJ051bXBhZFN1YnRyYWN0JywgbG9jYXRpb246IDMgfSxcbiAgICAnLyc6IHsga2V5Q29kZTogMTExLCBrZXk6ICcvJywgY29kZTogJ051bXBhZERpdmlkZScsIGxvY2F0aW9uOiAzIH0sXG4gICAgJzsnOiB7IGtleUNvZGU6IDE4Niwga2V5OiAnOycsIGNvZGU6ICdTZW1pY29sb24nIH0sXG4gICAgJz0nOiB7IGtleUNvZGU6IDE4Nywga2V5OiAnPScsIGNvZGU6ICdFcXVhbCcgfSxcbiAgICAnLCc6IHsga2V5Q29kZTogMTg4LCBrZXk6ICcsJywgY29kZTogJ0NvbW1hJyB9LFxuICAgICcuJzogeyBrZXlDb2RlOiAxOTAsIGtleTogJy4nLCBjb2RlOiAnUGVyaW9kJyB9LFxuICAgICdgJzogeyBrZXlDb2RlOiAxOTIsIGtleTogJ2AnLCBjb2RlOiAnQmFja3F1b3RlJyB9LFxuICAgICdbJzogeyBrZXlDb2RlOiAyMTksIGtleTogJ1snLCBjb2RlOiAnQnJhY2tldExlZnQnIH0sXG4gICAgJ1xcXFwnOiB7IGtleUNvZGU6IDIyMCwga2V5OiAnXFxcXCcsIGNvZGU6ICdCYWNrc2xhc2gnIH0sXG4gICAgJ10nOiB7IGtleUNvZGU6IDIyMSwga2V5OiAnXScsIGNvZGU6ICdCcmFja2V0UmlnaHQnIH0sXG4gICAgXCInXCI6IHsga2V5Q29kZTogMjIyLCBrZXk6IFwiJ1wiLCBjb2RlOiAnUXVvdGUnIH0sXG4gICAgQXR0bjogeyBrZXlDb2RlOiAyNDYsIGtleTogJ0F0dG4nIH0sXG4gICAgQ3JTZWw6IHsga2V5Q29kZTogMjQ3LCBrZXk6ICdDclNlbCcsIGNvZGU6ICdQcm9wcycgfSxcbiAgICBFeFNlbDogeyBrZXlDb2RlOiAyNDgsIGtleTogJ0V4U2VsJyB9LFxuICAgIEVyYXNlRW9mOiB7IGtleUNvZGU6IDI0OSwga2V5OiAnRXJhc2VFb2YnIH0sXG4gICAgUGxheTogeyBrZXlDb2RlOiAyNTAsIGtleTogJ1BsYXknIH0sXG4gICAgWm9vbU91dDogeyBrZXlDb2RlOiAyNTEsIGtleTogJ1pvb21PdXQnIH0sXG4gICAgJyknOiB7IGtleUNvZGU6IDQ4LCBrZXk6ICcpJywgY29kZTogJ0RpZ2l0MCcgfSxcbiAgICAnISc6IHsga2V5Q29kZTogNDksIGtleTogJyEnLCBjb2RlOiAnRGlnaXQxJyB9LFxuICAgICdAJzogeyBrZXlDb2RlOiA1MCwga2V5OiAnQCcsIGNvZGU6ICdEaWdpdDInIH0sXG4gICAgJyMnOiB7IGtleUNvZGU6IDUxLCBrZXk6ICcjJywgY29kZTogJ0RpZ2l0MycgfSxcbiAgICAkOiB7IGtleUNvZGU6IDUyLCBrZXk6ICckJywgY29kZTogJ0RpZ2l0NCcgfSxcbiAgICAnJSc6IHsga2V5Q29kZTogNTMsIGtleTogJyUnLCBjb2RlOiAnRGlnaXQ1JyB9LFxuICAgICdeJzogeyBrZXlDb2RlOiA1NCwga2V5OiAnXicsIGNvZGU6ICdEaWdpdDYnIH0sXG4gICAgJyYnOiB7IGtleUNvZGU6IDU1LCBrZXk6ICcmJywgY29kZTogJ0RpZ2l0NycgfSxcbiAgICAnKCc6IHsga2V5Q29kZTogNTcsIGtleTogJygnLCBjb2RlOiAnRGlnaXQ5JyB9LFxuICAgIEE6IHsga2V5Q29kZTogNjUsIGtleTogJ0EnLCBjb2RlOiAnS2V5QScgfSxcbiAgICBCOiB7IGtleUNvZGU6IDY2LCBrZXk6ICdCJywgY29kZTogJ0tleUInIH0sXG4gICAgQzogeyBrZXlDb2RlOiA2Nywga2V5OiAnQycsIGNvZGU6ICdLZXlDJyB9LFxuICAgIEQ6IHsga2V5Q29kZTogNjgsIGtleTogJ0QnLCBjb2RlOiAnS2V5RCcgfSxcbiAgICBFOiB7IGtleUNvZGU6IDY5LCBrZXk6ICdFJywgY29kZTogJ0tleUUnIH0sXG4gICAgRjogeyBrZXlDb2RlOiA3MCwga2V5OiAnRicsIGNvZGU6ICdLZXlGJyB9LFxuICAgIEc6IHsga2V5Q29kZTogNzEsIGtleTogJ0cnLCBjb2RlOiAnS2V5RycgfSxcbiAgICBIOiB7IGtleUNvZGU6IDcyLCBrZXk6ICdIJywgY29kZTogJ0tleUgnIH0sXG4gICAgSTogeyBrZXlDb2RlOiA3Mywga2V5OiAnSScsIGNvZGU6ICdLZXlJJyB9LFxuICAgIEo6IHsga2V5Q29kZTogNzQsIGtleTogJ0onLCBjb2RlOiAnS2V5SicgfSxcbiAgICBLOiB7IGtleUNvZGU6IDc1LCBrZXk6ICdLJywgY29kZTogJ0tleUsnIH0sXG4gICAgTDogeyBrZXlDb2RlOiA3Niwga2V5OiAnTCcsIGNvZGU6ICdLZXlMJyB9LFxuICAgIE06IHsga2V5Q29kZTogNzcsIGtleTogJ00nLCBjb2RlOiAnS2V5TScgfSxcbiAgICBOOiB7IGtleUNvZGU6IDc4LCBrZXk6ICdOJywgY29kZTogJ0tleU4nIH0sXG4gICAgTzogeyBrZXlDb2RlOiA3OSwga2V5OiAnTycsIGNvZGU6ICdLZXlPJyB9LFxuICAgIFA6IHsga2V5Q29kZTogODAsIGtleTogJ1AnLCBjb2RlOiAnS2V5UCcgfSxcbiAgICBROiB7IGtleUNvZGU6IDgxLCBrZXk6ICdRJywgY29kZTogJ0tleVEnIH0sXG4gICAgUjogeyBrZXlDb2RlOiA4Miwga2V5OiAnUicsIGNvZGU6ICdLZXlSJyB9LFxuICAgIFM6IHsga2V5Q29kZTogODMsIGtleTogJ1MnLCBjb2RlOiAnS2V5UycgfSxcbiAgICBUOiB7IGtleUNvZGU6IDg0LCBrZXk6ICdUJywgY29kZTogJ0tleVQnIH0sXG4gICAgVTogeyBrZXlDb2RlOiA4NSwga2V5OiAnVScsIGNvZGU6ICdLZXlVJyB9LFxuICAgIFY6IHsga2V5Q29kZTogODYsIGtleTogJ1YnLCBjb2RlOiAnS2V5VicgfSxcbiAgICBXOiB7IGtleUNvZGU6IDg3LCBrZXk6ICdXJywgY29kZTogJ0tleVcnIH0sXG4gICAgWDogeyBrZXlDb2RlOiA4OCwga2V5OiAnWCcsIGNvZGU6ICdLZXlYJyB9LFxuICAgIFk6IHsga2V5Q29kZTogODksIGtleTogJ1knLCBjb2RlOiAnS2V5WScgfSxcbiAgICBaOiB7IGtleUNvZGU6IDkwLCBrZXk6ICdaJywgY29kZTogJ0tleVonIH0sXG4gICAgJzonOiB7IGtleUNvZGU6IDE4Niwga2V5OiAnOicsIGNvZGU6ICdTZW1pY29sb24nIH0sXG4gICAgJzwnOiB7IGtleUNvZGU6IDE4OCwga2V5OiAnPCcsIGNvZGU6ICdDb21tYScgfSxcbiAgICBfOiB7IGtleUNvZGU6IDE4OSwga2V5OiAnXycsIGNvZGU6ICdNaW51cycgfSxcbiAgICAnPic6IHsga2V5Q29kZTogMTkwLCBrZXk6ICc+JywgY29kZTogJ1BlcmlvZCcgfSxcbiAgICAnPyc6IHsga2V5Q29kZTogMTkxLCBrZXk6ICc/JywgY29kZTogJ1NsYXNoJyB9LFxuICAgICd+JzogeyBrZXlDb2RlOiAxOTIsIGtleTogJ34nLCBjb2RlOiAnQmFja3F1b3RlJyB9LFxuICAgICd7JzogeyBrZXlDb2RlOiAyMTksIGtleTogJ3snLCBjb2RlOiAnQnJhY2tldExlZnQnIH0sXG4gICAgJ3wnOiB7IGtleUNvZGU6IDIyMCwga2V5OiAnfCcsIGNvZGU6ICdCYWNrc2xhc2gnIH0sXG4gICAgJ30nOiB7IGtleUNvZGU6IDIyMSwga2V5OiAnfScsIGNvZGU6ICdCcmFja2V0UmlnaHQnIH0sXG4gICAgJ1wiJzogeyBrZXlDb2RlOiAyMjIsIGtleTogJ1wiJywgY29kZTogJ1F1b3RlJyB9LFxuICAgIFNvZnRMZWZ0OiB7IGtleTogJ1NvZnRMZWZ0JywgY29kZTogJ1NvZnRMZWZ0JywgbG9jYXRpb246IDQgfSxcbiAgICBTb2Z0UmlnaHQ6IHsga2V5OiAnU29mdFJpZ2h0JywgY29kZTogJ1NvZnRSaWdodCcsIGxvY2F0aW9uOiA0IH0sXG4gICAgQ2FtZXJhOiB7IGtleUNvZGU6IDQ0LCBrZXk6ICdDYW1lcmEnLCBjb2RlOiAnQ2FtZXJhJywgbG9jYXRpb246IDQgfSxcbiAgICBDYWxsOiB7IGtleTogJ0NhbGwnLCBjb2RlOiAnQ2FsbCcsIGxvY2F0aW9uOiA0IH0sXG4gICAgRW5kQ2FsbDogeyBrZXlDb2RlOiA5NSwga2V5OiAnRW5kQ2FsbCcsIGNvZGU6ICdFbmRDYWxsJywgbG9jYXRpb246IDQgfSxcbiAgICBWb2x1bWVEb3duOiB7XG4gICAgICAgIGtleUNvZGU6IDE4MixcbiAgICAgICAga2V5OiAnVm9sdW1lRG93bicsXG4gICAgICAgIGNvZGU6ICdWb2x1bWVEb3duJyxcbiAgICAgICAgbG9jYXRpb246IDQsXG4gICAgfSxcbiAgICBWb2x1bWVVcDogeyBrZXlDb2RlOiAxODMsIGtleTogJ1ZvbHVtZVVwJywgY29kZTogJ1ZvbHVtZVVwJywgbG9jYXRpb246IDQgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VU0tleWJvYXJkTGF5b3V0LmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBFeGVjdXRpb25Db250ZXh0IH0gZnJvbSAnLi9FeGVjdXRpb25Db250ZXh0LmpzJztcbmltcG9ydCB7IEpTSGFuZGxlIH0gZnJvbSAnLi9KU0hhbmRsZS5qcyc7XG4vKipcbiAqIFRoZSBXZWJXb3JrZXIgY2xhc3MgcmVwcmVzZW50cyBhXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSSB8IFdlYldvcmtlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBldmVudHMgYHdvcmtlcmNyZWF0ZWRgIGFuZCBgd29ya2VyZGVzdHJveWVkYCBhcmUgZW1pdHRlZCBvbiB0aGUgcGFnZVxuICogb2JqZWN0IHRvIHNpZ25hbCB0aGUgd29ya2VyIGxpZmVjeWNsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHBhZ2Uub24oJ3dvcmtlcmNyZWF0ZWQnLCB3b3JrZXIgPT4gY29uc29sZS5sb2coJ1dvcmtlciBjcmVhdGVkOiAnICsgd29ya2VyLnVybCgpKSk7XG4gKiBwYWdlLm9uKCd3b3JrZXJkZXN0cm95ZWQnLCB3b3JrZXIgPT4gY29uc29sZS5sb2coJ1dvcmtlciBkZXN0cm95ZWQ6ICcgKyB3b3JrZXIudXJsKCkpKTtcbiAqXG4gKiBjb25zb2xlLmxvZygnQ3VycmVudCB3b3JrZXJzOicpO1xuICogZm9yIChjb25zdCB3b3JrZXIgb2YgcGFnZS53b3JrZXJzKCkpIHtcbiAqICAgY29uc29sZS5sb2coJyAgJyArIHdvcmtlci51cmwoKSk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50LCB1cmwsIGNvbnNvbGVBUElDYWxsZWQsIGV4Y2VwdGlvblRocm93bikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICAgICAgdGhpcy5fZXhlY3V0aW9uQ29udGV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoeCkgPT4gKHRoaXMuX2V4ZWN1dGlvbkNvbnRleHRDYWxsYmFjayA9IHgpKTtcbiAgICAgICAgbGV0IGpzSGFuZGxlRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uY2UoJ1J1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtZnVuY3Rpb24tcmV0dXJuLXR5cGVcbiAgICAgICAgICAgIGpzSGFuZGxlRmFjdG9yeSA9IChyZW1vdGVPYmplY3QpID0+IG5ldyBKU0hhbmRsZShleGVjdXRpb25Db250ZXh0LCBjbGllbnQsIHJlbW90ZU9iamVjdCk7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25Db250ZXh0ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoY2xpZW50LCBldmVudC5jb250ZXh0LCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGlvbkNvbnRleHRDYWxsYmFjayhleGVjdXRpb25Db250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgbWlnaHQgZmFpbCBpZiB0aGUgdGFyZ2V0IGlzIGNsb3NlZCBiZWZvcmUgd2UgcmVjZWl2ZSBhbGwgZXhlY3V0aW9uIGNvbnRleHRzLlxuICAgICAgICB0aGlzLl9jbGllbnQuc2VuZCgnUnVudGltZS5lbmFibGUnKS5jYXRjaChkZWJ1Z0Vycm9yKTtcbiAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdSdW50aW1lLmNvbnNvbGVBUElDYWxsZWQnLCAoZXZlbnQpID0+IGNvbnNvbGVBUElDYWxsZWQoZXZlbnQudHlwZSwgZXZlbnQuYXJncy5tYXAoanNIYW5kbGVGYWN0b3J5KSwgZXZlbnQuc3RhY2tUcmFjZSkpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ1J1bnRpbWUuZXhjZXB0aW9uVGhyb3duJywgKGV4Y2VwdGlvbikgPT4gZXhjZXB0aW9uVGhyb3duKGV4Y2VwdGlvbi5leGNlcHRpb25EZXRhaWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSBVUkwgb2YgdGhpcyB3ZWIgd29ya2VyLlxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRXhlY3V0aW9uQ29udGV4dCB0aGUgV2ViV29ya2VyIHJ1bnMgaW5cbiAgICAgKiBAcmV0dXJucyBUaGUgRXhlY3V0aW9uQ29udGV4dCB0aGUgd2ViIHdvcmtlciBydW5zIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGlvbkNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db250ZXh0UHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byB0aGUgYHdvcmtlci5ldmFsdWF0ZWAgcmV0dXJucyBhIFByb21pc2UsIHRoZW5cbiAgICAgKiBgd29ya2VyLmV2YWx1YXRlYCB3b3VsZCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGFuZCByZXR1cm4gaXRzXG4gICAgICogdmFsdWUuIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlIGB3b3JrZXIuZXZhbHVhdGVgIHJldHVybnMgYVxuICAgICAqIG5vbi1zZXJpYWxpemFibGUgdmFsdWUsIHRoZW4gYHdvcmtlci5ldmFsdWF0ZWAgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAuXG4gICAgICogRGV2VG9vbHMgUHJvdG9jb2wgYWxzbyBzdXBwb3J0cyB0cmFuc2ZlcnJpbmcgc29tZSBhZGRpdGlvbmFsIHZhbHVlcyB0aGF0XG4gICAgICogYXJlIG5vdCBzZXJpYWxpemFibGUgYnkgYEpTT05gOiBgLTBgLCBgTmFOYCwgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZFxuICAgICAqIGJpZ2ludCBsaXRlcmFscy5cbiAgICAgKiBTaG9ydGN1dCBmb3IgYGF3YWl0IHdvcmtlci5leGVjdXRpb25Db250ZXh0KCkpLmV2YWx1YXRlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2VGdW5jdGlvbiAtIEZ1bmN0aW9uIHRvIGJlIGV2YWx1YXRlZCBpbiB0aGUgd29ya2VyIGNvbnRleHQuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgdG8gcGFzcyB0byBgcGFnZUZ1bmN0aW9uYC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgYHBhZ2VGdW5jdGlvbmAuXG4gICAgICovXG4gICAgYXN5bmMgZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5fZXhlY3V0aW9uQ29udGV4dFByb21pc2UpLmV2YWx1YXRlKHBhZ2VGdW5jdGlvbiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBgd29ya2VyLmV2YWx1YXRlYCBhbmQgYHdvcmtlci5ldmFsdWF0ZUhhbmRsZWBcbiAgICAgKiBpcyB0aGF0IGB3b3JrZXIuZXZhbHVhdGVIYW5kbGVgIHJldHVybnMgaW4tcGFnZSBvYmplY3QgKEpTSGFuZGxlKS4gSWYgdGhlXG4gICAgICogZnVuY3Rpb24gcGFzc2VkIHRvIHRoZSBgd29ya2VyLmV2YWx1YXRlSGFuZGxlYCByZXR1cm5zIGEgYFByb21pc2VgLCB0aGVuXG4gICAgICogYHdvcmtlci5ldmFsdWF0ZUhhbmRsZWAgd291bGQgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuXG4gICAgICogaXRzIHZhbHVlLiBTaG9ydGN1dCBmb3JcbiAgICAgKiBgYXdhaXQgd29ya2VyLmV4ZWN1dGlvbkNvbnRleHQoKSkuZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlRnVuY3Rpb24gLSBGdW5jdGlvbiB0byBiZSBldmFsdWF0ZWQgaW4gdGhlIHBhZ2UgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyB0byBwYXNzIHRvIGBwYWdlRnVuY3Rpb25gLlxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiBgcGFnZUZ1bmN0aW9uYC5cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZUhhbmRsZShwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLl9leGVjdXRpb25Db250ZXh0UHJvbWlzZSkuZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJXb3JrZXIuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIHRydXRoeS5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdyBpZiB0aGUgdmFsdWUgaXMgbm90IHRydXRoeS5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2VydCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4ge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQuanMnO1xuLyogVXNlIHRoZSBnbG9iYWwgdmVyc2lvbiBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlciwgZWxzZSBsb2FkIHRoZSBub2RlLWZldGNoIG1vZHVsZS4gKi9cbmV4cG9ydCBjb25zdCBnZXRGZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gaXNOb2RlID8gYXdhaXQgaW1wb3J0KCdub2RlLWZldGNoJykgOiBnbG9iYWxUaGlzLmZldGNoO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IFRpbWVvdXRFcnJvciB9IGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9EZWJ1Zy5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9lbnZpcm9ubWVudC5qcyc7XG5leHBvcnQgY29uc3QgZGVidWdFcnJvciA9IGRlYnVnKCdwdXBwZXRlZXI6ZXJyb3InKTtcbmZ1bmN0aW9uIGdldEV4Y2VwdGlvbk1lc3NhZ2UoZXhjZXB0aW9uRGV0YWlscykge1xuICAgIGlmIChleGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbilcbiAgICAgICAgcmV0dXJuIChleGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbi5kZXNjcmlwdGlvbiB8fCBleGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgbGV0IG1lc3NhZ2UgPSBleGNlcHRpb25EZXRhaWxzLnRleHQ7XG4gICAgaWYgKGV4Y2VwdGlvbkRldGFpbHMuc3RhY2tUcmFjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxmcmFtZSBvZiBleGNlcHRpb25EZXRhaWxzLnN0YWNrVHJhY2UuY2FsbEZyYW1lcykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBjYWxsZnJhbWUudXJsICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIGNhbGxmcmFtZS5saW5lTnVtYmVyICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIGNhbGxmcmFtZS5jb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBjYWxsZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICc8YW5vbnltb3VzPic7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGBcXG4gICAgYXQgJHtmdW5jdGlvbk5hbWV9ICgke2xvY2F0aW9ufSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gdmFsdWVGcm9tUmVtb3RlT2JqZWN0KHJlbW90ZU9iamVjdCkge1xuICAgIGFzc2VydCghcmVtb3RlT2JqZWN0Lm9iamVjdElkLCAnQ2Fubm90IGV4dHJhY3QgdmFsdWUgd2hlbiBvYmplY3RJZCBpcyBnaXZlbicpO1xuICAgIGlmIChyZW1vdGVPYmplY3QudW5zZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICBpZiAocmVtb3RlT2JqZWN0LnR5cGUgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChyZW1vdGVPYmplY3QudW5zZXJpYWxpemFibGVWYWx1ZS5yZXBsYWNlKCduJywgJycpKTtcbiAgICAgICAgc3dpdGNoIChyZW1vdGVPYmplY3QudW5zZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnLTAnOlxuICAgICAgICAgICAgICAgIHJldHVybiAtMDtcbiAgICAgICAgICAgIGNhc2UgJ05hTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGNhc2UgJ0luZmluaXR5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICBjYXNlICctSW5maW5pdHknOlxuICAgICAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdW5zZXJpYWxpemFibGUgdmFsdWU6ICcgK1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVPYmplY3QudW5zZXJpYWxpemFibGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZU9iamVjdC52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3QoY2xpZW50LCByZW1vdGVPYmplY3QpIHtcbiAgICBpZiAoIXJlbW90ZU9iamVjdC5vYmplY3RJZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGF3YWl0IGNsaWVudFxuICAgICAgICAuc2VuZCgnUnVudGltZS5yZWxlYXNlT2JqZWN0JywgeyBvYmplY3RJZDogcmVtb3RlT2JqZWN0Lm9iamVjdElkIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgLy8gRXhjZXB0aW9ucyBtaWdodCBoYXBwZW4gaW4gY2FzZSBvZiBhIHBhZ2UgYmVlbiBuYXZpZ2F0ZWQgb3IgY2xvc2VkLlxuICAgICAgICAvLyBTd2FsbG93IHRoZXNlIHNpbmNlIHRoZXkgYXJlIGhhcm1sZXNzIGFuZCB3ZSBkb24ndCBsZWFrIGFueXRoaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGVtaXR0ZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICByZXR1cm4geyBlbWl0dGVyLCBldmVudE5hbWUsIGhhbmRsZXIgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKVxuICAgICAgICBsaXN0ZW5lci5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50TmFtZSwgbGlzdGVuZXIuaGFuZGxlcik7XG4gICAgbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JFdmVudChlbWl0dGVyLCBldmVudE5hbWUsIHByZWRpY2F0ZSwgdGltZW91dCwgYWJvcnRQcm9taXNlKSB7XG4gICAgbGV0IGV2ZW50VGltZW91dCwgcmVzb2x2ZUNhbGxiYWNrLCByZWplY3RDYWxsYmFjaztcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlQ2FsbGJhY2sgPSByZXNvbHZlO1xuICAgICAgICByZWplY3RDYWxsYmFjayA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgcHJlZGljYXRlKGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlc29sdmVDYWxsYmFjayhldmVudCk7XG4gICAgfSk7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgZXZlbnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWplY3RDYWxsYmFjayhuZXcgVGltZW91dEVycm9yKCdUaW1lb3V0IGV4Y2VlZGVkIHdoaWxlIHdhaXRpbmcgZm9yIGV2ZW50JykpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoW2xpc3RlbmVyXSk7XG4gICAgICAgIGNsZWFyVGltZW91dChldmVudFRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIGFib3J0UHJvbWlzZV0pLnRoZW4oKHIpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXZhbHVhdGlvblN0cmluZyhmdW4sIC4uLmFyZ3MpIHtcbiAgICBpZiAoaXNTdHJpbmcoZnVuKSkge1xuICAgICAgICBhc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdDYW5ub3QgZXZhbHVhdGUgYSBzdHJpbmcgd2l0aCBhcmd1bWVudHMnKTtcbiAgICAgICAgcmV0dXJuIGZ1bjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplQXJndW1lbnQoYXJnKSB7XG4gICAgICAgIGlmIChPYmplY3QuaXMoYXJnLCB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIGAoJHtmdW59KSgke2FyZ3MubWFwKHNlcmlhbGl6ZUFyZ3VtZW50KS5qb2luKCcsJyl9KWA7XG59XG5mdW5jdGlvbiBwYWdlQmluZGluZ0luaXRTdHJpbmcodHlwZSwgbmFtZSkge1xuICAgIGZ1bmN0aW9uIGFkZFBhZ2VCaW5kaW5nKHR5cGUsIGJpbmRpbmdOYW1lKSB7XG4gICAgICAgIC8qIENhc3Qgd2luZG93IHRvIGFueSBoZXJlIGFzIHdlJ3JlIGFib3V0IHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGl0XG4gICAgICAgICAqIHZpYSB3aW5bYmluZGluZ05hbWVdIHdoaWNoIFR5cGVTY3JpcHQgZG9lc24ndCBsaWtlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gd2luW2JpbmRpbmdOYW1lXTtcbiAgICAgICAgd2luW2JpbmRpbmdOYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZSA9IHdpbmRvd1tiaW5kaW5nTmFtZV07XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tzID0gbWUuY2FsbGJhY2tzO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgbWUuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VxID0gKG1lLmxhc3RTZXEgfHwgMCkgKyAxO1xuICAgICAgICAgICAgbWUubGFzdFNlcSA9IHNlcTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjYWxsYmFja3Muc2V0KHNlcSwgeyByZXNvbHZlLCByZWplY3QgfSkpO1xuICAgICAgICAgICAgYmluZGluZyhKU09OLnN0cmluZ2lmeSh7IHR5cGUsIG5hbWU6IGJpbmRpbmdOYW1lLCBzZXEsIGFyZ3MgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0aW9uU3RyaW5nKGFkZFBhZ2VCaW5kaW5nLCB0eXBlLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHBhZ2VCaW5kaW5nRGVsaXZlclJlc3VsdFN0cmluZyhuYW1lLCBzZXEsIHJlc3VsdCkge1xuICAgIGZ1bmN0aW9uIGRlbGl2ZXJSZXN1bHQobmFtZSwgc2VxLCByZXN1bHQpIHtcbiAgICAgICAgd2luZG93W25hbWVdLmNhbGxiYWNrcy5nZXQoc2VxKS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIHdpbmRvd1tuYW1lXS5jYWxsYmFja3MuZGVsZXRlKHNlcSk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0aW9uU3RyaW5nKGRlbGl2ZXJSZXN1bHQsIG5hbWUsIHNlcSwgcmVzdWx0KTtcbn1cbmZ1bmN0aW9uIHBhZ2VCaW5kaW5nRGVsaXZlckVycm9yU3RyaW5nKG5hbWUsIHNlcSwgbWVzc2FnZSwgc3RhY2spIHtcbiAgICBmdW5jdGlvbiBkZWxpdmVyRXJyb3IobmFtZSwgc2VxLCBtZXNzYWdlLCBzdGFjaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgd2luZG93W25hbWVdLmNhbGxiYWNrcy5nZXQoc2VxKS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB3aW5kb3dbbmFtZV0uY2FsbGJhY2tzLmRlbGV0ZShzZXEpO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbHVhdGlvblN0cmluZyhkZWxpdmVyRXJyb3IsIG5hbWUsIHNlcSwgbWVzc2FnZSwgc3RhY2spO1xufVxuZnVuY3Rpb24gcGFnZUJpbmRpbmdEZWxpdmVyRXJyb3JWYWx1ZVN0cmluZyhuYW1lLCBzZXEsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gZGVsaXZlckVycm9yVmFsdWUobmFtZSwgc2VxLCB2YWx1ZSkge1xuICAgICAgICB3aW5kb3dbbmFtZV0uY2FsbGJhY2tzLmdldChzZXEpLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIHdpbmRvd1tuYW1lXS5jYWxsYmFja3MuZGVsZXRlKHNlcSk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0aW9uU3RyaW5nKGRlbGl2ZXJFcnJvclZhbHVlLCBuYW1lLCBzZXEsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIG1ha2VQcmVkaWNhdGVTdHJpbmcocHJlZGljYXRlLCBwcmVkaWNhdGVRdWVyeUhhbmRsZXIpIHtcbiAgICBmdW5jdGlvbiBjaGVja1dhaXRGb3JPcHRpb25zKG5vZGUsIHdhaXRGb3JWaXNpYmxlLCB3YWl0Rm9ySGlkZGVuKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB3YWl0Rm9ySGlkZGVuO1xuICAgICAgICBpZiAoIXdhaXRGb3JWaXNpYmxlICYmICF3YWl0Rm9ySGlkZGVuKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IHN0eWxlICYmIHN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nICYmIGhhc1Zpc2libGVCb3VuZGluZ0JveCgpO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gd2FpdEZvclZpc2libGUgPT09IGlzVmlzaWJsZSB8fCB3YWl0Rm9ySGlkZGVuID09PSAhaXNWaXNpYmxlO1xuICAgICAgICByZXR1cm4gc3VjY2VzcyA/IG5vZGUgOiBudWxsO1xuICAgICAgICBmdW5jdGlvbiBoYXNWaXNpYmxlQm91bmRpbmdCb3goKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiAhIShyZWN0LnRvcCB8fCByZWN0LmJvdHRvbSB8fCByZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmVkaWNhdGVRdWVyeUhhbmRsZXJEZWYgPSBwcmVkaWNhdGVRdWVyeUhhbmRsZXJcbiAgICAgICAgPyBgY29uc3QgcHJlZGljYXRlUXVlcnlIYW5kbGVyID0gJHtwcmVkaWNhdGVRdWVyeUhhbmRsZXJ9O2BcbiAgICAgICAgOiAnJztcbiAgICByZXR1cm4gYFxuICAgICgoKSA9PiB7XG4gICAgICAke3ByZWRpY2F0ZVF1ZXJ5SGFuZGxlckRlZn1cbiAgICAgIGNvbnN0IGNoZWNrV2FpdEZvck9wdGlvbnMgPSAke2NoZWNrV2FpdEZvck9wdGlvbnN9O1xuICAgICAgcmV0dXJuICgke3ByZWRpY2F0ZX0pKC4uLmFyZ3MpXG4gICAgfSkoKSBgO1xufVxuYXN5bmMgZnVuY3Rpb24gd2FpdFdpdGhUaW1lb3V0KHByb21pc2UsIHRhc2tOYW1lLCB0aW1lb3V0KSB7XG4gICAgbGV0IHJlamVjdDtcbiAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgVGltZW91dEVycm9yKGB3YWl0aW5nIGZvciAke3Rhc2tOYW1lfSBmYWlsZWQ6IHRpbWVvdXQgJHt0aW1lb3V0fW1zIGV4Y2VlZGVkYCk7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgeCkgPT4gKHJlamVjdCA9IHgpKTtcbiAgICBsZXQgdGltZW91dFRpbWVyID0gbnVsbDtcbiAgICBpZiAodGltZW91dClcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QodGltZW91dEVycm9yKSwgdGltZW91dCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh0aW1lb3V0VGltZXIpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkUHJvdG9jb2xTdHJlYW0oY2xpZW50LCBoYW5kbGUsIHBhdGgpIHtcbiAgICBpZiAoIWlzTm9kZSAmJiBwYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHdyaXRlIHRvIGEgcGF0aCBvdXRzaWRlIG9mIE5vZGUuanMgZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gaXNOb2RlID8gYXdhaXQgaW1wb3J0RlNNb2R1bGUoKSA6IG51bGw7XG4gICAgbGV0IGVvZiA9IGZhbHNlO1xuICAgIGxldCBmaWxlSGFuZGxlO1xuICAgIGlmIChwYXRoICYmIGZzKSB7XG4gICAgICAgIGZpbGVIYW5kbGUgPSBhd2FpdCBmcy5wcm9taXNlcy5vcGVuKHBhdGgsICd3Jyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZnMgPSBbXTtcbiAgICB3aGlsZSAoIWVvZikge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kKCdJTy5yZWFkJywgeyBoYW5kbGUgfSk7XG4gICAgICAgIGVvZiA9IHJlc3BvbnNlLmVvZjtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuZGF0YSwgcmVzcG9uc2UuYmFzZTY0RW5jb2RlZCA/ICdiYXNlNjQnIDogdW5kZWZpbmVkKTtcbiAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgIGlmIChwYXRoICYmIGZzKSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoZmlsZUhhbmRsZSwgYnVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aClcbiAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgIGF3YWl0IGNsaWVudC5zZW5kKCdJTy5jbG9zZScsIHsgaGFuZGxlIH0pO1xuICAgIGxldCByZXN1bHRCdWZmZXIgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYnVmcyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICByZXR1cm4gcmVzdWx0QnVmZmVyO1xuICAgIH1cbn1cbi8qKlxuICogTG9hZHMgdGhlIE5vZGUgZnMgcHJvbWlzZXMgQVBJLiBOZWVkZWQgYmVjYXVzZSBvbiBOb2RlIDEwLjE3IGFuZCBiZWxvdyxcbiAqIGZzLnByb21pc2VzIGlzIGV4cGVyaW1lbnRhbCwgYW5kIHRoZXJlZm9yZSBub3QgbWFya2VkIGFzIGVudW1lcmFibGUuIFRoYXRcbiAqIG1lYW5zIHdoZW4gVHlwZVNjcmlwdCBjb21waWxlcyBhbiBgaW1wb3J0KCdmcycpYCwgaXRzIGhlbHBlciBkb2Vzbid0IHNwb3QgdGhlXG4gKiBwcm9taXNlcyBkZWNsYXJhdGlvbiBhbmQgdGhlcmVmb3JlIG9uIE5vZGUgPDEwLjE3IHlvdSBnZXQgYW4gZXJyb3IgYXNcbiAqIGZzLnByb21pc2VzIGlzIHVuZGVmaW5lZCBpbiBjb21waWxlZCBUeXBlU2NyaXB0IGxhbmQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wdXBwZXRlZXIvcHVwcGV0ZWVyL2lzc3Vlcy82NTQ4IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogT25jZSBOb2RlIDEwIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgKEFwcmlsIDIwMjEpIHdlIGNhbiByZW1vdmUgdGhpcyBhbmQgdXNlXG4gKiBgKGF3YWl0IGltcG9ydCgnZnMnKSkucHJvbWlzZXNgLlxuICovXG5hc3luYyBmdW5jdGlvbiBpbXBvcnRGU01vZHVsZSgpIHtcbiAgICBpZiAoIWlzTm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHRoZSBmcyBtb2R1bGUgQVBJIG91dHNpZGUgb2YgTm9kZS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSBhd2FpdCBpbXBvcnQoJ2ZzJyk7XG4gICAgaWYgKGZzLnByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBmcztcbiAgICB9XG4gICAgcmV0dXJuIGZzLmRlZmF1bHQ7XG59XG5leHBvcnQgY29uc3QgaGVscGVyID0ge1xuICAgIGV2YWx1YXRpb25TdHJpbmcsXG4gICAgcGFnZUJpbmRpbmdJbml0U3RyaW5nLFxuICAgIHBhZ2VCaW5kaW5nRGVsaXZlclJlc3VsdFN0cmluZyxcbiAgICBwYWdlQmluZGluZ0RlbGl2ZXJFcnJvclN0cmluZyxcbiAgICBwYWdlQmluZGluZ0RlbGl2ZXJFcnJvclZhbHVlU3RyaW5nLFxuICAgIG1ha2VQcmVkaWNhdGVTdHJpbmcsXG4gICAgcmVhZFByb3RvY29sU3RyZWFtLFxuICAgIHdhaXRXaXRoVGltZW91dCxcbiAgICB3YWl0Rm9yRXZlbnQsXG4gICAgaXNTdHJpbmcsXG4gICAgaXNOdW1iZXIsXG4gICAgaW1wb3J0RlNNb2R1bGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lcixcbiAgICByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgICB2YWx1ZUZyb21SZW1vdGVPYmplY3QsXG4gICAgZ2V0RXhjZXB0aW9uTWVzc2FnZSxcbiAgICByZWxlYXNlT2JqZWN0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgY29uc3QgaXNOb2RlID0gISEodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBQdXBwZXRlZXIgfSBmcm9tICcuL2NvbW1vbi9QdXBwZXRlZXIuanMnO1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVQdXBwZXRlZXJXZWIgPSAocGFja2FnZU5hbWUpID0+IHtcbiAgICBjb25zdCBpc1B1cHBldGVlckNvcmUgPSBwYWNrYWdlTmFtZSA9PT0gJ3B1cHBldGVlci1jb3JlJztcbiAgICByZXR1cm4gbmV3IFB1cHBldGVlcih7XG4gICAgICAgIGlzUHVwcGV0ZWVyQ29yZSxcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0aWFsaXplLXdlYi5qcy5tYXAiLCIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBpbml0aWFsaXplUHVwcGV0ZWVyV2ViIH0gZnJvbSAnLi9pbml0aWFsaXplLXdlYi5qcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmlmIChpc05vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBydW4gUHVwcGV0ZWVyLVdlYiBpbiBhIE5vZGUgZW52aXJvbm1lbnQnKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGluaXRpYWxpemVQdXBwZXRlZXJXZWIoJ3B1cHBldGVlcicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLmpzLm1hcCIsIi8qKlxuICogTWl0dDogVGlueSAofjIwMGIpIGZ1bmN0aW9uYWwgZXZlbnQgZW1pdHRlciAvIHB1YnN1Yi5cbiAqIEBuYW1lIG1pdHRcbiAqIEByZXR1cm5zIHtNaXR0fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KGFsbCkge1xuICAgIGFsbCA9IGFsbCB8fCBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTWFwIG9mIGV2ZW50IG5hbWVzIHRvIHJlZ2lzdGVyZWQgaGFuZGxlciBmdW5jdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBhbGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSB0eXBlIFR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvciwgb3IgYFwiKlwiYCBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRvIGNhbGwgaW4gcmVzcG9uc2UgdG8gZ2l2ZW4gZXZlbnRcbiAgICAgICAgICogQG1lbWJlck9mIG1pdHRcbiAgICAgICAgICovXG4gICAgICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gYWxsLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICAgICAgICBhbGwuc2V0KHR5cGUsIFtoYW5kbGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0gdHlwZSBUeXBlIG9mIGV2ZW50IHRvIHVucmVnaXN0ZXIgYGhhbmRsZXJgIGZyb20sIG9yIGBcIipcImBcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICAgICAgICAgKiBAbWVtYmVyT2YgbWl0dFxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gYWxsLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludm9rZSBhbGwgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgICAgICAgKiBJZiBwcmVzZW50LCBgXCIqXCJgIGhhbmRsZXJzIGFyZSBpbnZva2VkIGFmdGVyIHR5cGUtbWF0Y2hlZCBoYW5kbGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogTWFudWFsbHkgZmlyaW5nIFwiKlwiIGhhbmRsZXJzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBpbnZva2VcbiAgICAgICAgICogQHBhcmFtIHtBbnl9IFtldnRdIEFueSB2YWx1ZSAob2JqZWN0IGlzIHJlY29tbWVuZGVkIGFuZCBwb3dlcmZ1bCksIHBhc3NlZCB0byBlYWNoIGhhbmRsZXJcbiAgICAgICAgICogQG1lbWJlck9mIG1pdHRcbiAgICAgICAgICovXG4gICAgICAgIGVtaXQodHlwZSwgZXZ0KSB7XG4gICAgICAgICAgICAoYWxsLmdldCh0eXBlKSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXIpID0+IHsgaGFuZGxlcihldnQpOyB9KTtcbiAgICAgICAgICAgIChhbGwuZ2V0KCcqJykgfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyKSA9PiB7IGhhbmRsZXIodHlwZSwgZXZ0KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcInB1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2NvbW1vbi9Ccm93c2VyV2ViU29ja2V0VHJhbnNwb3J0XCIpO1xudmFyIHdlYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci93ZWJcIikpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBwcm90b2NvbENvbW1hbmRzID0gT2JqZWN0LmtleXModHlwZXNfMS5Qcm90b2NvbENvbW1hbmRzKTtcbnZhciBicm93c2VyO1xudmFyIHBhZ2U7XG52YXIgY2xpZW50O1xudmFyIHNlbmRQYXJlbnRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xufTtcbnZhciBjbG9zZVdvcmtlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBpZiAoYnJvd3NlcilcbiAgICAgICAgICAgIGJyb3dzZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gWzIsIHNlbGYuY2xvc2UoKV07XG4gICAgfSk7XG59KTsgfTtcbnZhciBvblNjcmVlbmNhc3RGcmFtZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkYXRhID0gX2EuZGF0YSwgc2Vzc2lvbklkID0gX2Euc2Vzc2lvbklkLCBtZXRhZGF0YSA9IF9hLm1ldGFkYXRhO1xuICAgIGNvbnNvbGUubG9nKCdPblNjcmVlbmNhc3RGcmFtZS4gc2Vzc2lvbklkOicsIHNlc3Npb25JZCwgJyBtZXRhZGF0YTonLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2NsaWVudCBleGlzdHMnKTtcbiAgICAgICAgY2xpZW50XG4gICAgICAgICAgICAuc2VuZCgnUGFnZS5zY3JlZW5jYXN0RnJhbWVBY2snLCB7IHNlc3Npb25JZDogc2Vzc2lvbklkIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zb2xlLmxvZygnc2VudCBhY2sgZm9yIHNlc3Npb25pZCcsIHNlc3Npb25JZCk7IH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc29sZS5lcnJvcignQ291bGQgbm90IHNlbmQgc2NyZWVuY2FzdCBhY2snKTsgfSk7XG4gICAgICAgIHNlbmRQYXJlbnRNZXNzYWdlKHsgY29tbWFuZDogdHlwZXNfMS5Xb3JrZXJDb21tYW5kcy5zY3JlZW5jYXN0RnJhbWUsIGRhdGE6IGRhdGEgfSk7XG4gICAgfVxufTtcbnZhciBzdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YXJnZXRJZCwgYnJvd3NlcldTRW5kcG9pbnQsIF9hLCBxdWFsaXR5LCBwYWdlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IGRhdGEudGFyZ2V0SWQsIGJyb3dzZXJXU0VuZHBvaW50ID0gZGF0YS5icm93c2VyV1NFbmRwb2ludCwgX2EgPSBkYXRhLnF1YWxpdHksIHF1YWxpdHkgPSBfYSA9PT0gdm9pZCAwID8gMTAwIDogX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB3ZWJfMS5kZWZhdWx0LmNvbm5lY3QoeyBicm93c2VyV1NFbmRwb2ludDogYnJvd3NlcldTRW5kcG9pbnQgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBicm93c2VyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghYnJvd3Nlcikge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUGFyZW50TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiB0eXBlc18xLldvcmtlckNvbW1hbmRzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJcXHUyNkEwXFx1RkUwRiBDb3VsZG4ndCBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIFxcXCJcIiArIGJyb3dzZXJXU0VuZHBvaW50ICsgXCJcXFwiLiBJcyB5b3VyIGJyb3dzZXIgcnVubmluZz9cIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc2VsZi5jbG9zZSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJvd3Nlci5vbmNlKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRQYXJlbnRNZXNzYWdlKHsgY29tbWFuZDogdHlwZXNfMS5Xb3JrZXJDb21tYW5kcy5icm93c2VyQ2xvc2UsIGRhdGE6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlV29ya2VyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBicm93c2VyLnBhZ2VzKCldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHBhZ2VzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYWdlczonLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgcGFnZSA9IHBhZ2VzLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudGFyZ2V0KCkuX3RhcmdldElkID09PSB0YXJnZXRJZDsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRQYXJlbnRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IHR5cGVzXzEuV29ya2VyQ29tbWFuZHMuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlxcdTI2QTBcXHVGRTBGIENvdWxkbid0IGZpbmQgdGFyZ2V0IHdpdGggdGFyZ2V0SWQgXCIgKyB0YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc2VsZi5jbG9zZSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBwYWdlLnRhcmdldCgpLmNyZWF0ZUNEUFNlc3Npb24oKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2xpZW50ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2xpZW50LnNlbmQoJ1BhZ2Uuc3RhcnRTY3JlZW5jYXN0JywgeyBmb3JtYXQ6ICdqcGVnJywgcXVhbGl0eTogcXVhbGl0eSB9KV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNsaWVudC5vbignUGFnZS5zY3JlZW5jYXN0RnJhbWUnLCBvblNjcmVlbmNhc3RGcmFtZSk7XG4gICAgICAgICAgICAgICAgc2VuZFBhcmVudE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiB0eXBlc18xLldvcmtlckNvbW1hbmRzLnN0YXJ0Q29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiBwYWdlLnRhcmdldCgpLl90YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBzZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHBhZ2UgJiYgcGFnZS5zZXRWaWV3cG9ydChkYXRhKTtcbn07XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIGNvbW1hbmQsIGRhdGEsIHByb3RvY29sQ29tbWFuZDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIF9hID0gbWVzc2FnZS5kYXRhLCBjb21tYW5kID0gX2EuY29tbWFuZCwgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgIGlmIChjb21tYW5kID09PSB0eXBlc18xLkhvc3RDb21tYW5kcy5zdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIFsyLCBzdGFydChkYXRhKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQgPT09IHR5cGVzXzEuSG9zdENvbW1hbmRzLnNldFZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gWzIsIHNldFZpZXdwb3J0KGRhdGEpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gdHlwZXNfMS5Ib3N0Q29tbWFuZHMuY2xvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiwgY2xvc2VXb3JrZXIoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3RvY29sQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGlmICghY2xpZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICBwcm90b2NvbENvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgICAgcmV0dXJuIFsyLCBjbGllbnQuc2VuZChwcm90b2NvbENvbW1hbmQsIGRhdGEpXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmRlYnVnKFwiVW5rbm93biB3b3JrZXIgY29tbWFuZDpcIiwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBbMl07XG4gICAgfSk7XG59KTsgfSwgZmFsc2UpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0hWd2NHVjBaV1Z5TG5kdmNtdGxjaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMM055WXk5d2RYQndaWFJsWlhJdWQyOXlhMlZ5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMEZCUjBFc05rVkJRVEpGTzBGQlJUTkZMRFpGUVVFMlJEdEJRVVUzUkN4cFEwRkJhMFk3UVVGRmJFWXNTVUZCVFN4blFrRkJaMElzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMSGRDUVVGblFpeERRVUZETEVOQlFVTTdRVUZGZGtRc1NVRkJTU3hQUVVGMVFpeERRVUZETzBGQlF6VkNMRWxCUVVrc1NVRkJhVUlzUTBGQlF6dEJRVU4wUWl4SlFVRkpMRTFCUVhsQ0xFTkJRVU03UVVGRk9VSXNTVUZCVFN4cFFrRkJhVUlzUjBGQlJ5eFZRVUZETEU5QlFXZENPMGxCUjNwRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1FVRkROVUlzUTBGQlF5eERRVUZETzBGQmFVSkdMRWxCUVUwc1YwRkJWeXhIUVVGSE96dFJRVU5zUWl4SlFVRkpMRTlCUVU4N1dVRkJSU3hQUVVGUExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdVVUZEYkVNc1YwRkJUeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVTTdPMHRCUTNKQ0xFTkJRVU03UVVGRlJpeEpRVUZOTEdsQ1FVRnBRaXhIUVVGSExGVkJRVU1zUlVGUk1VSTdVVUZRUXl4SlFVRkpMRlZCUVVFc1JVRkRTaXhUUVVGVExHVkJRVUVzUlVGRFZDeFJRVUZSTEdOQlFVRTdTVUZOVWl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExDdENRVUVyUWl4RlFVRkZMRk5CUVZNc1JVRkJSU3haUVVGWkxFVkJRVVVzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMmhITEVsQlFVa3NUVUZCVFN4RlFVRkZPMUZCUTFZc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVTTNRaXhOUVVGTk8yRkJRMGdzU1VGQlNTeERRVUZETEhsQ1FVRjVRaXhGUVVGRkxFVkJRVVVzVTBGQlV5eFhRVUZCTEVWQlFVVXNRMEZCUXp0aFFVTTVReXhKUVVGSkxFTkJRVU1zWTBGQlRTeFBRVUZCTEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc2QwSkJRWGRDTEVWQlFVVXNVMEZCVXl4RFFVRkRMRVZCUVdoRUxFTkJRV2RFTEVOQlFVTTdZVUZETlVRc1MwRkJTeXhEUVVGRExHTkJRVTBzVDBGQlFTeFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMQ3RDUVVFclFpeERRVUZETEVWQlFUbERMRU5CUVRoRExFTkJRVU1zUTBGQlF6dFJRVU12UkN4cFFrRkJhVUlzUTBGQlF5eEZRVUZGTEU5QlFVOHNSVUZCUlN4elFrRkJZeXhEUVVGRExHVkJRV1VzUlVGQlJTeEpRVUZKTEUxQlFVRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1MwRkRkRVU3UVVGRFNDeERRVUZETEVOQlFVTTdRVUZIUml4SlFVRk5MRXRCUVVzc1IwRkJSeXhWUVVGUExFbEJRWEZDT3pzN096dG5Ra0ZEYUVNc1VVRkJVU3hIUVVGMVF5eEpRVUZKTEZOQlFUTkRMRVZCUVVVc2FVSkJRV2xDTEVkQlFXOUNMRWxCUVVrc2EwSkJRWGhDTEVWQlFVVXNTMEZCYTBJc1NVRkJTU3hSUVVGVUxFVkJRV0lzVDBGQlR5eHRRa0ZCUnl4SFFVRkhMRXRCUVVFc1EwRkJWVHRuUWtGRmJFUXNWMEZCVFN4aFFVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVVzYVVKQlFXbENMRzFDUVVGQkxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4VlFVRkRMRXRCUVVzN2QwSkJRMjVGTEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03ZDBKQlEzSkNMRTlCUVU4c1UwRkJVeXhEUVVGRE8yOUNRVU51UWl4RFFVRkRMRU5CUVVNc1JVRkJRVHM3WjBKQlNFWXNUMEZCVHl4SFFVRkhMRk5CUjFJc1EwRkJRenRuUWtGRlNDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RlFVRkZPMjlDUVVOYUxHbENRVUZwUWl4RFFVRkRPM2RDUVVOb1FpeFBRVUZQTEVWQlFVVXNjMEpCUVdNc1EwRkJReXhMUVVGTE8zZENRVU0zUWl4SlFVRkpMRVZCUVVVc2IwUkJRWFZETEdsQ1FVRnBRaXhwUTBGQk5rSTdjVUpCUXpWR0xFTkJRVU1zUTBGQlF6dHZRa0ZEU0N4WFFVRlBMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzUlVGQlF6dHBRa0ZEY2tJN1owSkJSVVFzVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRVZCUVVVN2IwSkJRek5DTEdsQ1FVRnBRaXhEUVVGRExFVkJRVVVzVDBGQlR5eEZRVUZGTEhOQ1FVRmpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRPMjlDUVVONFJTeFhRVUZYTEVWQlFVVXNRMEZCUXp0blFrRkRhRUlzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTFjc1YwRkJUU3hQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVRTdPMmRDUVVFM1FpeExRVUZMTEVkQlFVY3NVMEZCY1VJN1owSkJRMjVETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzJkQ1FVTTNRaXhKUVVGSkxFZEJRVWNzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4VlFVRkRMRU5CUVU4c1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4VFFVRlRMRXRCUVVzc1VVRkJVU3hGUVVGcVF5eERRVUZwUXl4RFFVRkRMRU5CUVVNN1owSkJRMnhGTEVsQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVVVN2IwSkJRMVFzYVVKQlFXbENMRU5CUVVNN2QwSkJRMmhDTEU5QlFVOHNSVUZCUlN4elFrRkJZeXhEUVVGRExFdEJRVXM3ZDBKQlF6ZENMRWxCUVVrc1JVRkJSU3h4UkVGQmVVTXNVVUZCVlR0eFFrRkRNVVFzUTBGQlF5eERRVUZETzI5Q1FVTklMRmRCUVU4c1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZETzJsQ1FVTnlRanRuUWtGRFVTeFhRVUZOTEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4RlFVRkJPenRuUWtGQkwwTXNUVUZCVFN4SFFVRkhMRk5CUVhORExFTkJRVU03WjBKQlJXaEVMRmRCUVUwc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeE5RVUZOTEVWQlFVVXNUMEZCVHl4VFFVRkJMRVZCUVVVc1EwRkJReXhGUVVGQk96dG5Ra0ZCZEVVc1UwRkJjMFVzUTBGQlF6dG5Ra0ZGZGtVc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF5eHpRa0ZCYzBJc1JVRkJSU3hwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMmRDUVVWeVJDeHBRa0ZCYVVJc1EwRkJRenR2UWtGRGFFSXNUMEZCVHl4RlFVRkZMSE5DUVVGakxFTkJRVU1zWVVGQllUdHZRa0ZEY2tNc1NVRkJTU3hGUVVGRk8zZENRVU5LTEZGQlFWRXNSVUZCUlN4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zVTBGQlV6dHhRa0ZEYkVNN2FVSkJRMFlzUTBGQlF5eERRVUZET3pzN08wdEJRMG9zUTBGQlF6dEJRVVZHTEVsQlFVMHNWMEZCVnl4SFFVRkhMRlZCUVVNc1NVRkJhMFU3U1VGRGNrWXNUMEZCUVN4SlFVRkpMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZCT1VJc1EwRkJPRUlzUTBGQlF6dEJRVWRxUXl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlEyNUNMRk5CUVZNc1JVRkZWQ3hWUVVGUExFOUJRVTg3T3p0UlFVTk9MRXRCUVc5Q0xFOUJRVThzUTBGQlF5eEpRVUZsTEVWQlFYcERMRTlCUVU4c1lVRkJRU3hGUVVGRkxFbEJRVWtzVlVGQlFTeERRVUUyUWp0UlFVVnNSQ3hKUVVGSkxFOUJRVThzUzBGQlN5eHZRa0ZCV1N4RFFVRkRMRXRCUVVzc1JVRkJSVHRaUVVOc1F5eFhRVUZQTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJRenRUUVVOd1FqdFJRVVZFTEVsQlFVa3NUMEZCVHl4TFFVRkxMRzlDUVVGWkxFTkJRVU1zVjBGQlZ5eEZRVUZGTzFsQlEzaERMRmRCUVU4c1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZETzFOQlF6RkNPMUZCUlVRc1NVRkJTU3hQUVVGUExFdEJRVXNzYjBKQlFWa3NRMEZCUXl4TFFVRkxMRVZCUVVVN1dVRkRiRU1zVjBGQlR5eFhRVUZYTEVWQlFVVXNSVUZCUXp0VFFVTjBRanRSUVVWRUxFbEJRVWtzWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTzFsQlJYUkRMRWxCUVVrc1EwRkJReXhOUVVGTk8yZENRVUZGTEZkQlFVODdXVUZEWkN4bFFVRmxMRWRCUVVjc1QwRkJNa0lzUTBGQlF6dFpRVU53UkN4WFFVRlBMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RlFVRkRPMU5CUXpORE8xRkJSVVFzVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4NVFrRkJlVUlzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXpzN08wdEJRMjVFTEVWQlEwUXNTMEZCU3l4RFFVTk9MRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29ya2VyQ29tbWFuZHMgPSBleHBvcnRzLkhvc3RDb21tYW5kcyA9IGV4cG9ydHMuUHJvdG9jb2xDb21tYW5kcyA9IHZvaWQgMDtcbnZhciBQcm90b2NvbENvbW1hbmRzO1xuKGZ1bmN0aW9uIChQcm90b2NvbENvbW1hbmRzKSB7XG4gICAgUHJvdG9jb2xDb21tYW5kc1tcIklucHV0LmRpc3BhdGNoS2V5RXZlbnRcIl0gPSBcIklucHV0LmRpc3BhdGNoS2V5RXZlbnRcIjtcbiAgICBQcm90b2NvbENvbW1hbmRzW1wiSW5wdXQuZW11bGF0ZVRvdWNoRnJvbU1vdXNlRXZlbnRcIl0gPSBcIklucHV0LmVtdWxhdGVUb3VjaEZyb21Nb3VzZUV2ZW50XCI7XG4gICAgUHJvdG9jb2xDb21tYW5kc1tcIlBhZ2UucmVsb2FkXCJdID0gXCJQYWdlLnJlbG9hZFwiO1xuICAgIFByb3RvY29sQ29tbWFuZHNbXCJQYWdlLm5hdmlnYXRlVG9IaXN0b3J5RW50cnlcIl0gPSBcIlBhZ2UubmF2aWdhdGVUb0hpc3RvcnlFbnRyeVwiO1xufSkoUHJvdG9jb2xDb21tYW5kcyA9IGV4cG9ydHMuUHJvdG9jb2xDb21tYW5kcyB8fCAoZXhwb3J0cy5Qcm90b2NvbENvbW1hbmRzID0ge30pKTtcbnZhciBIb3N0Q29tbWFuZHM7XG4oZnVuY3Rpb24gKEhvc3RDb21tYW5kcykge1xuICAgIEhvc3RDb21tYW5kc1tcInN0YXJ0XCJdID0gXCJzdGFydFwiO1xuICAgIEhvc3RDb21tYW5kc1tcInJ1blwiXSA9IFwicnVuXCI7XG4gICAgSG9zdENvbW1hbmRzW1wiY2xvc2VcIl0gPSBcImNsb3NlXCI7XG4gICAgSG9zdENvbW1hbmRzW1wic2V0Vmlld3BvcnRcIl0gPSBcInNldFZpZXdwb3J0XCI7XG59KShIb3N0Q29tbWFuZHMgPSBleHBvcnRzLkhvc3RDb21tYW5kcyB8fCAoZXhwb3J0cy5Ib3N0Q29tbWFuZHMgPSB7fSkpO1xudmFyIFdvcmtlckNvbW1hbmRzO1xuKGZ1bmN0aW9uIChXb3JrZXJDb21tYW5kcykge1xuICAgIFdvcmtlckNvbW1hbmRzW1wic3RhcnRDb21wbGV0ZVwiXSA9IFwic3RhcnRDb21wbGV0ZVwiO1xuICAgIFdvcmtlckNvbW1hbmRzW1wicnVuQ29tcGxldGVcIl0gPSBcInJ1bkNvbXBsZXRlXCI7XG4gICAgV29ya2VyQ29tbWFuZHNbXCJzY3JlZW5jYXN0RnJhbWVcIl0gPSBcInNjcmVlbmNhc3RGcmFtZVwiO1xuICAgIFdvcmtlckNvbW1hbmRzW1wiYnJvd3NlckNsb3NlXCJdID0gXCJicm93c2VyQ2xvc2VcIjtcbiAgICBXb3JrZXJDb21tYW5kc1tcImVycm9yXCJdID0gXCJlcnJvclwiO1xufSkoV29ya2VyQ29tbWFuZHMgPSBleHBvcnRzLldvcmtlckNvbW1hbmRzIHx8IChleHBvcnRzLldvcmtlckNvbW1hbmRzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRIbHdaWE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmRIbHdaWE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRMEVzU1VGQldTeG5Ra0ZMV0R0QlFVeEVMRmRCUVZrc1owSkJRV2RDTzBsQlF6RkNMSEZGUVVGdFJDeERRVUZCTzBsQlEyNUVMSGxHUVVGMVJTeERRVUZCTzBsQlEzWkZMQ3REUVVFMlFpeERRVUZCTzBsQlF6ZENMQ3RGUVVFMlJDeERRVUZCTzBGQlF5OUVMRU5CUVVNc1JVRk1WeXhuUWtGQlowSXNSMEZCYUVJc2QwSkJRV2RDTEV0QlFXaENMSGRDUVVGblFpeFJRVXN6UWp0QlFVVkVMRWxCUVZrc1dVRkxXRHRCUVV4RUxGZEJRVmtzV1VGQldUdEpRVU4wUWl3clFrRkJhVUlzUTBGQlFUdEpRVU5xUWl3eVFrRkJZU3hEUVVGQk8wbEJRMklzSzBKQlFXbENMRU5CUVVFN1NVRkRha0lzTWtOQlFUWkNMRU5CUVVFN1FVRkRMMElzUTBGQlF5eEZRVXhYTEZsQlFWa3NSMEZCV2l4dlFrRkJXU3hMUVVGYUxHOUNRVUZaTEZGQlMzWkNPMEZCUlVRc1NVRkJXU3hqUVUxWU8wRkJUa1FzVjBGQldTeGpRVUZqTzBsQlEzaENMR2xFUVVGcFF5eERRVUZCTzBsQlEycERMRFpEUVVFMlFpeERRVUZCTzBsQlF6ZENMSEZFUVVGeFF5eERRVUZCTzBsQlEzSkRMQ3REUVVFclFpeERRVUZCTzBsQlF5OUNMR2xEUVVGcFFpeERRVUZCTzBGQlEyNUNMRU5CUVVNc1JVRk9WeXhqUVVGakxFZEJRV1FzYzBKQlFXTXNTMEZCWkN4elFrRkJZeXhSUVUxNlFpSjkiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwidmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gKG9iaikgPT4gKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSA6IChvYmopID0+IChvYmouX19wcm90b19fKTtcbnZhciBsZWFmUHJvdG90eXBlcztcbi8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLy8gbW9kZSAmIDE2OiByZXR1cm4gdmFsdWUgd2hlbiBpdCdzIFByb21pc2UtbGlrZVxuLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0aWYobW9kZSAmIDEpIHZhbHVlID0gdGhpcyh2YWx1ZSk7XG5cdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcblx0XHRpZigobW9kZSAmIDQpICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0XHRpZigobW9kZSAmIDE2KSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdHZhciBkZWYgPSB7fTtcblx0bGVhZlByb3RvdHlwZXMgPSBsZWFmUHJvdG90eXBlcyB8fCBbbnVsbCwgZ2V0UHJvdG8oe30pLCBnZXRQcm90byhbXSksIGdldFByb3RvKGdldFByb3RvKV07XG5cdGZvcih2YXIgY3VycmVudCA9IG1vZGUgJiAyICYmIHZhbHVlOyB0eXBlb2YgY3VycmVudCA9PSAnb2JqZWN0JyAmJiAhfmxlYWZQcm90b3R5cGVzLmluZGV4T2YoY3VycmVudCk7IGN1cnJlbnQgPSBnZXRQcm90byhjdXJyZW50KSkge1xuXHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goKGtleSkgPT4gKGRlZltrZXldID0gKCkgPT4gKHZhbHVlW2tleV0pKSk7XG5cdH1cblx0ZGVmWydkZWZhdWx0J10gPSAoKSA9PiAodmFsdWUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGRlZik7XG5cdHJldHVybiBucztcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLmJ1bmRsZS5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBjaHVua3Ncbi8vIFwiMVwiIG1lYW5zIFwiYWxyZWFkeSBsb2FkZWRcIlxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJwdXBwZXRlZXIud29ya2VyXCI6IDFcbn07XG5cbi8vIGltcG9ydFNjcmlwdHMgY2h1bmsgbG9hZGluZ1xudmFyIGluc3RhbGxDaHVuayA9IChkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0d2hpbGUoY2h1bmtJZHMubGVuZ3RoKVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkcy5wb3AoKV0gPSAxO1xuXHRwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcbn07XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaSA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHQvLyBcIjFcIiBpcyB0aGUgc2lnbmFsIGZvciBcImFscmVhZHkgbG9hZGVkXCJcblx0aWYoIWluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRpbXBvcnRTY3JpcHRzKF9fd2VicGFja19yZXF1aXJlX18ucCArIF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKSk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgY2h1bmtMb2FkaW5nR2xvYmFsID0gc2VsZltcIndlYnBhY2tDaHVua3B1cHBldGVlcl9leHRyYV9wbHVnaW5fcG9ydGFsX2Zyb250ZW5kXCJdID0gc2VsZltcIndlYnBhY2tDaHVua3B1cHBldGVlcl9leHRyYV9wbHVnaW5fcG9ydGFsX2Zyb250ZW5kXCJdIHx8IFtdO1xudmFyIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uID0gY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSBpbnN0YWxsQ2h1bms7XG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3QiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wdXBwZXRlZXIud29ya2VyLnRzXCIpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==